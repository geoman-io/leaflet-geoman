{"version":3,"sources":["leaflet.pm.js","Drag.js","Overlap.js","Snapping.js","L.PM.js","L.PM.Map.js","L.PM.Draw.js","L.PM.Edit.js","Draw/L.PM.Draw.Line.js","Draw/L.PM.Draw.Poly.js","Edit/L.PM.Edit.LayerGroup.js","Edit/L.PM.Edit.Line.js","Edit/L.PM.Edit.Poly.js","Toolbar/L.Controls.js","Toolbar/L.PM.Toolbar.js"],"names":["DragMixin","_initDraggableLayer","_this","this","_tempDragCoord","el","_layer","_path","L","DomUtil","addClass","onMouseUp","_map","dragging","enable","off","_dragging","_initMarkers","window","setTimeout","removeClass","fire","_fireEdit","onMouseMove","e","bringToFront","disable","_markerGroup","clearLayers","_onLayerDrag","on","latlng","deltaLatLng","lat","lng","coords","_latlngs","newLatLngs","map","currentLatLng","setLatLngs","redraw","OverlapMixin","_applyPossibleCoordsChanges","_tempPolygon","latlngs","getLayers","getLatLngs","_poly","_drawTemporaryPolygon","geoJson","setStyle","opacity","fillOpacity","addTo","bringToBack","_handleOverlap","mainPoly","layers","_layerGroup","changed","resultingGeoJson","toGeoJSON","filter","layer","Object","is","intersect","turf","console","warn","difference","geometry","type","remove","SnapMixin","_initSnappableMarkers","options","snapDistance","_markers","forEach","marker","_handleSnapping","_cleanupSnapping","_unsnap","_snapLatLng","_snapList","debugIndicatorLines","line","undefined","_createSnapList","length","target","closestLayer","_calcClosestLayer","getLatLng","snapLatLng","_checkPrioritiySnapping","minDistance","eventInfo","segment","layerInteractedWith","distance","setLatLng","_onMarkerDrag","A","B","C","distanceAC","_getDistance","distanceBC","closestVertexLatLng","shortestDistance","priorityDistance","snapLatlng","_this2","eachLayer","Polyline","push","debugLine","polyline","color","_this3","index","results","_calcLayerDistances","_this4","closedShape","Polygon","P","closestSegment","coord","nextIndex","_getDistanceToSegment","_getClosestPointOnSegment","latlngA","latlngB","maxzoom","getMaxZoom","Infinity","getZoom","project","closest","LineUtil","closestPointOnSegment","unproject","latLngToLayerPoint","pointToSegmentDistance","distanceTo","PM","initialize","initLayerGroup","pm","Edit","LayerGroup","initPolygon","Poly","initPolyline","Line","initMap","Map","addInitHook","Class","extend","Draw","Toolbar","addControls","enableDraw","shape","arguments","disableDraw","removeLayer","_layers","toggleRemoval","enabled","globalEditEnabled","_globalEditMode","toggleGlobalEditMode","shapes","getShapes","Error","join","addButton","includes","_shape","toolbarButtonName","_enabled","_polyline","addLayer","_hintline","dashArray","_container","style","cursor","_createPolygonPoint","_syncHintLine","toggleButton","toggle","polyPoints","lastPolygonPoint","first","addLatLng","_createMarker","_finishShape","polylineLayer","Marker","draggable","icon","divIcon","className","polygonLayer","polygon","layerGroup","availableEvents","event","_fireEvent","getOptions","fireEvent","toggleEdit","_options","find","poly","k","_createMiddleMarker","snappable","_origLatLng","_index","_onMarkerDragStart","_onMarkerDragEnd","_removeMarker","leftM","rightM","_calcMiddleLatLng","middleMarker","middleIcon","setIcon","_middleMarkerNext","_middleMarkerPrev","_addMarker","newM","splice","i","leftMarkerIndex","rightMarkerIndex","m","nextMarkerIndex","prevMarkerIndex","_latlng","markerLatLng","prevMarkerLatLng","nextMarkerLatLng","middleMarkerNextLatLng","middleMarkerPrevLatLng","markerEvent","edited","latlng1","latlng2","p1","p2","_add","_divideBy","Control","PMButton","position","_button","setButton","onAdd","container","buttonsDomNode","_makeButton","appendChild","onRemove","button","iconUrl","onClick","afterClick","doToggle","toggleStatus","disableOtherButtons","getText","text","getIconUrl","destroy","_update","_applyStyleClasses","toggled","onCreate","_triggerClick","_clicked","newButton","create","image","setAttribute","DomEvent","addListener","triggerClickOnToggledButtons","disableClickPropagation","drawPolygon","drawPolyline","editPolygon","dragPolygon","deleteLayer","buttons","_defineButtons","getButtons","Util","setOptions","_showHideButtons","_addButton","name","exceptThisButton","status","deleteButton","drawPolyButton","drawLineButton","editButton","dragButton","btn"],"mappings":"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","file":"leaflet.pm.min.js","sourcesContent":["'use strict';\n\nvar DragMixin = {\n    _initDraggableLayer: function _initDraggableLayer() {\n        var _this = this;\n\n        // temporary coord variable for delta calculation\n        this._tempDragCoord = null;\n\n        // add CSS class\n        var el = this._layer._path;\n        L.DomUtil.addClass(el, 'leaflet-pm-draggable');\n\n        var onMouseUp = function onMouseUp() {\n            // re-enable map drag\n            _this._layer._map.dragging.enable();\n\n            // clear up mousemove event\n            _this._layer._map.off('mousemove');\n\n            // clear up mouseup event\n            _this._layer.off('mouseup');\n\n            // if no drag happened, don't do anything\n            if (!_this._dragging) {\n                return false;\n            }\n\n            // show markers again\n            _this._initMarkers();\n\n            // timeout to prevent click event after drag :-/\n            // TODO: do it better as soon as leaflet has a way to do it better :-)\n            window.setTimeout(function () {\n                // set state\n                _this._dragging = false;\n                L.DomUtil.removeClass(el, 'leaflet-pm-dragging');\n\n                // fire pm:dragend event\n                _this._layer.fire('pm:dragend');\n\n                // fire edit\n                _this._fireEdit();\n            }, 10);\n\n            return true;\n        };\n\n        var onMouseMove = function onMouseMove(e) {\n            if (!_this._dragging) {\n                // set state\n                _this._dragging = true;\n                L.DomUtil.addClass(el, 'leaflet-pm-dragging');\n\n                // bring it to front to prevent drag interception\n                _this._layer.bringToFront();\n\n                // disbale map drag\n                _this._layer._map.dragging.disable();\n\n                // hide markers\n                _this._markerGroup.clearLayers();\n\n                // fire pm:dragstart event\n                _this._layer.fire('pm:dragstart');\n            }\n\n            _this._onLayerDrag(e);\n        };\n\n        this._layer.on('mousedown', function (e) {\n            // save for delta calculation\n            _this._tempDragCoord = e.latlng;\n\n            _this._layer.on('mouseup', onMouseUp);\n\n            // listen to mousemove on map (instead of polygon),\n            // otherwise fast mouse movements stop the drag\n            _this._layer._map.on('mousemove', onMouseMove);\n        });\n    },\n    dragging: function dragging() {\n        return this._dragging;\n    },\n    _onLayerDrag: function _onLayerDrag(e) {\n        // latLng of mouse event\n        var latlng = e.latlng;\n\n        // delta coords (how far was dragged)\n        var deltaLatLng = {\n            lat: latlng.lat - this._tempDragCoord.lat,\n            lng: latlng.lng - this._tempDragCoord.lng\n        };\n\n        // create the new coordinates array\n        var coords = this._layer._latlngs[0];\n        var newLatLngs = coords.map(function (currentLatLng) {\n            return {\n                lat: currentLatLng.lat + deltaLatLng.lat,\n                lng: currentLatLng.lng + deltaLatLng.lng\n            };\n        });\n\n        // set new coordinates and redraw\n        this._layer.setLatLngs(newLatLngs).redraw();\n\n        // save current latlng for next delta calculation\n        this._tempDragCoord = latlng;\n\n        // fire pm:dragstart event\n        this._layer.fire('pm:drag');\n    }\n};\n'use strict';\n\n// this isn't included anymore but if you want to re-enable it:\n// 1. include this mixing inside L.PM.Edit.js\n// 2. include the turf.js dependency in your project before leaflet.pm\n// 3. uncomment all code inside L.PM.Edit.Poly that has an if-check on options.preventOverlap\n// 4. pass the option preventOverlap to the enable() function on your layer\nvar OverlapMixin = {\n    _applyPossibleCoordsChanges: function _applyPossibleCoordsChanges() {\n        // after the polygon was dragged and changed it's shape because of unallowed intersecting\n        // with another polygon, this function takes the temporarily drawn polygon (during drag) and applies\n        // it's coordinates to our main polygon\n\n        if (this._tempPolygon) {\n            // get the new coordinates\n            var latlngs = this._tempPolygon.getLayers()[0].getLatLngs();\n\n            // reshape our main polygon\n            this._poly.setLatLngs(latlngs).redraw();\n\n            // initialize the markers again\n            this._initMarkers();\n        }\n    },\n    _drawTemporaryPolygon: function _drawTemporaryPolygon(geoJson) {\n        // hide our polygon\n        this._poly.setStyle({ opacity: 0, fillOpacity: 0 });\n\n        // draw a temporary polygon (happens during drag & intersection)\n        this._tempPolygon = L.geoJson(geoJson).addTo(this._poly._map).bringToBack();\n    },\n    _handleOverlap: function _handleOverlap() {\n        var mainPoly = this._poly;\n        var layers = this._layerGroup.getLayers();\n        var changed = false;\n        var resultingGeoJson = this._poly.toGeoJSON();\n\n        layers.filter(function (layer) {\n            return !Object.is(layer, mainPoly);\n        }).map(function (layer) {\n            var intersect = void 0;\n\n            // this needs to be in a try catch block because turf isn't reliable\n            // it throws self-intersection errors even if there are none\n            try {\n                intersect = turf.intersect(resultingGeoJson, layer.toGeoJSON());\n            } catch (e) {\n                console.warn('Turf Error.');\n            }\n\n            if (intersect) {\n                resultingGeoJson = turf.difference(resultingGeoJson, layer.toGeoJSON());\n\n                // if the resulting polygon is a MultiPolygon, don't handle it.\n                if (resultingGeoJson.geometry.type !== 'MultiPolygon') {\n                    changed = true;\n                }\n            }\n\n            return true;\n        });\n\n        if (this._tempPolygon) {\n            this._tempPolygon.remove();\n            delete this._tempPolygon;\n        }\n\n        if (changed) {\n            this._drawTemporaryPolygon(resultingGeoJson);\n        } else {\n            this._poly.setStyle({ opacity: 1, fillOpacity: 0.2 });\n        }\n    }\n};\n'use strict';\n\nvar SnapMixin = {\n    _initSnappableMarkers: function _initSnappableMarkers() {\n        var _this = this;\n\n        this.options.snapDistance = this.options.snapDistance || 30;\n\n        this._markers.forEach(function (marker) {\n            marker.off('drag', _this._handleSnapping, _this);\n            marker.on('drag', _this._handleSnapping, _this);\n\n            marker.off('dragend', _this._cleanupSnapping, _this);\n            marker.on('dragend', _this._cleanupSnapping, _this);\n        });\n\n        this._layer.off('pm:dragstart', this._unsnap, this);\n        this._layer.on('pm:dragstart', this._unsnap, this);\n    },\n    _unsnap: function _unsnap() {\n        // delete the last snap\n        delete this._snapLatLng;\n    },\n    _cleanupSnapping: function _cleanupSnapping() {\n        // delete it, we need to refresh this with each start of a drag because\n        // meanwhile, new layers could've been added to the map\n        delete this._snapList;\n\n        this.debugIndicatorLines.forEach(function (line) {\n            line.remove();\n        });\n    },\n    _handleSnapping: function _handleSnapping(e) {\n        // create a list of polygons that the marker could snap to\n        // this isn't inside a movestart/dragstart callback because middlemarkers are initialized\n        // after dragstart/movestart so it wouldn't fire for them\n        if (this._snapList === undefined) {\n            this._createSnapList(e);\n        }\n\n        // if there are no layers to snap to, stop here\n        if (this._snapList.length <= 0) {\n            return false;\n        }\n\n        var marker = e.target;\n\n        // get the closest layer, it's closest latlng, segment and the distance\n        var closestLayer = this._calcClosestLayer(marker.getLatLng(), this._snapList);\n\n        // find the final latlng that we want to snap to\n        var snapLatLng = this._checkPrioritiySnapping(closestLayer);\n\n        // minimal distance before marker snaps (in pixels)\n        var minDistance = this.options.snapDistance;\n\n        // event info for pm:snap and pm:unsnap\n        var eventInfo = {\n            marker: marker,\n            snapLatLng: snapLatLng,\n            segment: closestLayer.segment,\n            layer: this._layer,\n            layerInteractedWith: closestLayer.layer };\n\n        if (closestLayer.distance < minDistance) {\n            // snap the marker\n            marker.setLatLng(snapLatLng);\n            this._onMarkerDrag(e);\n\n            // check if the snapping position differs from the last snap\n            if (this._snapLatLng !== snapLatLng) {\n                // if yes, save it and fire the pm:snap event\n                this._snapLatLng = snapLatLng;\n                marker.fire('pm:snap', eventInfo);\n                this._layer.fire('pm:snap', eventInfo);\n            }\n        } else if (this._snapLatLng) {\n            // no more snapping\n\n            // if it was previously snapped...\n            // ...unsnap\n            this._unsnap(eventInfo);\n\n            // and fire unsnap event\n            eventInfo.marker.fire('pm:unsnap', eventInfo);\n            this._layer.fire('pm:unsnap', eventInfo);\n        }\n\n        return true;\n    },\n\n\n    // we got the point we want to snap to (C), but we need to check if a coord of the polygon\n    // receives priority over C as the snapping point. Let's check this here\n    _checkPrioritiySnapping: function _checkPrioritiySnapping(closestLayer) {\n        var map = this._layer._map;\n\n        // A and B are the points of the closest segment to P (the marker position we want to snap)\n        var A = closestLayer.segment[0];\n        var B = closestLayer.segment[1];\n\n        // C is the point we would snap to on the segment.\n        // The closest point on the closest segment of the closest polygon to P. That's right.\n        var C = closestLayer.latlng;\n\n        // distances from A to C and B to C to check which one is closer to C\n        var distanceAC = this._getDistance(map, A, C);\n        var distanceBC = this._getDistance(map, B, C);\n\n        // closest latlng of A and B to C\n        var closestVertexLatLng = distanceAC < distanceBC ? A : B;\n\n        // distance between closestVertexLatLng and C\n        var shortestDistance = distanceAC < distanceBC ? distanceAC : distanceBC;\n\n        // the distance that needs to be undercut to trigger priority\n        var priorityDistance = this.options.snapDistance;\n\n        // the latlng we ultemately want to snap to\n        var snapLatlng = void 0;\n\n        // if C is closer to the closestVertexLatLng (A or B) than the snapDistance,\n        // the closestVertexLatLng has priority over C as the snapping point.\n        if (shortestDistance < priorityDistance) {\n            snapLatlng = closestVertexLatLng;\n        } else {\n            snapLatlng = closestLayer.latlng;\n        }\n\n        // return the snapping point\n        return snapLatlng;\n    },\n    _createSnapList: function _createSnapList() {\n        var _this2 = this;\n\n        var layers = [];\n        var debugIndicatorLines = [];\n\n        // find all layers that are or inherit from Polylines...\n        this._layer._map.eachLayer(function (layer) {\n            if (layer instanceof L.Polyline) {\n                layers.push(layer);\n\n                // this is for debugging\n                var debugLine = L.polyline([], { color: 'red' });\n                debugIndicatorLines.push(debugLine);\n\n                // uncomment ðŸ‘‡ this in to show debugging lines\n                // debugLine.addTo(this._layer._map);\n            }\n        });\n\n        // ...except myself\n        layers = layers.filter(function (layer) {\n            return _this2._layer !== layer;\n        });\n\n        this._snapList = layers;\n        this.debugIndicatorLines = debugIndicatorLines;\n    },\n    _calcClosestLayer: function _calcClosestLayer(latlng, layers) {\n        var _this3 = this;\n\n        // the closest polygon to our dragged marker latlng\n        var closestLayer = {};\n\n        // loop through the layers\n        layers.forEach(function (layer, index) {\n            // find the closest latlng, segment and the distance of this layer to the dragged marker latlng\n            var results = _this3._calcLayerDistances(latlng, layer);\n\n            // show indicator lines, it's for debugging\n            _this3.debugIndicatorLines[index].setLatLngs([latlng, results.latlng]);\n\n            // save the info if it doesn't exist or if the distance is smaller than the previous one\n            if (closestLayer.distance === undefined || results.distance < closestLayer.distance) {\n                closestLayer = results;\n                closestLayer.layer = layer;\n            }\n        });\n\n        // return the closest layer and it's data\n        // if there is no closest layer, return undefined\n        return closestLayer;\n    },\n    _calcLayerDistances: function _calcLayerDistances(latlng, layer) {\n        var _this4 = this;\n\n        var map = this._layer._map;\n\n        // is this a polyline, or polygon?\n        var closedShape = layer instanceof L.Polygon;\n\n        // the point P which we want to snap (probpably the marker that is dragged)\n        var P = latlng;\n\n        var coords = void 0;\n\n        // the coords of the layer\n        if (closedShape) {\n            coords = layer.getLatLngs()[0];\n        } else {\n            coords = layer.getLatLngs();\n        }\n\n        // the closest segment (line between two points) of the layer\n        var closestSegment = void 0;\n\n        // the shortest distance from P to closestSegment\n        var shortestDistance = void 0;\n\n        // loop through the coords of the layer\n        coords.forEach(function (coord, index) {\n            // take this coord (A)...\n            var A = coord;\n            var nextIndex = void 0;\n\n            // and the next coord (B) as points\n            if (closedShape) {\n                nextIndex = index + 1 === coords.length ? 0 : index + 1;\n            } else {\n                nextIndex = index + 1 === coords.length ? undefined : index + 1;\n            }\n\n            var B = coords[nextIndex];\n\n            if (B) {\n                // calc the distance between P and AB-segment\n                var distance = _this4._getDistanceToSegment(map, P, A, B);\n\n                // is the distance shorter than the previous one? Save it and the segment\n                if (shortestDistance === undefined || distance < shortestDistance) {\n                    shortestDistance = distance;\n                    closestSegment = [A, B];\n                }\n            }\n\n            return true;\n        });\n\n        // now, take the closest segment (closestSegment) and calc the closest point to P on it.\n        var C = this._getClosestPointOnSegment(map, latlng, closestSegment[0], closestSegment[1]);\n\n        // return the latlng of that sucker\n        return {\n            latlng: C,\n            segment: closestSegment,\n            distance: shortestDistance\n        };\n    },\n    _getClosestPointOnSegment: function _getClosestPointOnSegment(map, latlng, latlngA, latlngB) {\n        var maxzoom = map.getMaxZoom();\n        if (maxzoom === Infinity) {\n            maxzoom = map.getZoom();\n        }\n        var P = map.project(latlng, maxzoom);\n        var A = map.project(latlngA, maxzoom);\n        var B = map.project(latlngB, maxzoom);\n        var closest = L.LineUtil.closestPointOnSegment(P, A, B);\n        return map.unproject(closest, maxzoom);\n    },\n    _getDistanceToSegment: function _getDistanceToSegment(map, latlng, latlngA, latlngB) {\n        var P = map.latLngToLayerPoint(latlng);\n        var A = map.latLngToLayerPoint(latlngA);\n        var B = map.latLngToLayerPoint(latlngB);\n        return L.LineUtil.pointToSegmentDistance(P, A, B);\n    },\n    _getDistance: function _getDistance(map, latlngA, latlngB) {\n        return map.latLngToLayerPoint(latlngA).distanceTo(map.latLngToLayerPoint(latlngB));\n    }\n};\n\"use strict\";\n\n/**\n*\n* A Leaflet Plugin For Editing Geometry Layers in Leaflet 1.0\n* by Sumit Kumar (@TweetsOfSumit)\n* Github Repo: https://github.com/codeofsumit/leaflet.pm\n*/\n\nL.PM = L.PM || {\n    initialize: function initialize() {\n        function initLayerGroup() {\n            this.pm = new L.PM.Edit.LayerGroup(this);\n        }\n\n        L.LayerGroup.addInitHook(initLayerGroup);\n\n        function initPolygon() {\n            this.pm = new L.PM.Edit.Poly(this);\n        }\n\n        L.Polygon.addInitHook(initPolygon);\n\n        function initPolyline() {\n            this.pm = new L.PM.Edit.Line(this);\n        }\n\n        L.Polyline.addInitHook(initPolyline);\n\n        function initMap() {\n            this.pm = new L.PM.Map(this);\n        }\n\n        L.Map.addInitHook(initMap);\n    }\n};\n\n// initialize leaflet.pm\nL.PM.initialize();\n'use strict';\n\nL.PM.Map = L.Class.extend({\n    initialize: function initialize(map) {\n        this.map = map;\n        this.Draw = new L.PM.Draw(map);\n        this.Toolbar = new L.PM.Toolbar(map);\n    },\n    addControls: function addControls(options) {\n        this.Toolbar.addControls(options);\n    },\n    enableDraw: function enableDraw() {\n        var shape = arguments.length <= 0 || arguments[0] === undefined ? 'Poly' : arguments[0];\n\n        this.Draw.enable(shape);\n    },\n    disableDraw: function disableDraw() {\n        var shape = arguments.length <= 0 || arguments[0] === undefined ? 'Poly' : arguments[0];\n\n        this.Draw.disable(shape);\n    },\n    removeLayer: function removeLayer(e) {\n        var layer = e.target;\n        if (!layer._layers && !layer.pm.dragging()) {\n            e.target.remove();\n        }\n    },\n    toggleRemoval: function toggleRemoval(enabled) {\n        var _this = this;\n\n        if (enabled) {\n            this.map.eachLayer(function (layer) {\n                layer.on('click', _this.removeLayer);\n            });\n        } else {\n            this.map.eachLayer(function (layer) {\n                layer.off('click', _this.removeLayer);\n            });\n        }\n    },\n    globalEditEnabled: function globalEditEnabled() {\n        return this._globalEditMode;\n    },\n    toggleGlobalEditMode: function toggleGlobalEditMode(options) {\n        // find all layers that are or inherit from Polylines...\n        var layers = [];\n        this.map.eachLayer(function (layer) {\n            if (layer instanceof L.Polyline) {\n                layers.push(layer);\n            }\n        });\n\n        if (this.globalEditEnabled()) {\n            // disable\n\n            this._globalEditMode = false;\n\n            layers.forEach(function (layer) {\n                layer.pm.disable();\n            });\n        } else {\n            // enable\n\n            this._globalEditMode = true;\n\n            layers.forEach(function (layer) {\n                layer.pm.enable(options);\n            });\n        }\n    }\n});\n'use strict';\n\nL.PM.Draw = L.Class.extend({\n    initialize: function initialize(map) {\n        var _this = this;\n\n        // save the map\n        this._map = map;\n\n        // define all possible shapes that can be drawn\n        this.shapes = ['Poly', 'Line'];\n\n        // initiate drawing class for our shapes\n        this.shapes.forEach(function (shape) {\n            _this[shape] = new L.PM.Draw[shape](_this._map);\n        });\n    },\n    getShapes: function getShapes() {\n        // if somebody wants to know what shapes are available\n        return this.shapes;\n    },\n    enable: function enable(shape) {\n        if (!shape) {\n            throw new Error('Error: Please pass a shape as a parameter. Possible shapes are: ' + this.getShapes().join(','));\n        }\n\n        // disable drawing for all shapes\n        this.disable();\n\n        // enable draw for a shape\n        this[shape].enable();\n    },\n    disable: function disable() {\n        var _this2 = this;\n\n        // there can only be one drawing mode active at a time on a map\n        // so it doesn't matter which one should be disabled.\n        // just disable all of them\n        this.shapes.forEach(function (shape) {\n            _this2[shape].disable();\n        });\n    },\n    addControls: function addControls() {\n        var _this3 = this;\n\n        // add control buttons for our shapes\n        this.shapes.forEach(function (shape) {\n            _this3[shape].addButton();\n        });\n    }\n});\n\"use strict\";\n\nL.PM.Edit = L.Class.extend({\n    includes: [DragMixin, SnapMixin]\n});\n'use strict';\n\nL.PM.Draw.Line = L.PM.Draw.extend({\n    initialize: function initialize(map) {\n        this._map = map;\n        this._shape = 'Line';\n        this.toolbarButtonName = 'drawPolyline';\n    },\n    enable: function enable() {\n        // enable draw mode\n\n        this._enabled = true;\n\n        // create a new layergroup\n        this._layerGroup = new L.LayerGroup();\n        this._layerGroup.addTo(this._map);\n\n        // this is the polyLine that'll make up the polygon\n        this._polyline = L.polyline([], { color: 'red' });\n        this._layerGroup.addLayer(this._polyline);\n\n        // this is the hintline from the mouse cursor to the last marker\n        this._hintline = L.polyline([], {\n            color: 'red',\n            dashArray: [5, 5]\n        });\n        this._layerGroup.addLayer(this._hintline);\n\n        // change map cursor\n        this._map._container.style.cursor = 'crosshair';\n\n        // create a polygon-point on click\n        this._map.on('click', this._createPolygonPoint, this);\n\n        // sync the hintline on mousemove\n        this._map.on('mousemove', this._syncHintLine, this);\n\n        // fire drawstart event\n        this._map.fire('pm:drawstart', { shape: this._shape });\n\n        // toggle the draw button of the Toolbar in case drawing mode got enabled without the button\n        this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, true);\n    },\n    disable: function disable() {\n        // disable draw mode\n\n        // cancel, if drawing mode isn't even enabled\n        if (!this._enabled) {\n            return;\n        }\n\n        this._enabled = false;\n\n        // reset cursor\n        this._map._container.style.cursor = 'default';\n\n        // unbind listeners\n        this._map.off('click', this._createPolygonPoint);\n        this._map.off('mousemove', this._syncHintLine);\n\n        // remove layer\n        this._map.removeLayer(this._layerGroup);\n\n        // fire drawend event\n        this._map.fire('pm:drawend', { shape: this._shape });\n\n        // toggle the draw button of the Toolbar in case drawing mode got disabled without the button\n        this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, false);\n    },\n    enabled: function enabled() {\n        return this._enabled;\n    },\n    toggle: function toggle(options) {\n        if (this.enabled()) {\n            this.disable();\n        } else {\n            this.enable(options);\n        }\n    },\n    _syncHintLine: function _syncHintLine(e) {\n        var polyPoints = this._polyline.getLatLngs();\n\n        if (polyPoints.length > 0) {\n            var lastPolygonPoint = polyPoints[polyPoints.length - 1];\n            this._hintline.setLatLngs([lastPolygonPoint, e.latlng]);\n        }\n    },\n    _createPolygonPoint: function _createPolygonPoint(e) {\n        // is this the first point?\n        var first = this._polyline.getLatLngs().length === 0;\n\n        this._polyline.addLatLng(e.latlng);\n        this._createMarker(e.latlng, first);\n\n        this._hintline.setLatLngs([e.latlng, e.latlng]);\n    },\n    _finishShape: function _finishShape() {\n        // get coordinates, create the leaflet shape and add it to the map\n        var coords = this._polyline.getLatLngs();\n        var polylineLayer = L.polyline(coords).addTo(this._map);\n\n        // disable drawing\n        this.disable();\n\n        // fire the pm:create event and pass shape and layer\n        this._map.fire('pm:create', {\n            shape: this._shape,\n            layer: polylineLayer\n        });\n    },\n    _createMarker: function _createMarker(latlng) {\n        // create the new marker\n        var marker = new L.Marker(latlng, {\n            draggable: false,\n            icon: L.divIcon({ className: 'marker-icon' })\n        });\n\n        // add it to the map\n        this._layerGroup.addLayer(marker);\n\n        // a click on any marker finishes this shape\n        marker.on('click', this._finishShape, this);\n\n        return marker;\n    }\n});\n'use strict';\n\nL.PM.Draw.Poly = L.PM.Draw.Line.extend({\n    initialize: function initialize(map) {\n        this._map = map;\n        this._shape = 'Poly';\n        this.toolbarButtonName = 'drawPolygon';\n    },\n    _finishShape: function _finishShape() {\n        // get coordinates, create the leaflet shape and add it to the map\n        var coords = this._polyline.getLatLngs();\n        var polygonLayer = L.polygon(coords).addTo(this._map);\n\n        // disable drawing\n        this.disable();\n\n        // fire the pm:create event and pass shape and layer\n        this._map.fire('pm:create', {\n            shape: this._shape,\n            layer: polygonLayer\n        });\n    },\n    _createMarker: function _createMarker(latlng, first) {\n        // create the new marker\n        var marker = new L.Marker(latlng, {\n            draggable: false,\n            icon: L.divIcon({ className: 'marker-icon' })\n        });\n\n        // add it to the map\n        this._layerGroup.addLayer(marker);\n\n        // if the first marker gets clicked again, finish this shape\n        if (first) {\n            marker.on('click', this._finishShape, this);\n        }\n    }\n});\n'use strict';\n\n// LayerGroup doesn't inherit from L.PM.Edit because it's just calling L.PM.Edit.Poly\n// (which inherits from L.PM.Edit) for each layer,\n// so it's not really a parent class\nL.PM.Edit.LayerGroup = L.Class.extend({\n    initialize: function initialize(layerGroup) {\n        var _this = this;\n\n        this._layerGroup = layerGroup;\n        this._layers = layerGroup.getLayers();\n\n        var availableEvents = ['pm:edit', 'pm:dragstart', 'pm:drag', 'pm:dragend', 'pm:snap', 'pm:unsnap', 'pm:raiseMarkers', 'pm:markerdragend', 'pm:markerdragstart'];\n\n        this._layers.forEach(function (layer) {\n            // listen to the events of the layers in this group\n            availableEvents.forEach(function (event) {\n                layer.on(event, _this._fireEvent, _this);\n            });\n\n            // add reference for the group to each layer inside said group\n            layer.pm._layerGroup = _this._layerGroup;\n        });\n\n        // if a new layer is added to the group, reinitialize\n        // This only works for FeatureGroups, not LayerGroups\n        // https://github.com/Leaflet/Leaflet/issues/4861\n        this._layerGroup.on('layeradd', function (e) {\n            _this.initialize(layerGroup);\n\n            // if editing was already enabled for this group, enable it again\n            // so the new layers are enabled\n            if (e.target.pm.enabled()) {\n                _this.enable(_this.getOptions());\n            }\n        });\n    },\n    _fireEvent: function _fireEvent(e) {\n        this._layerGroup.fireEvent(e.type, e);\n    },\n    toggleEdit: function toggleEdit(options) {\n        this._options = options;\n        this._layers.forEach(function (layer) {\n            layer.pm.toggleEdit(options);\n        });\n    },\n    enable: function enable(options) {\n        this._options = options;\n        this._layers.forEach(function (layer) {\n            layer.pm.enable(options);\n        });\n    },\n    disable: function disable() {\n        this._layers.forEach(function (layer) {\n            layer.pm.disable();\n        });\n    },\n    enabled: function enabled() {\n        var enabled = this._layers.find(function (layer) {\n            return layer.pm.enabled();\n        });\n        return !!enabled;\n    },\n    dragging: function dragging() {\n        var dragging = this._layers.find(function (layer) {\n            return layer.pm.dragging();\n        });\n        return !!dragging;\n    },\n    getOptions: function getOptions() {\n        return this._options;\n    }\n});\n'use strict';\n\nL.PM.Edit.Line = L.PM.Edit.extend({\n    initialize: function initialize(layer) {\n        this._layer = layer;\n        this._enabled = false;\n    },\n    toggleEdit: function toggleEdit(options) {\n        if (!this.enabled()) {\n            this.enable(options);\n        } else {\n            this.disable();\n        }\n    },\n    enable: function enable() {\n        var _this = this;\n\n        var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];\n\n        this.options = options;\n\n        if (!this.enabled()) {\n            // if it was already enabled, disable first\n            // we don't block enabling again because new options might be passed\n            this.disable();\n        }\n\n        // change state\n        this._enabled = true;\n\n        // init markers\n        this._initMarkers();\n\n        // if polygon gets removed from map, disable edit mode\n        this._layer.on('remove', function (e) {\n            _this.disable(e.target);\n        });\n\n        // preventOverlap needs the turf library. If it's not included, deactivate it again\n        // if(window.turf === undefined && this.options.preventOverlap) {\n        //     console.warn('TurfJS not found, preventOverlap is deactivated');\n        //     this.options.preventOverlap = false;\n        // }\n\n        if (this.options.draggable) {\n            this._initDraggableLayer();\n        }\n\n        // if(this.options.preventOverlap) {\n        //\n        //     // if the dragged polygon should be cutted when overlapping another polygon, go ahead\n        //     this._layer.on('pm:drag', this._handleOverlap, this);\n        //\n        //     // set new coordinates, more details inside the function\n        //     this._layer.on('pm:dragend', this._applyPossibleCoordsChanges, this);\n        // }\n    },\n    enabled: function enabled() {\n        return this._enabled;\n    },\n    disable: function disable() {\n        var poly = arguments.length <= 0 || arguments[0] === undefined ? this._layer : arguments[0];\n\n        // if it's not enabled, it doesn't need to be disabled\n        if (!this.enabled()) {\n            return false;\n        }\n\n        // prevent disabling if polygon is being dragged\n        if (poly.pm._dragging) {\n            return false;\n        }\n        poly.pm._enabled = false;\n        poly.pm._markerGroup.clearLayers();\n\n        // clean up draggable\n        poly.off('mousedown');\n        poly.off('mouseup');\n\n        // remove draggable class\n        var el = poly._path;\n        L.DomUtil.removeClass(el, 'leaflet-pm-draggable');\n\n        return true;\n    },\n    _initMarkers: function _initMarkers() {\n        var map = this._layer._map;\n\n        // cleanup old ones first\n        if (this._markerGroup) {\n            this._markerGroup.clearLayers();\n        }\n\n        // add markerGroup to map, markerGroup includes regular and middle markers\n        this._markerGroup = new L.LayerGroup();\n        map.addLayer(this._markerGroup);\n\n        // create marker for each coordinate\n        var coords = this._layer._latlngs;\n\n        // the marker array, it includes only the markers that're associated with the coordinates\n        this._markers = coords.map(this._createMarker, this);\n\n        // create small markers in the middle of the regular markers\n        for (var k = 0; k < coords.length - 1; k += 1) {\n            var nextIndex = k + 1;\n            this._createMiddleMarker(this._markers[k], this._markers[nextIndex]);\n        }\n\n        if (this.options.snappable) {\n            this._initSnappableMarkers();\n        }\n    },\n\n\n    // creates initial markers for coordinates\n    _createMarker: function _createMarker(latlng, index) {\n        var marker = new L.Marker(latlng, {\n            draggable: true,\n            icon: L.divIcon({ className: 'marker-icon' })\n        });\n\n        marker._origLatLng = latlng;\n        marker._index = index;\n\n        marker.on('dragstart', this._onMarkerDragStart, this);\n        marker.on('drag', this._onMarkerDrag, this);\n        marker.on('dragend', this._onMarkerDragEnd, this);\n        marker.on('contextmenu', this._removeMarker, this);\n\n        this._markerGroup.addLayer(marker);\n\n        return marker;\n    },\n\n\n    // creates the middle markes between coordinates\n    _createMiddleMarker: function _createMiddleMarker(leftM, rightM) {\n        var _this2 = this;\n\n        var latlng = this._calcMiddleLatLng(leftM.getLatLng(), rightM.getLatLng());\n\n        var middleMarker = this._createMarker(latlng);\n        var middleIcon = L.divIcon({ className: 'marker-icon marker-icon-middle' });\n        middleMarker.setIcon(middleIcon);\n\n        // save reference to this middle markers on the neighboor regular markers\n        leftM._middleMarkerNext = middleMarker;\n        rightM._middleMarkerPrev = middleMarker;\n\n        middleMarker.on('click', function () {\n            // TODO: move the next two lines inside _addMarker() as soon as\n            // https://github.com/Leaflet/Leaflet/issues/4484\n            // is fixed\n            var icon = L.divIcon({ className: 'marker-icon' });\n            middleMarker.setIcon(icon);\n\n            _this2._addMarker(middleMarker, leftM, rightM);\n        });\n        middleMarker.on('movestart', function () {\n            // TODO: This is a workaround. Remove the moveend listener and\n            // callback as soon as this is fixed:\n            // https://github.com/Leaflet/Leaflet/issues/4484\n            middleMarker.on('moveend', function () {\n                var icon = L.divIcon({ className: 'marker-icon' });\n                middleMarker.setIcon(icon);\n\n                middleMarker.off('moveend');\n            });\n\n            _this2._addMarker(middleMarker, leftM, rightM);\n        });\n    },\n\n\n    // adds a new marker from a middlemarker\n    _addMarker: function _addMarker(newM, leftM, rightM) {\n        // first, make this middlemarker a regular marker\n        newM.off('movestart');\n        newM.off('click');\n\n        // now, create the polygon coordinate point for that marker\n        var latlng = newM.getLatLng();\n        var coords = this._layer._latlngs;\n        var index = leftM._index + 1;\n\n        coords.splice(index, 0, latlng);\n\n        // associate polygon coordinate with marker coordinate\n        newM._origLatLng = coords[index];\n\n        // push into marker array & update the indexes for every marker\n        this._markers.splice(index, 0, newM);\n        this._markers.map(function (marker, i) {\n            marker._index = i;\n            return true;\n        });\n\n        // create the new middlemarkers\n        this._createMiddleMarker(leftM, newM);\n        this._createMiddleMarker(newM, rightM);\n\n        // fire edit event\n        this._fireEdit();\n\n        if (this.options.snappable) {\n            this._initSnappableMarkers();\n        }\n    },\n    _removeMarker: function _removeMarker(e) {\n        var marker = e.target;\n        var coords = this._layer._latlngs;\n        var index = marker._index;\n\n        // only continue if this is NOT a middle marker (those can't be deleted)\n        if (index === undefined) {\n            return;\n        }\n\n        // remove polygon coordinate from this marker\n        coords.splice(index, 1);\n\n        // if the poly has no coordinates left, remove the layer\n        // else, redraw it\n        if (coords.length < 1) {\n            this._layer.remove();\n        } else {\n            this._layer.redraw();\n        }\n\n        // remove the marker and the middlemarkers next to it from the map\n        if (marker._middleMarkerPrev) {\n            this._markerGroup.removeLayer(marker._middleMarkerPrev);\n        }\n        if (marker._middleMarkerNext) {\n            this._markerGroup.removeLayer(marker._middleMarkerNext);\n        }\n\n        this._markerGroup.removeLayer(marker);\n\n        // find neighbor marker-indexes\n        var leftMarkerIndex = index - 1 < 0 ? undefined : index - 1;\n        var rightMarkerIndex = index + 1 >= this._markers.length ? undefined : index + 1;\n\n        // don't create middlemarkers if there is only one marker left\n        // or if the middlemarker would be between the first and last coordinate of a polyline\n        if (rightMarkerIndex && leftMarkerIndex && rightMarkerIndex !== leftMarkerIndex) {\n            var leftM = this._markers[leftMarkerIndex];\n            var rightM = this._markers[rightMarkerIndex];\n            this._createMiddleMarker(leftM, rightM);\n        }\n\n        // remove the marker from the markers array & update indexes\n        this._markers.splice(index, 1);\n        this._markers.map(function (m, i) {\n            m._index = i;\n            return true;\n        });\n\n        // if the polygon should be cutted when overlapping another polygon, do it now\n        // if(this.options.preventOverlap) {\n        //     this._handleOverlap();\n        //     this._applyPossibleCoordsChanges();\n        // }\n\n        // fire edit event\n        this._fireEdit();\n    },\n    _onMarkerDrag: function _onMarkerDrag(e) {\n        // dragged marker\n        var marker = e.target;\n\n        // the dragged markers neighbors\n        var nextMarkerIndex = marker._index + 1 >= this._markers.length ? 0 : marker._index + 1;\n        var prevMarkerIndex = marker._index - 1 < 0 ? this._markers.length - 1 : marker._index - 1;\n\n        // update marker coordinates which will update polygon coordinates\n        L.extend(marker._origLatLng, marker._latlng);\n        this._layer.redraw();\n\n        // update middle markers on the left and right\n        // be aware that \"next\" and \"prev\" might be interchanged, depending on the geojson array\n        var markerLatLng = marker.getLatLng();\n        var prevMarkerLatLng = this._markers[prevMarkerIndex].getLatLng();\n        var nextMarkerLatLng = this._markers[nextMarkerIndex].getLatLng();\n\n        if (marker._middleMarkerNext) {\n            var middleMarkerNextLatLng = this._calcMiddleLatLng(markerLatLng, nextMarkerLatLng);\n            marker._middleMarkerNext.setLatLng(middleMarkerNextLatLng);\n        }\n\n        if (marker._middleMarkerPrev) {\n            var middleMarkerPrevLatLng = this._calcMiddleLatLng(markerLatLng, prevMarkerLatLng);\n            marker._middleMarkerPrev.setLatLng(middleMarkerPrevLatLng);\n        }\n\n        // if the dragged polygon should be cutted when overlapping another polygon, go ahead\n        // if(this.options.preventOverlap) {\n        //     this._handleOverlap();\n        // }\n    },\n    _onMarkerDragEnd: function _onMarkerDragEnd(e) {\n        // if(this.options.preventOverlap) {\n        //     this._applyPossibleCoordsChanges();\n        // }\n\n        this._layer.fire('pm:markerdragend', {\n            markerEvent: e\n        });\n\n        // fire edit event\n        this._fireEdit();\n    },\n    _onMarkerDragStart: function _onMarkerDragStart(e) {\n        this._layer.fire('pm:markerdragstart', {\n            markerEvent: e\n        });\n    },\n    _fireEdit: function _fireEdit() {\n        // fire edit event\n        this._layer.edited = true;\n        this._layer.fire('pm:edit');\n    },\n    _calcMiddleLatLng: function _calcMiddleLatLng(latlng1, latlng2) {\n        // calculate the middle coordinates between two markers\n        // TODO: put this into a utils.js or something\n\n        var map = this._layer._map;\n        var p1 = map.project(latlng1);\n        var p2 = map.project(latlng2);\n\n        var latlng = map.unproject(p1._add(p2)._divideBy(2));\n\n        return latlng;\n    }\n});\n'use strict';\n\nL.PM.Edit.Poly = L.PM.Edit.Line.extend({\n    _initMarkers: function _initMarkers() {\n        var map = this._layer._map;\n\n        // cleanup old ones first\n        if (this._markerGroup) {\n            this._markerGroup.clearLayers();\n        }\n\n        // add markerGroup to map, markerGroup includes regular and middle markers\n        this._markerGroup = new L.LayerGroup();\n        map.addLayer(this._markerGroup);\n\n        // create marker for each coordinate\n        var coords = this._layer._latlngs[0];\n\n        // the marker array, it includes only the markers that're associated with the coordinates\n        this._markers = coords.map(this._createMarker, this);\n\n        // create small markers in the middle of the regular markers\n        for (var k = 0; k < coords.length; k += 1) {\n            var nextIndex = k + 1 >= coords.length ? 0 : k + 1;\n            this._createMiddleMarker(this._markers[k], this._markers[nextIndex]);\n        }\n\n        if (this.options.snappable) {\n            this._initSnappableMarkers();\n        }\n    },\n\n\n    // adds a new marker from a middlemarker\n    _addMarker: function _addMarker(newM, leftM, rightM) {\n        // first, make this middlemarker a regular marker\n        newM.off('movestart');\n        newM.off('click');\n\n        // now, create the polygon coordinate point for that marker\n        var latlng = newM.getLatLng();\n        var coords = this._layer._latlngs[0];\n        var index = leftM._index + 1;\n\n        coords.splice(index, 0, latlng);\n\n        // associate polygon coordinate with marker coordinate\n        newM._origLatLng = coords[index];\n\n        // push into marker array & update the indexes for every marker\n        this._markers.splice(index, 0, newM);\n        this._markers.map(function (marker, i) {\n            marker._index = i;\n            return true;\n        });\n\n        // create the new middlemarkers\n        this._createMiddleMarker(leftM, newM);\n        this._createMiddleMarker(newM, rightM);\n\n        // fire edit event\n        this._fireEdit();\n\n        if (this.options.snappable) {\n            this._initSnappableMarkers();\n        }\n    },\n    _removeMarker: function _removeMarker(e) {\n        var marker = e.target;\n        var coords = this._layer._latlngs[0];\n        var index = marker._index;\n\n        // only continue if this is NOT a middle marker (those can't be deleted)\n        if (index === undefined) {\n            return;\n        }\n\n        // remove polygon coordinate from this marker\n        coords.splice(index, 1);\n\n        // if the poly has no coordinates left, remove the layer\n        // else, redraw it\n        if (coords.length < 1) {\n            this._layer.remove();\n        } else {\n            this._layer.redraw();\n        }\n\n        // remove the marker and the middlemarkers next to it from the map\n        this._markerGroup.removeLayer(marker._middleMarkerPrev);\n        this._markerGroup.removeLayer(marker._middleMarkerNext);\n        this._markerGroup.removeLayer(marker);\n\n        // find neighbor marker-indexes\n        var leftMarkerIndex = index - 1 < 0 ? this._markers.length - 1 : index - 1;\n        var rightMarkerIndex = index + 1 >= this._markers.length ? 0 : index + 1;\n\n        // don't create middlemarkers if there is only one marker left\n        if (rightMarkerIndex !== leftMarkerIndex) {\n            var leftM = this._markers[leftMarkerIndex];\n            var rightM = this._markers[rightMarkerIndex];\n            this._createMiddleMarker(leftM, rightM);\n        }\n\n        // remove the marker from the markers array & update indexes\n        this._markers.splice(index, 1);\n        this._markers.map(function (m, i) {\n            m._index = i;\n            return true;\n        });\n\n        // if the polygon should be cutted when overlapping another polygon, do it now\n        // if(this.options.preventOverlap) {\n        //     this._handleOverlap();\n        //     this._applyPossibleCoordsChanges();\n        // }\n\n        // fire edit event\n        this._fireEdit();\n    }\n});\n'use strict';\n\nL.Control.PMButton = L.Control.extend({\n    options: {\n        position: 'topleft'\n    },\n    // TODO: clean up variable names like _button should be _options and that domNodeVariable stuff\n    initialize: function initialize(options) {\n        this._button = {};\n        this._button = this.setButton(options);\n    },\n    onAdd: function onAdd(map) {\n        this._map = map;\n\n        this._container = this._map.pm.Toolbar.container;\n        this.buttonsDomNode = this._makeButton(this._button);\n        this._container.appendChild(this.buttonsDomNode);\n\n        return this._container;\n    },\n    onRemove: function onRemove() {},\n    setButton: function setButton(options) {\n        var button = {\n            className: options.className,\n            iconUrl: options.iconUrl,\n            onClick: options.onClick,\n            afterClick: options.afterClick,\n            doToggle: options.doToggle,\n            toggleStatus: options.toggleStatus,\n            disableOtherButtons: options.disableOtherButtons\n        };\n\n        return button;\n    },\n    getText: function getText() {\n        return this._button.text;\n    },\n    getIconUrl: function getIconUrl() {\n        return this._button.iconUrl;\n    },\n    destroy: function destroy() {\n        this._button = {};\n        this._update();\n    },\n    toggle: function toggle(e) {\n        if (typeof e === 'boolean') {\n            this._button.toggleStatus = e;\n        } else {\n            this._button.toggleStatus = !this._button.toggleStatus;\n        }\n        this._applyStyleClasses();\n\n        return this._button.toggleStatus;\n    },\n    toggled: function toggled() {\n        return this._button.toggleStatus;\n    },\n    onCreate: function onCreate() {\n        this.toggle(false);\n    },\n    _triggerClick: function _triggerClick(e) {\n        this._button.onClick(e);\n        this._clicked(e);\n        this._button.afterClick(e);\n    },\n    _makeButton: function _makeButton(button) {\n        var _this = this;\n\n        var newButton = L.DomUtil.create('a', 'leaflet-buttons-control-button', this._container);\n        if (button.toggleStatus) {\n            L.DomUtil.addClass(newButton, 'active');\n        }\n\n        var image = L.DomUtil.create('div', 'control-icon', newButton);\n        if (button.iconUrl) {\n            image.setAttribute('src', button.iconUrl);\n        }\n        if (button.className) {\n            L.DomUtil.addClass(image, button.className);\n        }\n        // before the actual click, trigger a click on currently toggled buttons to\n        // untoggle them and their functionality\n        L.DomEvent.addListener(newButton, 'click', function () {\n            if (_this._button.disableOtherButtons) {\n                _this._map.pm.Toolbar.triggerClickOnToggledButtons(_this);\n            }\n        });\n        L.DomEvent.addListener(newButton, 'click', this._triggerClick, this);\n\n        L.DomEvent.disableClickPropagation(newButton);\n        return newButton;\n    },\n    _applyStyleClasses: function _applyStyleClasses() {\n        if (!this._container) {\n            return;\n        }\n\n        if (!this._button.toggleStatus) {\n            L.DomUtil.removeClass(this.buttonsDomNode, 'active');\n        } else {\n            L.DomUtil.addClass(this.buttonsDomNode, 'active');\n        }\n    },\n    _clicked: function _clicked() {\n        if (this._button.doToggle) {\n            this.toggle();\n        }\n        return;\n    }\n});\n'use strict';\n\n/**\n* The Icons used in this Toolbar are CC-BY Glyphicons - http://glyphicons.com/\n*/\n\nL.PM.Toolbar = L.Class.extend({\n    options: {\n        drawPolygon: true,\n        drawPolyline: true,\n        editPolygon: true,\n        dragPolygon: false,\n        deleteLayer: true\n    },\n    initialize: function initialize(map) {\n        this.map = map;\n\n        this.buttons = {};\n        this.container = L.DomUtil.create('div', 'leaflet-pm-toolbar leaflet-bar leaflet-control');\n        this._defineButtons();\n    },\n    getButtons: function getButtons() {\n        return this.buttons;\n    },\n    addControls: function addControls() {\n        var options = arguments.length <= 0 || arguments[0] === undefined ? this.options : arguments[0];\n\n        // adds all buttons to the map specified inside options\n\n        // first set the options\n        L.Util.setOptions(this, options);\n\n        // now show the specified buttons\n        this._showHideButtons();\n    },\n    _addButton: function _addButton(name, button) {\n        this.buttons[name] = button;\n        this.options[name] = this.options[name] || false;\n\n        return this.buttons[name];\n    },\n    triggerClickOnToggledButtons: function triggerClickOnToggledButtons(exceptThisButton) {\n        // this function is used when - e.g. drawing mode is enabled and a possible\n        // other active mode (like removal tool) is already active.\n        // we can't have two active modes because of possible event conflicts\n        // so, we trigger a click on all currently active (toggled) buttons\n        for (var name in this.buttons) {\n            if (this.buttons[name] !== exceptThisButton && this.buttons[name].toggled()) {\n                this.buttons[name]._triggerClick();\n            }\n        }\n    },\n    toggleButton: function toggleButton(name, status) {\n        // does not fire the events/functionality of the button\n        // this just changes the state and is used if a functionality (like Draw)\n        // is enabled manually via script\n\n        // as some mode got enabled, we still have to trigger the click on the other buttons\n        // to disable their mode\n        this.triggerClickOnToggledButtons(this.buttons[name]);\n\n        // now toggle the state of the button\n        return this.buttons[name].toggle(status);\n    },\n    _defineButtons: function _defineButtons() {\n        var _this = this;\n\n        // some buttons are still in their respective classes, like L.PM.Draw.Poly\n        var deleteButton = {\n            className: 'icon-delete',\n            onClick: function onClick() {},\n            afterClick: function afterClick() {\n                _this.map.pm.toggleRemoval(_this.buttons.deleteLayer.toggled());\n            },\n            doToggle: true,\n            toggleStatus: false,\n            disableOtherButtons: true\n        };\n\n        var drawPolyButton = {\n            className: 'icon-polygon',\n            onClick: function onClick() {},\n            afterClick: function afterClick() {\n                // toggle drawing mode\n                _this.map.pm.Draw.Poly.toggle();\n            },\n            doToggle: true,\n            toggleStatus: false,\n            disableOtherButtons: true\n        };\n\n        var drawLineButton = {\n            className: 'icon-polyline',\n            onClick: function onClick() {},\n            afterClick: function afterClick() {\n                // toggle drawing mode\n                _this.map.pm.Draw.Line.toggle();\n            },\n            doToggle: true,\n            toggleStatus: false,\n            disableOtherButtons: true\n        };\n\n        var editButton = {\n            className: 'icon-edit',\n            onClick: function onClick() {},\n            afterClick: function afterClick() {\n                _this.map.pm.toggleGlobalEditMode({\n                    snappable: true,\n                    draggable: true\n                });\n            },\n            doToggle: true,\n            toggleStatus: false,\n            disableOtherButtons: true\n        };\n\n        var dragButton = {\n            className: 'icon-drag',\n            onClick: function onClick() {},\n            afterClick: function afterClick() {},\n            doToggle: true,\n            toggleStatus: false,\n            disableOtherButtons: true\n        };\n\n        this._addButton('drawPolygon', new L.Control.PMButton(drawPolyButton));\n        this._addButton('drawPolyline', new L.Control.PMButton(drawLineButton));\n        this._addButton('editPolygon', new L.Control.PMButton(editButton));\n        this._addButton('dragPolygon', new L.Control.PMButton(dragButton));\n        this._addButton('deleteLayer', new L.Control.PMButton(deleteButton));\n    },\n    _showHideButtons: function _showHideButtons() {\n        // loop through all buttons\n        var buttons = this.getButtons();\n\n        for (var btn in buttons) {\n            if (this.options[btn]) {\n                // if options say the button should be visible, add it to the map\n                buttons[btn].addTo(this.map);\n            } else {\n                // if not, remove it\n                buttons[btn].remove();\n            }\n        }\n    }\n});","const DragMixin = {\n    _initDraggableLayer() {\n        // temporary coord variable for delta calculation\n        this._tempDragCoord = null;\n\n        // add CSS class\n        const el = this._layer._path;\n        L.DomUtil.addClass(el, 'leaflet-pm-draggable');\n\n\n        const onMouseUp = () => {\n            // re-enable map drag\n            this._layer._map.dragging.enable();\n\n            // clear up mousemove event\n            this._layer._map.off('mousemove');\n\n            // clear up mouseup event\n            this._layer.off('mouseup');\n\n            // if no drag happened, don't do anything\n            if(!this._dragging) {\n                return false;\n            }\n\n            // show markers again\n            this._initMarkers();\n\n            // timeout to prevent click event after drag :-/\n            // TODO: do it better as soon as leaflet has a way to do it better :-)\n            window.setTimeout(() => {\n                // set state\n                this._dragging = false;\n                L.DomUtil.removeClass(el, 'leaflet-pm-dragging');\n\n                // fire pm:dragend event\n                this._layer.fire('pm:dragend');\n\n                // fire edit\n                this._fireEdit();\n            }, 10);\n\n            return true;\n        };\n\n        const onMouseMove = (e) => {\n            if(!this._dragging) {\n                // set state\n                this._dragging = true;\n                L.DomUtil.addClass(el, 'leaflet-pm-dragging');\n\n                // bring it to front to prevent drag interception\n                this._layer.bringToFront();\n\n                // disbale map drag\n                this._layer._map.dragging.disable();\n\n                // hide markers\n                this._markerGroup.clearLayers();\n\n                // fire pm:dragstart event\n                this._layer.fire('pm:dragstart');\n            }\n\n            this._onLayerDrag(e);\n        };\n\n        this._layer.on('mousedown', (e) => {\n            // save for delta calculation\n            this._tempDragCoord = e.latlng;\n\n            this._layer.on('mouseup', onMouseUp);\n\n            // listen to mousemove on map (instead of polygon),\n            // otherwise fast mouse movements stop the drag\n            this._layer._map.on('mousemove', onMouseMove);\n        });\n    },\n    dragging() {\n        return this._dragging;\n    },\n\n    _onLayerDrag(e) {\n        // latLng of mouse event\n        const latlng = e.latlng;\n\n        // delta coords (how far was dragged)\n        const deltaLatLng = {\n            lat: latlng.lat - this._tempDragCoord.lat,\n            lng: latlng.lng - this._tempDragCoord.lng,\n        };\n\n        // create the new coordinates array\n        const coords = this._layer._latlngs[0];\n        const newLatLngs = coords.map((currentLatLng) => {\n            return {\n                lat: currentLatLng.lat + deltaLatLng.lat,\n                lng: currentLatLng.lng + deltaLatLng.lng,\n            };\n        });\n\n        // set new coordinates and redraw\n        this._layer.setLatLngs(newLatLngs).redraw();\n\n        // save current latlng for next delta calculation\n        this._tempDragCoord = latlng;\n\n        // fire pm:dragstart event\n        this._layer.fire('pm:drag');\n    },\n};\n","// this isn't included anymore but if you want to re-enable it:\n// 1. include this mixing inside L.PM.Edit.js\n// 2. include the turf.js dependency in your project before leaflet.pm\n// 3. uncomment all code inside L.PM.Edit.Poly that has an if-check on options.preventOverlap\n// 4. pass the option preventOverlap to the enable() function on your layer\nvar OverlapMixin = {\n\n    _applyPossibleCoordsChanges() {\n        // after the polygon was dragged and changed it's shape because of unallowed intersecting\n        // with another polygon, this function takes the temporarily drawn polygon (during drag) and applies\n        // it's coordinates to our main polygon\n\n        if(this._tempPolygon) {\n            // get the new coordinates\n            const latlngs = this._tempPolygon.getLayers()[0].getLatLngs();\n\n            // reshape our main polygon\n            this._poly.setLatLngs(latlngs).redraw();\n\n            // initialize the markers again\n            this._initMarkers();\n        }\n    },\n\n    _drawTemporaryPolygon(geoJson) {\n        // hide our polygon\n        this._poly.setStyle({ opacity: 0, fillOpacity: 0 });\n\n        // draw a temporary polygon (happens during drag & intersection)\n        this._tempPolygon = L.geoJson(geoJson).addTo(this._poly._map).bringToBack();\n    },\n\n    _handleOverlap() {\n        const mainPoly = this._poly;\n        const layers = this._layerGroup.getLayers();\n        let changed = false;\n        let resultingGeoJson = this._poly.toGeoJSON();\n\n        layers\n        .filter(layer => !Object.is(layer, mainPoly))\n        .map((layer) => {\n            let intersect;\n\n            // this needs to be in a try catch block because turf isn't reliable\n            // it throws self-intersection errors even if there are none\n            try {\n                intersect = turf.intersect(resultingGeoJson, layer.toGeoJSON());\n            } catch(e) {\n                console.warn('Turf Error.');\n            }\n\n            if(intersect) {\n                resultingGeoJson = turf.difference(resultingGeoJson, layer.toGeoJSON());\n\n                // if the resulting polygon is a MultiPolygon, don't handle it.\n                if(resultingGeoJson.geometry.type !== 'MultiPolygon') {\n                    changed = true;\n                }\n            }\n\n            return true;\n        });\n\n        if(this._tempPolygon) {\n            this._tempPolygon.remove();\n            delete this._tempPolygon;\n        }\n\n        if(changed) {\n            this._drawTemporaryPolygon(resultingGeoJson);\n        } else {\n            this._poly.setStyle({ opacity: 1, fillOpacity: 0.2 });\n        }\n    },\n};\n","const SnapMixin = {\n    _initSnappableMarkers() {\n        this.options.snapDistance = this.options.snapDistance || 30;\n\n        this._markers.forEach((marker) => {\n            marker.off('drag', this._handleSnapping, this);\n            marker.on('drag', this._handleSnapping, this);\n\n            marker.off('dragend', this._cleanupSnapping, this);\n            marker.on('dragend', this._cleanupSnapping, this);\n        });\n\n\n        this._layer.off('pm:dragstart', this._unsnap, this);\n        this._layer.on('pm:dragstart', this._unsnap, this);\n    },\n\n    _unsnap() {\n        // delete the last snap\n        delete this._snapLatLng;\n    },\n    _cleanupSnapping() {\n        // delete it, we need to refresh this with each start of a drag because\n        // meanwhile, new layers could've been added to the map\n        delete this._snapList;\n\n        this.debugIndicatorLines.forEach((line) => {\n            line.remove();\n        });\n    },\n    _handleSnapping(e) {\n        // create a list of polygons that the marker could snap to\n        // this isn't inside a movestart/dragstart callback because middlemarkers are initialized\n        // after dragstart/movestart so it wouldn't fire for them\n        if(this._snapList === undefined) {\n            this._createSnapList(e);\n        }\n\n        // if there are no layers to snap to, stop here\n        if(this._snapList.length <= 0) {\n            return false;\n        }\n\n        const marker = e.target;\n\n        // get the closest layer, it's closest latlng, segment and the distance\n        const closestLayer = this._calcClosestLayer(marker.getLatLng(), this._snapList);\n\n        // find the final latlng that we want to snap to\n        const snapLatLng = this._checkPrioritiySnapping(closestLayer);\n\n        // minimal distance before marker snaps (in pixels)\n        const minDistance = this.options.snapDistance;\n\n        // event info for pm:snap and pm:unsnap\n        const eventInfo = {\n            marker,\n            snapLatLng,\n            segment: closestLayer.segment,\n            layer: this._layer,\n            layerInteractedWith: closestLayer.layer, // for lack of a better property name\n        };\n\n        if(closestLayer.distance < minDistance) {\n            // snap the marker\n            marker.setLatLng(snapLatLng);\n            this._onMarkerDrag(e);\n\n            // check if the snapping position differs from the last snap\n            if(this._snapLatLng !== snapLatLng) {\n                // if yes, save it and fire the pm:snap event\n                this._snapLatLng = snapLatLng;\n                marker.fire('pm:snap', eventInfo);\n                this._layer.fire('pm:snap', eventInfo);\n            }\n        } else if(this._snapLatLng) {\n            // no more snapping\n\n            // if it was previously snapped...\n            // ...unsnap\n            this._unsnap(eventInfo);\n\n            // and fire unsnap event\n            eventInfo.marker.fire('pm:unsnap', eventInfo);\n            this._layer.fire('pm:unsnap', eventInfo);\n        }\n\n        return true;\n    },\n\n    // we got the point we want to snap to (C), but we need to check if a coord of the polygon\n    // receives priority over C as the snapping point. Let's check this here\n    _checkPrioritiySnapping(closestLayer) {\n        const map = this._layer._map;\n\n        // A and B are the points of the closest segment to P (the marker position we want to snap)\n        const A = closestLayer.segment[0];\n        const B = closestLayer.segment[1];\n\n        // C is the point we would snap to on the segment.\n        // The closest point on the closest segment of the closest polygon to P. That's right.\n        const C = closestLayer.latlng;\n\n        // distances from A to C and B to C to check which one is closer to C\n        const distanceAC = this._getDistance(map, A, C);\n        const distanceBC = this._getDistance(map, B, C);\n\n        // closest latlng of A and B to C\n        const closestVertexLatLng = distanceAC < distanceBC ? A : B;\n\n        // distance between closestVertexLatLng and C\n        const shortestDistance = distanceAC < distanceBC ? distanceAC : distanceBC;\n\n        // the distance that needs to be undercut to trigger priority\n        const priorityDistance = this.options.snapDistance;\n\n        // the latlng we ultemately want to snap to\n        let snapLatlng;\n\n        // if C is closer to the closestVertexLatLng (A or B) than the snapDistance,\n        // the closestVertexLatLng has priority over C as the snapping point.\n        if(shortestDistance < priorityDistance) {\n            snapLatlng = closestVertexLatLng;\n        } else {\n            snapLatlng = closestLayer.latlng;\n        }\n\n        // return the snapping point\n        return snapLatlng;\n    },\n\n    _createSnapList() {\n        let layers = [];\n        const debugIndicatorLines = [];\n\n        // find all layers that are or inherit from Polylines...\n        this._layer._map.eachLayer((layer) => {\n            if(layer instanceof L.Polyline) {\n                layers.push(layer);\n\n                // this is for debugging\n                const debugLine = L.polyline([], { color: 'red' });\n                debugIndicatorLines.push(debugLine);\n\n                // uncomment ðŸ‘‡ this in to show debugging lines\n                // debugLine.addTo(this._layer._map);\n            }\n        });\n\n        // ...except myself\n        layers = layers.filter(layer => this._layer !== layer);\n\n        this._snapList = layers;\n        this.debugIndicatorLines = debugIndicatorLines;\n    },\n    _calcClosestLayer(latlng, layers) {\n        // the closest polygon to our dragged marker latlng\n        let closestLayer = {};\n\n        // loop through the layers\n        layers.forEach((layer, index) => {\n            // find the closest latlng, segment and the distance of this layer to the dragged marker latlng\n            const results = this._calcLayerDistances(latlng, layer);\n\n            // show indicator lines, it's for debugging\n            this.debugIndicatorLines[index].setLatLngs([latlng, results.latlng]);\n\n            // save the info if it doesn't exist or if the distance is smaller than the previous one\n            if(closestLayer.distance === undefined || results.distance < closestLayer.distance) {\n                closestLayer = results;\n                closestLayer.layer = layer;\n            }\n        });\n\n        // return the closest layer and it's data\n        // if there is no closest layer, return undefined\n        return closestLayer;\n    },\n\n    _calcLayerDistances(latlng, layer) {\n        const map = this._layer._map;\n\n        // is this a polyline, or polygon?\n        const closedShape = layer instanceof L.Polygon;\n\n        // the point P which we want to snap (probpably the marker that is dragged)\n        const P = latlng;\n\n        let coords;\n\n        // the coords of the layer\n        if(closedShape) {\n            coords = layer.getLatLngs()[0];\n        } else {\n            coords = layer.getLatLngs();\n        }\n\n        // the closest segment (line between two points) of the layer\n        let closestSegment;\n\n        // the shortest distance from P to closestSegment\n        let shortestDistance;\n\n        // loop through the coords of the layer\n        coords.forEach((coord, index) => {\n            // take this coord (A)...\n            const A = coord;\n            let nextIndex;\n\n            // and the next coord (B) as points\n            if(closedShape) {\n                nextIndex = index + 1 === coords.length ? 0 : index + 1;\n            } else {\n                nextIndex = index + 1 === coords.length ? undefined : index + 1;\n            }\n\n            const B = coords[nextIndex];\n\n            if(B) {\n                // calc the distance between P and AB-segment\n                const distance = this._getDistanceToSegment(map, P, A, B);\n\n                // is the distance shorter than the previous one? Save it and the segment\n                if(shortestDistance === undefined || distance < shortestDistance) {\n                    shortestDistance = distance;\n                    closestSegment = [A, B];\n                }\n            }\n\n            return true;\n        });\n\n        // now, take the closest segment (closestSegment) and calc the closest point to P on it.\n        const C = this._getClosestPointOnSegment(map, latlng, closestSegment[0], closestSegment[1]);\n\n        // return the latlng of that sucker\n        return {\n            latlng: C,\n            segment: closestSegment,\n            distance: shortestDistance,\n        };\n    },\n\n    _getClosestPointOnSegment(map, latlng, latlngA, latlngB) {\n        let maxzoom = map.getMaxZoom();\n        if (maxzoom === Infinity) {\n            maxzoom = map.getZoom();\n        }\n        const P = map.project(latlng, maxzoom);\n        const A = map.project(latlngA, maxzoom);\n        const B = map.project(latlngB, maxzoom);\n        const closest = L.LineUtil.closestPointOnSegment(P, A, B);\n        return map.unproject(closest, maxzoom);\n    },\n    _getDistanceToSegment(map, latlng, latlngA, latlngB) {\n        const P = map.latLngToLayerPoint(latlng);\n        const A = map.latLngToLayerPoint(latlngA);\n        const B = map.latLngToLayerPoint(latlngB);\n        return L.LineUtil.pointToSegmentDistance(P, A, B);\n    },\n    _getDistance(map, latlngA, latlngB) {\n        return map.latLngToLayerPoint(latlngA).distanceTo(map.latLngToLayerPoint(latlngB));\n    },\n};\n","/**\n*\n* A Leaflet Plugin For Editing Geometry Layers in Leaflet 1.0\n* by Sumit Kumar (@TweetsOfSumit)\n* Github Repo: https://github.com/codeofsumit/leaflet.pm\n*/\n\nL.PM = L.PM || {\n    initialize() {\n        function initLayerGroup() {\n            this.pm = new L.PM.Edit.LayerGroup(this);\n        }\n\n        L.LayerGroup.addInitHook(initLayerGroup);\n\n\n        function initPolygon() {\n            this.pm = new L.PM.Edit.Poly(this);\n        }\n\n        L.Polygon.addInitHook(initPolygon);\n\n\n        function initPolyline() {\n            this.pm = new L.PM.Edit.Line(this);\n        }\n\n        L.Polyline.addInitHook(initPolyline);\n\n\n        function initMap() {\n            this.pm = new L.PM.Map(this);\n        }\n\n        L.Map.addInitHook(initMap);\n    },\n};\n\n// initialize leaflet.pm\nL.PM.initialize();\n","L.PM.Map = L.Class.extend({\n    initialize(map) {\n        this.map = map;\n        this.Draw = new L.PM.Draw(map);\n        this.Toolbar = new L.PM.Toolbar(map);\n    },\n    addControls(options) {\n        this.Toolbar.addControls(options);\n    },\n    enableDraw(shape = 'Poly') {\n        this.Draw.enable(shape);\n    },\n    disableDraw(shape = 'Poly') {\n        this.Draw.disable(shape);\n    },\n    removeLayer(e) {\n        const layer = e.target;\n        if(!layer._layers && !layer.pm.dragging()) {\n            e.target.remove();\n        }\n    },\n    toggleRemoval(enabled) {\n        if(enabled) {\n            this.map.eachLayer((layer) => {\n                layer.on('click', this.removeLayer);\n            });\n        } else {\n            this.map.eachLayer((layer) => {\n                layer.off('click', this.removeLayer);\n            });\n        }\n    },\n    globalEditEnabled() {\n        return this._globalEditMode;\n    },\n    toggleGlobalEditMode(options) {\n        // find all layers that are or inherit from Polylines...\n        const layers = [];\n        this.map.eachLayer((layer) => {\n            if(layer instanceof L.Polyline) {\n                layers.push(layer);\n            }\n        });\n\n        if(this.globalEditEnabled()) {\n            // disable\n\n            this._globalEditMode = false;\n\n            layers.forEach((layer) => {\n                layer.pm.disable();\n            });\n        } else {\n            // enable\n\n            this._globalEditMode = true;\n\n            layers.forEach((layer) => {\n                layer.pm.enable(options);\n            });\n        }\n    },\n});\n","L.PM.Draw = L.Class.extend({\n\n    initialize(map) {\n        // save the map\n        this._map = map;\n\n        // define all possible shapes that can be drawn\n        this.shapes = ['Poly', 'Line'];\n\n        // initiate drawing class for our shapes\n        this.shapes.forEach((shape) => {\n            this[shape] = new L.PM.Draw[shape](this._map);\n        });\n    },\n\n    getShapes() {\n        // if somebody wants to know what shapes are available\n        return this.shapes;\n    },\n    enable(shape) {\n        if(!shape) {\n            throw new Error(`Error: Please pass a shape as a parameter. Possible shapes are: ${this.getShapes().join(',')}`);\n        }\n\n        // disable drawing for all shapes\n        this.disable();\n\n        // enable draw for a shape\n        this[shape].enable();\n    },\n    disable() {\n        // there can only be one drawing mode active at a time on a map\n        // so it doesn't matter which one should be disabled.\n        // just disable all of them\n        this.shapes.forEach((shape) => {\n            this[shape].disable();\n        });\n    },\n    addControls() {\n        // add control buttons for our shapes\n        this.shapes.forEach((shape) => {\n            this[shape].addButton();\n        });\n    },\n});\n","L.PM.Edit = L.Class.extend({\n    includes: [DragMixin, SnapMixin]\n});\n","L.PM.Draw.Line = L.PM.Draw.extend({\n    initialize(map) {\n        this._map = map;\n        this._shape = 'Line';\n        this.toolbarButtonName = 'drawPolyline';\n    },\n    enable() {\n        // enable draw mode\n\n        this._enabled = true;\n\n        // create a new layergroup\n        this._layerGroup = new L.LayerGroup();\n        this._layerGroup.addTo(this._map);\n\n        // this is the polyLine that'll make up the polygon\n        this._polyline = L.polyline([], { color: 'red' });\n        this._layerGroup.addLayer(this._polyline);\n\n        // this is the hintline from the mouse cursor to the last marker\n        this._hintline = L.polyline([], {\n            color: 'red',\n            dashArray: [5, 5],\n        });\n        this._layerGroup.addLayer(this._hintline);\n\n\n        // change map cursor\n        this._map._container.style.cursor = 'crosshair';\n\n        // create a polygon-point on click\n        this._map.on('click', this._createPolygonPoint, this);\n\n        // sync the hintline on mousemove\n        this._map.on('mousemove', this._syncHintLine, this);\n\n        // fire drawstart event\n        this._map.fire('pm:drawstart', { shape: this._shape });\n\n        // toggle the draw button of the Toolbar in case drawing mode got enabled without the button\n        this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, true);\n    },\n    disable() {\n        // disable draw mode\n\n        // cancel, if drawing mode isn't even enabled\n        if(!this._enabled) {\n            return;\n        }\n\n        this._enabled = false;\n\n        // reset cursor\n        this._map._container.style.cursor = 'default';\n\n        // unbind listeners\n        this._map.off('click', this._createPolygonPoint);\n        this._map.off('mousemove', this._syncHintLine);\n\n        // remove layer\n        this._map.removeLayer(this._layerGroup);\n\n        // fire drawend event\n        this._map.fire('pm:drawend', { shape: this._shape });\n\n        // toggle the draw button of the Toolbar in case drawing mode got disabled without the button\n        this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, false);\n    },\n    enabled() {\n        return this._enabled;\n    },\n    toggle(options) {\n        if(this.enabled()) {\n            this.disable();\n        } else {\n            this.enable(options);\n        }\n    },\n    _syncHintLine(e) {\n        const polyPoints = this._polyline.getLatLngs();\n\n        if(polyPoints.length > 0) {\n            const lastPolygonPoint = polyPoints[polyPoints.length - 1];\n            this._hintline.setLatLngs([lastPolygonPoint, e.latlng]);\n        }\n    },\n    _createPolygonPoint(e) {\n        // is this the first point?\n        const first = this._polyline.getLatLngs().length === 0;\n\n        this._polyline.addLatLng(e.latlng);\n        this._createMarker(e.latlng, first);\n\n\n        this._hintline.setLatLngs([e.latlng, e.latlng]);\n    },\n    _finishShape() {\n        // get coordinates, create the leaflet shape and add it to the map\n        const coords = this._polyline.getLatLngs();\n        const polylineLayer = L.polyline(coords).addTo(this._map);\n\n        // disable drawing\n        this.disable();\n\n        // fire the pm:create event and pass shape and layer\n        this._map.fire('pm:create', {\n            shape: this._shape,\n            layer: polylineLayer,\n        });\n    },\n    _createMarker(latlng) {\n        // create the new marker\n        const marker = new L.Marker(latlng, {\n            draggable: false,\n            icon: L.divIcon({ className: 'marker-icon' }),\n        });\n\n        // add it to the map\n        this._layerGroup.addLayer(marker);\n\n        // a click on any marker finishes this shape\n        marker.on('click', this._finishShape, this);\n\n        return marker;\n    },\n});\n","L.PM.Draw.Poly = L.PM.Draw.Line.extend({\n\n    initialize(map) {\n        this._map = map;\n        this._shape = 'Poly';\n        this.toolbarButtonName = 'drawPolygon';\n    },\n    _finishShape() {\n        // get coordinates, create the leaflet shape and add it to the map\n        const coords = this._polyline.getLatLngs();\n        const polygonLayer = L.polygon(coords).addTo(this._map);\n\n        // disable drawing\n        this.disable();\n\n        // fire the pm:create event and pass shape and layer\n        this._map.fire('pm:create', {\n            shape: this._shape,\n            layer: polygonLayer,\n        });\n    },\n    _createMarker(latlng, first) {\n        // create the new marker\n        const marker = new L.Marker(latlng, {\n            draggable: false,\n            icon: L.divIcon({ className: 'marker-icon' }),\n        });\n\n        // add it to the map\n        this._layerGroup.addLayer(marker);\n\n        // if the first marker gets clicked again, finish this shape\n        if(first) {\n            marker.on('click', this._finishShape, this);\n        }\n    },\n});\n","// LayerGroup doesn't inherit from L.PM.Edit because it's just calling L.PM.Edit.Poly\n// (which inherits from L.PM.Edit) for each layer,\n// so it's not really a parent class\nL.PM.Edit.LayerGroup = L.Class.extend({\n    initialize(layerGroup) {\n        this._layerGroup = layerGroup;\n        this._layers = layerGroup.getLayers();\n\n        const availableEvents = [\n            'pm:edit',\n            'pm:dragstart',\n            'pm:drag',\n            'pm:dragend',\n            'pm:snap',\n            'pm:unsnap',\n            'pm:raiseMarkers',\n            'pm:markerdragend',\n            'pm:markerdragstart',\n        ];\n\n        this._layers.forEach((layer) => {\n            // listen to the events of the layers in this group\n            availableEvents.forEach((event) => {\n                layer.on(event, this._fireEvent, this);\n            });\n\n            // add reference for the group to each layer inside said group\n            layer.pm._layerGroup = this._layerGroup;\n        });\n\n\n        // if a new layer is added to the group, reinitialize\n        // This only works for FeatureGroups, not LayerGroups\n        // https://github.com/Leaflet/Leaflet/issues/4861\n        this._layerGroup.on('layeradd', (e) => {\n            this.initialize(layerGroup);\n\n            // if editing was already enabled for this group, enable it again\n            // so the new layers are enabled\n            if(e.target.pm.enabled()) {\n                this.enable(this.getOptions());\n            }\n        });\n    },\n    _fireEvent(e) {\n        this._layerGroup.fireEvent(e.type, e);\n    },\n    toggleEdit(options) {\n        this._options = options;\n        this._layers.forEach((layer) => {\n            layer.pm.toggleEdit(options);\n        });\n    },\n    enable(options) {\n        this._options = options;\n        this._layers.forEach((layer) => {\n            layer.pm.enable(options);\n        });\n    },\n    disable() {\n        this._layers.forEach((layer) => {\n            layer.pm.disable();\n        });\n    },\n    enabled() {\n        const enabled = this._layers.find(layer => layer.pm.enabled());\n        return !!enabled;\n    },\n    dragging() {\n        const dragging = this._layers.find(layer => layer.pm.dragging());\n        return !!dragging;\n    },\n    getOptions() {\n        return this._options;\n    },\n});\n","L.PM.Edit.Line = L.PM.Edit.extend({\n    initialize(layer) {\n        this._layer = layer;\n        this._enabled = false;\n    },\n\n    toggleEdit(options) {\n        if(!this.enabled()) {\n            this.enable(options);\n        } else {\n            this.disable();\n        }\n    },\n\n    enable(options = {}) {\n        this.options = options;\n\n        if(!this.enabled()) {\n            // if it was already enabled, disable first\n            // we don't block enabling again because new options might be passed\n            this.disable();\n        }\n\n        // change state\n        this._enabled = true;\n\n        // init markers\n        this._initMarkers();\n\n        // if polygon gets removed from map, disable edit mode\n        this._layer.on('remove', (e) => {\n            this.disable(e.target);\n        });\n\n\n        // preventOverlap needs the turf library. If it's not included, deactivate it again\n        // if(window.turf === undefined && this.options.preventOverlap) {\n        //     console.warn('TurfJS not found, preventOverlap is deactivated');\n        //     this.options.preventOverlap = false;\n        // }\n\n        if(this.options.draggable) {\n            this._initDraggableLayer();\n        }\n\n        // if(this.options.preventOverlap) {\n        //\n        //     // if the dragged polygon should be cutted when overlapping another polygon, go ahead\n        //     this._layer.on('pm:drag', this._handleOverlap, this);\n        //\n        //     // set new coordinates, more details inside the function\n        //     this._layer.on('pm:dragend', this._applyPossibleCoordsChanges, this);\n        // }\n    },\n\n    enabled() {\n        return this._enabled;\n    },\n\n    disable(poly = this._layer) {\n        // if it's not enabled, it doesn't need to be disabled\n        if(!this.enabled()) {\n            return false;\n        }\n\n        // prevent disabling if polygon is being dragged\n        if(poly.pm._dragging) {\n            return false;\n        }\n        poly.pm._enabled = false;\n        poly.pm._markerGroup.clearLayers();\n\n        // clean up draggable\n        poly.off('mousedown');\n        poly.off('mouseup');\n\n        // remove draggable class\n        const el = poly._path;\n        L.DomUtil.removeClass(el, 'leaflet-pm-draggable');\n\n        return true;\n    },\n\n    _initMarkers() {\n        const map = this._layer._map;\n\n        // cleanup old ones first\n        if(this._markerGroup) {\n            this._markerGroup.clearLayers();\n        }\n\n        // add markerGroup to map, markerGroup includes regular and middle markers\n        this._markerGroup = new L.LayerGroup();\n        map.addLayer(this._markerGroup);\n\n        // create marker for each coordinate\n        const coords = this._layer._latlngs;\n\n        // the marker array, it includes only the markers that're associated with the coordinates\n        this._markers = coords.map(this._createMarker, this);\n\n        // create small markers in the middle of the regular markers\n        for(let k = 0; k < coords.length - 1; k += 1) {\n            const nextIndex = k + 1;\n            this._createMiddleMarker(\n                this._markers[k], this._markers[nextIndex]\n            );\n        }\n\n        if(this.options.snappable) {\n            this._initSnappableMarkers();\n        }\n    },\n\n    // creates initial markers for coordinates\n    _createMarker(latlng, index) {\n        const marker = new L.Marker(latlng, {\n            draggable: true,\n            icon: L.divIcon({ className: 'marker-icon' }),\n        });\n\n        marker._origLatLng = latlng;\n        marker._index = index;\n\n        marker.on('dragstart', this._onMarkerDragStart, this);\n        marker.on('drag', this._onMarkerDrag, this);\n        marker.on('dragend', this._onMarkerDragEnd, this);\n        marker.on('contextmenu', this._removeMarker, this);\n\n        this._markerGroup.addLayer(marker);\n\n        return marker;\n    },\n\n    // creates the middle markes between coordinates\n    _createMiddleMarker(leftM, rightM) {\n        const latlng = this._calcMiddleLatLng(leftM.getLatLng(), rightM.getLatLng());\n\n        const middleMarker = this._createMarker(latlng);\n        const middleIcon = L.divIcon({ className: 'marker-icon marker-icon-middle' });\n        middleMarker.setIcon(middleIcon);\n\n        // save reference to this middle markers on the neighboor regular markers\n        leftM._middleMarkerNext = middleMarker;\n        rightM._middleMarkerPrev = middleMarker;\n\n        middleMarker.on('click', () => {\n            // TODO: move the next two lines inside _addMarker() as soon as\n            // https://github.com/Leaflet/Leaflet/issues/4484\n            // is fixed\n            const icon = L.divIcon({ className: 'marker-icon' });\n            middleMarker.setIcon(icon);\n\n            this._addMarker(middleMarker, leftM, rightM);\n        });\n        middleMarker.on('movestart', () => {\n            // TODO: This is a workaround. Remove the moveend listener and\n            // callback as soon as this is fixed:\n            // https://github.com/Leaflet/Leaflet/issues/4484\n            middleMarker.on('moveend', () => {\n                const icon = L.divIcon({ className: 'marker-icon' });\n                middleMarker.setIcon(icon);\n\n                middleMarker.off('moveend');\n            });\n\n            this._addMarker(middleMarker, leftM, rightM);\n        });\n    },\n\n    // adds a new marker from a middlemarker\n    _addMarker(newM, leftM, rightM) {\n        // first, make this middlemarker a regular marker\n        newM.off('movestart');\n        newM.off('click');\n\n        // now, create the polygon coordinate point for that marker\n        const latlng = newM.getLatLng();\n        const coords = this._layer._latlngs;\n        const index = leftM._index + 1;\n\n        coords.splice(index, 0, latlng);\n\n        // associate polygon coordinate with marker coordinate\n        newM._origLatLng = coords[index];\n\n        // push into marker array & update the indexes for every marker\n        this._markers.splice(index, 0, newM);\n        this._markers.map((marker, i) => {\n            marker._index = i;\n            return true;\n        });\n\n        // create the new middlemarkers\n        this._createMiddleMarker(leftM, newM);\n        this._createMiddleMarker(newM, rightM);\n\n        // fire edit event\n        this._fireEdit();\n\n        if(this.options.snappable) {\n            this._initSnappableMarkers();\n        }\n    },\n\n    _removeMarker(e) {\n        const marker = e.target;\n        const coords = this._layer._latlngs;\n        const index = marker._index;\n\n        // only continue if this is NOT a middle marker (those can't be deleted)\n        if(index === undefined) {\n            return;\n        }\n\n        // remove polygon coordinate from this marker\n        coords.splice(index, 1);\n\n        // if the poly has no coordinates left, remove the layer\n        // else, redraw it\n        if(coords.length < 1) {\n            this._layer.remove();\n        } else {\n            this._layer.redraw();\n        }\n\n        // remove the marker and the middlemarkers next to it from the map\n        if(marker._middleMarkerPrev) {\n            this._markerGroup.removeLayer(marker._middleMarkerPrev);\n        }\n        if(marker._middleMarkerNext) {\n            this._markerGroup.removeLayer(marker._middleMarkerNext);\n        }\n\n        this._markerGroup.removeLayer(marker);\n\n        // find neighbor marker-indexes\n        const leftMarkerIndex = index - 1 < 0 ? undefined : index - 1;\n        const rightMarkerIndex = index + 1 >= this._markers.length ? undefined : index + 1;\n\n        // don't create middlemarkers if there is only one marker left\n        // or if the middlemarker would be between the first and last coordinate of a polyline\n        if(rightMarkerIndex && leftMarkerIndex && rightMarkerIndex !== leftMarkerIndex) {\n            const leftM = this._markers[leftMarkerIndex];\n            const rightM = this._markers[rightMarkerIndex];\n            this._createMiddleMarker(leftM, rightM);\n        }\n\n        // remove the marker from the markers array & update indexes\n        this._markers.splice(index, 1);\n        this._markers.map((m, i) => {\n            m._index = i;\n            return true;\n        });\n\n        // if the polygon should be cutted when overlapping another polygon, do it now\n        // if(this.options.preventOverlap) {\n        //     this._handleOverlap();\n        //     this._applyPossibleCoordsChanges();\n        // }\n\n        // fire edit event\n        this._fireEdit();\n    },\n\n    _onMarkerDrag(e) {\n        // dragged marker\n        const marker = e.target;\n\n        // the dragged markers neighbors\n        const nextMarkerIndex = marker._index + 1 >= this._markers.length ? 0 : marker._index + 1;\n        const prevMarkerIndex = marker._index - 1 < 0 ? this._markers.length - 1 : marker._index - 1;\n\n        // update marker coordinates which will update polygon coordinates\n        L.extend(marker._origLatLng, marker._latlng);\n        this._layer.redraw();\n\n        // update middle markers on the left and right\n        // be aware that \"next\" and \"prev\" might be interchanged, depending on the geojson array\n        const markerLatLng = marker.getLatLng();\n        const prevMarkerLatLng = this._markers[prevMarkerIndex].getLatLng();\n        const nextMarkerLatLng = this._markers[nextMarkerIndex].getLatLng();\n\n        if(marker._middleMarkerNext) {\n            const middleMarkerNextLatLng = this._calcMiddleLatLng(markerLatLng, nextMarkerLatLng);\n            marker._middleMarkerNext.setLatLng(middleMarkerNextLatLng);\n        }\n\n        if(marker._middleMarkerPrev) {\n            const middleMarkerPrevLatLng = this._calcMiddleLatLng(markerLatLng, prevMarkerLatLng);\n            marker._middleMarkerPrev.setLatLng(middleMarkerPrevLatLng);\n        }\n\n        // if the dragged polygon should be cutted when overlapping another polygon, go ahead\n        // if(this.options.preventOverlap) {\n        //     this._handleOverlap();\n        // }\n    },\n\n    _onMarkerDragEnd(e) {\n        // if(this.options.preventOverlap) {\n        //     this._applyPossibleCoordsChanges();\n        // }\n\n        this._layer.fire('pm:markerdragend', {\n            markerEvent: e,\n        });\n\n        // fire edit event\n        this._fireEdit();\n    },\n    _onMarkerDragStart(e) {\n        this._layer.fire('pm:markerdragstart', {\n            markerEvent: e,\n        });\n    },\n\n    _fireEdit() {\n        // fire edit event\n        this._layer.edited = true;\n        this._layer.fire('pm:edit');\n    },\n\n    _calcMiddleLatLng(latlng1, latlng2) {\n        // calculate the middle coordinates between two markers\n        // TODO: put this into a utils.js or something\n\n        const map = this._layer._map;\n        const p1 = map.project(latlng1);\n        const p2 = map.project(latlng2);\n\n        const latlng = map.unproject(p1._add(p2)._divideBy(2));\n\n        return latlng;\n    },\n});\n","L.PM.Edit.Poly = L.PM.Edit.Line.extend({\n\n    _initMarkers() {\n        const map = this._layer._map;\n\n        // cleanup old ones first\n        if(this._markerGroup) {\n            this._markerGroup.clearLayers();\n        }\n\n        // add markerGroup to map, markerGroup includes regular and middle markers\n        this._markerGroup = new L.LayerGroup();\n        map.addLayer(this._markerGroup);\n\n        // create marker for each coordinate\n        const coords = this._layer._latlngs[0];\n\n        // the marker array, it includes only the markers that're associated with the coordinates\n        this._markers = coords.map(this._createMarker, this);\n\n        // create small markers in the middle of the regular markers\n        for(let k = 0; k < coords.length; k += 1) {\n            const nextIndex = k + 1 >= coords.length ? 0 : k + 1;\n            this._createMiddleMarker(\n                this._markers[k], this._markers[nextIndex]\n            );\n        }\n\n        if(this.options.snappable) {\n            this._initSnappableMarkers();\n        }\n    },\n\n    // adds a new marker from a middlemarker\n    _addMarker(newM, leftM, rightM) {\n        // first, make this middlemarker a regular marker\n        newM.off('movestart');\n        newM.off('click');\n\n        // now, create the polygon coordinate point for that marker\n        const latlng = newM.getLatLng();\n        const coords = this._layer._latlngs[0];\n        const index = leftM._index + 1;\n\n        coords.splice(index, 0, latlng);\n\n        // associate polygon coordinate with marker coordinate\n        newM._origLatLng = coords[index];\n\n        // push into marker array & update the indexes for every marker\n        this._markers.splice(index, 0, newM);\n        this._markers.map((marker, i) => {\n            marker._index = i;\n            return true;\n        });\n\n        // create the new middlemarkers\n        this._createMiddleMarker(leftM, newM);\n        this._createMiddleMarker(newM, rightM);\n\n        // fire edit event\n        this._fireEdit();\n\n        if(this.options.snappable) {\n            this._initSnappableMarkers();\n        }\n    },\n\n    _removeMarker(e) {\n        const marker = e.target;\n        const coords = this._layer._latlngs[0];\n        const index = marker._index;\n\n        // only continue if this is NOT a middle marker (those can't be deleted)\n        if(index === undefined) {\n            return;\n        }\n\n        // remove polygon coordinate from this marker\n        coords.splice(index, 1);\n\n        // if the poly has no coordinates left, remove the layer\n        // else, redraw it\n        if(coords.length < 1) {\n            this._layer.remove();\n        } else {\n            this._layer.redraw();\n        }\n\n        // remove the marker and the middlemarkers next to it from the map\n        this._markerGroup.removeLayer(marker._middleMarkerPrev);\n        this._markerGroup.removeLayer(marker._middleMarkerNext);\n        this._markerGroup.removeLayer(marker);\n\n        // find neighbor marker-indexes\n        const leftMarkerIndex = index - 1 < 0 ? this._markers.length - 1 : index - 1;\n        const rightMarkerIndex = index + 1 >= this._markers.length ? 0 : index + 1;\n\n        // don't create middlemarkers if there is only one marker left\n        if(rightMarkerIndex !== leftMarkerIndex) {\n            const leftM = this._markers[leftMarkerIndex];\n            const rightM = this._markers[rightMarkerIndex];\n            this._createMiddleMarker(leftM, rightM);\n        }\n\n        // remove the marker from the markers array & update indexes\n        this._markers.splice(index, 1);\n        this._markers.map((m, i) => {\n            m._index = i;\n            return true;\n        });\n\n        // if the polygon should be cutted when overlapping another polygon, do it now\n        // if(this.options.preventOverlap) {\n        //     this._handleOverlap();\n        //     this._applyPossibleCoordsChanges();\n        // }\n\n        // fire edit event\n        this._fireEdit();\n    },\n});\n","L.Control.PMButton = L.Control.extend({\n    options: {\n        position: 'topleft',\n    },\n    // TODO: clean up variable names like _button should be _options and that domNodeVariable stuff\n    initialize(options) {\n        this._button = {};\n        this._button = this.setButton(options);\n    },\n\n    onAdd(map) {\n        this._map = map;\n\n        this._container = this._map.pm.Toolbar.container;\n        this.buttonsDomNode = this._makeButton(this._button);\n        this._container.appendChild(this.buttonsDomNode);\n\n        return this._container;\n    },\n\n    onRemove() {\n    },\n\n    setButton(options) {\n        const button = {\n            className: options.className,\n            iconUrl: options.iconUrl,\n            onClick: options.onClick,\n            afterClick: options.afterClick,\n            doToggle: options.doToggle,\n            toggleStatus: options.toggleStatus,\n            disableOtherButtons: options.disableOtherButtons,\n        };\n\n        return button;\n    },\n\n    getText() {\n        return this._button.text;\n    },\n\n    getIconUrl() {\n        return this._button.iconUrl;\n    },\n\n    destroy() {\n        this._button = {};\n        this._update();\n    },\n\n    toggle(e) {\n        if(typeof e === 'boolean') {\n            this._button.toggleStatus = e;\n        } else {\n            this._button.toggleStatus = !this._button.toggleStatus;\n        }\n        this._applyStyleClasses();\n\n        return this._button.toggleStatus;\n    },\n    toggled() {\n        return this._button.toggleStatus;\n    },\n    onCreate() {\n        this.toggle(false);\n    },\n    _triggerClick(e) {\n        this._button.onClick(e);\n        this._clicked(e);\n        this._button.afterClick(e);\n    },\n    _makeButton(button) {\n        const newButton = L.DomUtil.create('a', 'leaflet-buttons-control-button', this._container);\n        if(button.toggleStatus) {\n            L.DomUtil.addClass(newButton, 'active');\n        }\n\n        const image = L.DomUtil.create('div', 'control-icon', newButton);\n        if (button.iconUrl) {\n            image.setAttribute('src', button.iconUrl);\n        }\n        if (button.className) {\n            L.DomUtil.addClass(image, button.className);\n        }\n        // before the actual click, trigger a click on currently toggled buttons to\n        // untoggle them and their functionality\n        L.DomEvent.addListener(newButton, 'click', () => {\n            if(this._button.disableOtherButtons) {\n                this._map.pm.Toolbar.triggerClickOnToggledButtons(this);\n            }\n        });\n        L.DomEvent.addListener(newButton, 'click', this._triggerClick, this);\n\n        L.DomEvent.disableClickPropagation(newButton);\n        return newButton;\n    },\n\n    _applyStyleClasses() {\n        if(!this._container) {\n            return;\n        }\n\n        if(!this._button.toggleStatus) {\n            L.DomUtil.removeClass(this.buttonsDomNode, 'active');\n        } else {\n            L.DomUtil.addClass(this.buttonsDomNode, 'active');\n        }\n    },\n\n    _clicked() {\n        if(this._button.doToggle) {\n            this.toggle();\n        }\n        return;\n    },\n\n});\n","/**\n* The Icons used in this Toolbar are CC-BY Glyphicons - http://glyphicons.com/\n*/\n\nL.PM.Toolbar = L.Class.extend({\n    options: {\n        drawPolygon: true,\n        drawPolyline: true,\n        editPolygon: true,\n        dragPolygon: false,\n        deleteLayer: true,\n    },\n    initialize(map) {\n        this.map = map;\n\n        this.buttons = {};\n        this.container = L.DomUtil.create('div', 'leaflet-pm-toolbar leaflet-bar leaflet-control');\n        this._defineButtons();\n    },\n    getButtons() {\n        return this.buttons;\n    },\n\n    addControls(options = this.options) {\n        // adds all buttons to the map specified inside options\n\n        // first set the options\n        L.Util.setOptions(this, options);\n\n        // now show the specified buttons\n        this._showHideButtons();\n    },\n    _addButton(name, button) {\n        this.buttons[name] = button;\n        this.options[name] = this.options[name] || false;\n\n        return this.buttons[name];\n    },\n    triggerClickOnToggledButtons(exceptThisButton) {\n        // this function is used when - e.g. drawing mode is enabled and a possible\n        // other active mode (like removal tool) is already active.\n        // we can't have two active modes because of possible event conflicts\n        // so, we trigger a click on all currently active (toggled) buttons\n        for (var name in this.buttons) {\n            if(this.buttons[name] !== exceptThisButton && this.buttons[name].toggled()) {\n                this.buttons[name]._triggerClick();\n            }\n        }\n    },\n    toggleButton(name, status) {\n        // does not fire the events/functionality of the button\n        // this just changes the state and is used if a functionality (like Draw)\n        // is enabled manually via script\n\n        // as some mode got enabled, we still have to trigger the click on the other buttons\n        // to disable their mode\n        this.triggerClickOnToggledButtons(this.buttons[name]);\n\n        // now toggle the state of the button\n        return this.buttons[name].toggle(status);\n    },\n    _defineButtons() {\n        // some buttons are still in their respective classes, like L.PM.Draw.Poly\n        const deleteButton = {\n            className: 'icon-delete',\n            onClick: () => {\n\n            },\n            afterClick: () => {\n                this.map.pm.toggleRemoval(this.buttons.deleteLayer.toggled());\n            },\n            doToggle: true,\n            toggleStatus: false,\n            disableOtherButtons: true,\n        };\n\n        const drawPolyButton = {\n            className: 'icon-polygon',\n            onClick: () => {\n\n            },\n            afterClick: () => {\n                // toggle drawing mode\n                this.map.pm.Draw.Poly.toggle();\n            },\n            doToggle: true,\n            toggleStatus: false,\n            disableOtherButtons: true,\n        };\n\n        const drawLineButton = {\n            className: 'icon-polyline',\n            onClick: () => {\n\n            },\n            afterClick: () => {\n                // toggle drawing mode\n                this.map.pm.Draw.Line.toggle();\n            },\n            doToggle: true,\n            toggleStatus: false,\n            disableOtherButtons: true,\n        };\n\n        const editButton = {\n            className: 'icon-edit',\n            onClick: () => {\n            },\n            afterClick: () => {\n                this.map.pm.toggleGlobalEditMode({\n                    snappable: true,\n                    draggable: true,\n                });\n            },\n            doToggle: true,\n            toggleStatus: false,\n            disableOtherButtons: true,\n        };\n\n        const dragButton = {\n            className: 'icon-drag',\n            onClick: () => {\n            },\n            afterClick: () => {\n\n            },\n            doToggle: true,\n            toggleStatus: false,\n            disableOtherButtons: true,\n        };\n\n        this._addButton('drawPolygon', new L.Control.PMButton(drawPolyButton));\n        this._addButton('drawPolyline', new L.Control.PMButton(drawLineButton));\n        this._addButton('editPolygon', new L.Control.PMButton(editButton));\n        this._addButton('dragPolygon', new L.Control.PMButton(dragButton));\n        this._addButton('deleteLayer', new L.Control.PMButton(deleteButton));\n    },\n\n    _showHideButtons() {\n        // loop through all buttons\n        const buttons = this.getButtons();\n\n        for (var btn in buttons) {\n            if(this.options[btn]) {\n                // if options say the button should be visible, add it to the map\n                buttons[btn].addTo(this.map);\n            } else {\n                // if not, remove it\n                buttons[btn].remove();\n            }\n        }\n    },\n});\n"],"sourceRoot":"/source/"}
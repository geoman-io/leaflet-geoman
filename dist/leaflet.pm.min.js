/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 17);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _Snapping = __webpack_require__(2);\n\nvar _Snapping2 = _interopRequireDefault(_Snapping);\n\nvar _Drag = __webpack_require__(18);\n\nvar _Drag2 = _interopRequireDefault(_Drag);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Edit = L.Class.extend({\n    includes: [_Drag2.default, _Snapping2.default]\n});\n\nexports.default = Edit;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9FZGl0L0wuUE0uRWRpdC5qcz85YjEzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX1NuYXBwaW5nID0gcmVxdWlyZSgnLi4vTWl4aW5zL1NuYXBwaW5nJyk7XG5cbnZhciBfU25hcHBpbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU25hcHBpbmcpO1xuXG52YXIgX0RyYWcgPSByZXF1aXJlKCcuLi9NaXhpbnMvRHJhZycpO1xuXG52YXIgX0RyYWcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfRHJhZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBFZGl0ID0gTC5DbGFzcy5leHRlbmQoe1xuICAgIGluY2x1ZGVzOiBbX0RyYWcyLmRlZmF1bHQsIF9TbmFwcGluZzIuZGVmYXVsdF1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBFZGl0O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL0VkaXQvTC5QTS5FZGl0LmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _Snapping = __webpack_require__(2);\n\nvar _Snapping2 = _interopRequireDefault(_Snapping);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar Draw = L.Class.extend({\n    includes: [_Snapping2.default],\n    options: {\n        snappable: true,\n        snapDistance: 20,\n        finishOnDoubleClick: false,\n        templineStyle: {\n            color: 'red'\n        },\n        hintlineStyle: {\n            color: 'red',\n            dashArray: [5, 5]\n        },\n        markerStyle: {\n            draggable: true\n        }\n    },\n    initialize: function initialize(map) {\n        var _this = this;\n\n        // save the map\n        this._map = map;\n\n        // define all possible shapes that can be drawn\n        this.shapes = ['Poly', 'Line', 'Marker', 'Circle'];\n\n        // initiate drawing class for our shapes\n        this.shapes.forEach(function (shape) {\n            _this[shape] = new L.PM.Draw[shape](_this._map);\n        });\n    },\n    setPathOptions: function setPathOptions(options) {\n        this.options.pathOptions = options;\n    },\n    getShapes: function getShapes() {\n        // if somebody wants to know what shapes are available\n        return this.shapes;\n    },\n    enable: function enable(shape, options) {\n        if (!shape) {\n            throw new Error('Error: Please pass a shape as a parameter. Possible shapes are: ' + this.getShapes().join(','));\n        }\n\n        // disable drawing for all shapes\n        this.disable();\n\n        // enable draw for a shape\n        this[shape].enable(options);\n    },\n    disable: function disable() {\n        var _this2 = this;\n\n        // there can only be one drawing mode active at a time on a map\n        // so it doesn't matter which one should be disabled.\n        // just disable all of them\n        this.shapes.forEach(function (shape) {\n            _this2[shape].disable();\n        });\n    },\n    addControls: function addControls() {\n        var _this3 = this;\n\n        // add control buttons for our shapes\n        this.shapes.forEach(function (shape) {\n            _this3[shape].addButton();\n        });\n    }\n});\n\nexports.default = Draw;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9EcmF3L0wuUE0uRHJhdy5qcz85Nzk3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuXG52YXIgX1NuYXBwaW5nID0gcmVxdWlyZSgnLi4vTWl4aW5zL1NuYXBwaW5nJyk7XG5cbnZhciBfU25hcHBpbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfU25hcHBpbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG52YXIgRHJhdyA9IEwuQ2xhc3MuZXh0ZW5kKHtcbiAgICBpbmNsdWRlczogW19TbmFwcGluZzIuZGVmYXVsdF0sXG4gICAgb3B0aW9uczoge1xuICAgICAgICBzbmFwcGFibGU6IHRydWUsXG4gICAgICAgIHNuYXBEaXN0YW5jZTogMjAsXG4gICAgICAgIGZpbmlzaE9uRG91YmxlQ2xpY2s6IGZhbHNlLFxuICAgICAgICB0ZW1wbGluZVN0eWxlOiB7XG4gICAgICAgICAgICBjb2xvcjogJ3JlZCdcbiAgICAgICAgfSxcbiAgICAgICAgaGludGxpbmVTdHlsZToge1xuICAgICAgICAgICAgY29sb3I6ICdyZWQnLFxuICAgICAgICAgICAgZGFzaEFycmF5OiBbNSwgNV1cbiAgICAgICAgfSxcbiAgICAgICAgbWFya2VyU3R5bGU6IHtcbiAgICAgICAgICAgIGRyYWdnYWJsZTogdHJ1ZVxuICAgICAgICB9XG4gICAgfSxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBpbml0aWFsaXplKG1hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIC8vIHNhdmUgdGhlIG1hcFxuICAgICAgICB0aGlzLl9tYXAgPSBtYXA7XG5cbiAgICAgICAgLy8gZGVmaW5lIGFsbCBwb3NzaWJsZSBzaGFwZXMgdGhhdCBjYW4gYmUgZHJhd25cbiAgICAgICAgdGhpcy5zaGFwZXMgPSBbJ1BvbHknLCAnTGluZScsICdNYXJrZXInLCAnQ2lyY2xlJ107XG5cbiAgICAgICAgLy8gaW5pdGlhdGUgZHJhd2luZyBjbGFzcyBmb3Igb3VyIHNoYXBlc1xuICAgICAgICB0aGlzLnNoYXBlcy5mb3JFYWNoKGZ1bmN0aW9uIChzaGFwZSkge1xuICAgICAgICAgICAgX3RoaXNbc2hhcGVdID0gbmV3IEwuUE0uRHJhd1tzaGFwZV0oX3RoaXMuX21hcCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgc2V0UGF0aE9wdGlvbnM6IGZ1bmN0aW9uIHNldFBhdGhPcHRpb25zKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnBhdGhPcHRpb25zID0gb3B0aW9ucztcbiAgICB9LFxuICAgIGdldFNoYXBlczogZnVuY3Rpb24gZ2V0U2hhcGVzKCkge1xuICAgICAgICAvLyBpZiBzb21lYm9keSB3YW50cyB0byBrbm93IHdoYXQgc2hhcGVzIGFyZSBhdmFpbGFibGVcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhcGVzO1xuICAgIH0sXG4gICAgZW5hYmxlOiBmdW5jdGlvbiBlbmFibGUoc2hhcGUsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFzaGFwZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFcnJvcjogUGxlYXNlIHBhc3MgYSBzaGFwZSBhcyBhIHBhcmFtZXRlci4gUG9zc2libGUgc2hhcGVzIGFyZTogJyArIHRoaXMuZ2V0U2hhcGVzKCkuam9pbignLCcpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRpc2FibGUgZHJhd2luZyBmb3IgYWxsIHNoYXBlc1xuICAgICAgICB0aGlzLmRpc2FibGUoKTtcblxuICAgICAgICAvLyBlbmFibGUgZHJhdyBmb3IgYSBzaGFwZVxuICAgICAgICB0aGlzW3NoYXBlXS5lbmFibGUob3B0aW9ucyk7XG4gICAgfSxcbiAgICBkaXNhYmxlOiBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAvLyB0aGVyZSBjYW4gb25seSBiZSBvbmUgZHJhd2luZyBtb2RlIGFjdGl2ZSBhdCBhIHRpbWUgb24gYSBtYXBcbiAgICAgICAgLy8gc28gaXQgZG9lc24ndCBtYXR0ZXIgd2hpY2ggb25lIHNob3VsZCBiZSBkaXNhYmxlZC5cbiAgICAgICAgLy8ganVzdCBkaXNhYmxlIGFsbCBvZiB0aGVtXG4gICAgICAgIHRoaXMuc2hhcGVzLmZvckVhY2goZnVuY3Rpb24gKHNoYXBlKSB7XG4gICAgICAgICAgICBfdGhpczJbc2hhcGVdLmRpc2FibGUoKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBhZGRDb250cm9sczogZnVuY3Rpb24gYWRkQ29udHJvbHMoKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIC8vIGFkZCBjb250cm9sIGJ1dHRvbnMgZm9yIG91ciBzaGFwZXNcbiAgICAgICAgdGhpcy5zaGFwZXMuZm9yRWFjaChmdW5jdGlvbiAoc2hhcGUpIHtcbiAgICAgICAgICAgIF90aGlzM1tzaGFwZV0uYWRkQnV0dG9uKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBEcmF3O1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL0RyYXcvTC5QTS5EcmF3LmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar SnapMixin = {\n    _initSnappableMarkers: function _initSnappableMarkers() {\n        var _this = this;\n\n        this.options.snapDistance = this.options.snapDistance || 30;\n\n        this._markers.forEach(function (marker) {\n            marker.off('drag', _this._handleSnapping, _this);\n            marker.on('drag', _this._handleSnapping, _this);\n\n            marker.off('dragend', _this._cleanupSnapping, _this);\n            marker.on('dragend', _this._cleanupSnapping, _this);\n        });\n\n        this._layer.off('pm:dragstart', this._unsnap, this);\n        this._layer.on('pm:dragstart', this._unsnap, this);\n    },\n    _unsnap: function _unsnap() {\n        // delete the last snap\n        delete this._snapLatLng;\n    },\n    _cleanupSnapping: function _cleanupSnapping() {\n        // delete it, we need to refresh this with each start of a drag because\n        // meanwhile, new layers could've been added to the map\n        delete this._snapList;\n\n        if (this.debugIndicatorLines) {\n            this.debugIndicatorLines.forEach(function (line) {\n                line.remove();\n            });\n        }\n    },\n    _handleSnapping: function _handleSnapping(e) {\n        // if snapping is disabled via holding ALT during drag, stop right here\n        if (e.originalEvent.altKey) {\n            return false;\n        }\n\n        // create a list of polygons that the marker could snap to\n        // this isn't inside a movestart/dragstart callback because middlemarkers are initialized\n        // after dragstart/movestart so it wouldn't fire for them\n        if (this._snapList === undefined) {\n            this._createSnapList(e);\n        }\n\n        // if there are no layers to snap to, stop here\n        if (this._snapList.length <= 0) {\n            return false;\n        }\n\n        var marker = e.target;\n\n        // get the closest layer, it's closest latlng, segment and the distance\n        var closestLayer = this._calcClosestLayer(marker.getLatLng(), this._snapList);\n\n        var isMarker = closestLayer.layer instanceof L.Marker || closestLayer.layer instanceof L.CircleMarker;\n\n        // find the final latlng that we want to snap to\n        var snapLatLng = void 0;\n        if (!isMarker) {\n            snapLatLng = this._checkPrioritiySnapping(closestLayer);\n        } else {\n            snapLatLng = closestLayer.latlng;\n        }\n\n        // minimal distance before marker snaps (in pixels)\n        var minDistance = this.options.snapDistance;\n\n        // event info for pm:snap and pm:unsnap\n        var eventInfo = {\n            marker: marker,\n            snapLatLng: snapLatLng,\n            segment: closestLayer.segment,\n            layer: this._layer,\n            layerInteractedWith: closestLayer.layer };\n\n        if (closestLayer.distance < minDistance) {\n            // snap the marker\n            marker.setLatLng(snapLatLng);\n\n            marker._snapped = true;\n\n            // check if the snapping position differs from the last snap\n            if (this._snapLatLng !== snapLatLng) {\n                // if yes, save it and fire the pm:snap event\n                this._snapLatLng = snapLatLng;\n                marker.fire('pm:snap', eventInfo);\n                this._layer.fire('pm:snap', eventInfo);\n            }\n        } else if (this._snapLatLng) {\n            // no more snapping\n\n            // if it was previously snapped...\n            // ...unsnap\n            this._unsnap(eventInfo);\n\n            marker._snapped = false;\n\n            // and fire unsnap event\n            eventInfo.marker.fire('pm:unsnap', eventInfo);\n            this._layer.fire('pm:unsnap', eventInfo);\n        }\n\n        return true;\n    },\n\n\n    // we got the point we want to snap to (C), but we need to check if a coord of the polygon\n    // receives priority over C as the snapping point. Let's check this here\n    _checkPrioritiySnapping: function _checkPrioritiySnapping(closestLayer) {\n        var map = this._map;\n\n        // A and B are the points of the closest segment to P (the marker position we want to snap)\n        var A = closestLayer.segment[0];\n        var B = closestLayer.segment[1];\n\n        // C is the point we would snap to on the segment.\n        // The closest point on the closest segment of the closest polygon to P. That's right.\n        var C = closestLayer.latlng;\n\n        // distances from A to C and B to C to check which one is closer to C\n        var distanceAC = this._getDistance(map, A, C);\n        var distanceBC = this._getDistance(map, B, C);\n\n        // closest latlng of A and B to C\n        var closestVertexLatLng = distanceAC < distanceBC ? A : B;\n\n        // distance between closestVertexLatLng and C\n        var shortestDistance = distanceAC < distanceBC ? distanceAC : distanceBC;\n\n        // the distance that needs to be undercut to trigger priority\n        var priorityDistance = this.options.snapDistance;\n\n        // the latlng we ultemately want to snap to\n        var snapLatlng = void 0;\n\n        // if C is closer to the closestVertexLatLng (A or B) than the snapDistance,\n        // the closestVertexLatLng has priority over C as the snapping point.\n        if (shortestDistance < priorityDistance) {\n            snapLatlng = closestVertexLatLng;\n        } else {\n            snapLatlng = C;\n        }\n\n        // return the copy of snapping point\n        return Object.assign({}, snapLatlng);\n    },\n    _createSnapList: function _createSnapList() {\n        var _this2 = this;\n\n        var layers = [];\n        var debugIndicatorLines = [];\n        var map = this._map;\n\n        // find all layers that are or inherit from Polylines... and markers that are not\n        // temporary markers of polygon-edits\n        map.eachLayer(function (layer) {\n            if (layer instanceof L.Polyline || layer instanceof L.Marker || layer instanceof L.CircleMarker) {\n                layers.push(layer);\n\n                // this is for debugging\n                var debugLine = L.polyline([], { color: 'red' });\n                debugIndicatorLines.push(debugLine);\n\n                // uncomment ðŸ‘‡ this line to show helper lines for debugging\n                // debugLine.addTo(map);\n            }\n        });\n\n        // ...except myself\n        layers = layers.filter(function (layer) {\n            return _this2._layer !== layer;\n        });\n\n        // also remove everything that has no coordinates yet\n        layers = layers.filter(function (layer) {\n            return layer._latlng || layer._latlngs.length > 0;\n        });\n\n        // finally remove everything that's leaflet.pm specific temporary stuff\n        layers = layers.filter(function (layer) {\n            return !layer._pmTempLayer;\n        });\n\n        // save snaplist from layers and the other snap layers added from other classes/scripts\n        if (this._otherSnapLayers) {\n            this._snapList = layers.concat(this._otherSnapLayers);\n        } else {\n            this._snapList = layers;\n        }\n\n        this.debugIndicatorLines = debugIndicatorLines;\n    },\n    _calcClosestLayer: function _calcClosestLayer(latlng, layers) {\n        var _this3 = this;\n\n        // the closest polygon to our dragged marker latlng\n        var closestLayer = {};\n\n        // loop through the layers\n        layers.forEach(function (layer, index) {\n            // find the closest latlng, segment and the distance of this layer to the dragged marker latlng\n            var results = _this3._calcLayerDistances(latlng, layer);\n\n            // show indicator lines, it's for debugging\n            _this3.debugIndicatorLines[index].setLatLngs([latlng, results.latlng]);\n\n            // save the info if it doesn't exist or if the distance is smaller than the previous one\n            if (closestLayer.distance === undefined || results.distance < closestLayer.distance) {\n                closestLayer = results;\n                closestLayer.layer = layer;\n            }\n        });\n\n        // return the closest layer and it's data\n        // if there is no closest layer, return undefined\n        return closestLayer;\n    },\n    _calcLayerDistances: function _calcLayerDistances(latlng, layer) {\n        var _this4 = this;\n\n        var map = this._map;\n\n        // is this a polyline, marker or polygon?\n        var isPolygon = layer instanceof L.Polygon;\n        var isPolyline = !(layer instanceof L.Polygon) && layer instanceof L.Polyline;\n        var isMarker = layer instanceof L.Marker || layer instanceof L.CircleMarker;\n\n        // the point P which we want to snap (probpably the marker that is dragged)\n        var P = latlng;\n\n        var coords = void 0;\n\n        // the coords of the layer\n        if (isPolygon) {\n            // polygon\n            coords = layer.getLatLngs()[0];\n        } else if (isPolyline) {\n            // polyline\n            coords = layer.getLatLngs();\n        } else if (isMarker) {\n            // marker\n            coords = layer.getLatLng();\n\n            // return the info for the marker, no more calculations needed\n            return {\n                latlng: Object.assign({}, coords),\n                distance: this._getDistance(map, coords, P)\n            };\n        }\n\n        // the closest segment (line between two points) of the layer\n        var closestSegment = void 0;\n\n        // the shortest distance from P to closestSegment\n        var shortestDistance = void 0;\n\n        // loop through the coords of the layer\n        coords.forEach(function (coord, index) {\n            // take this coord (A)...\n            var A = coord;\n            var nextIndex = void 0;\n\n            // and the next coord (B) as points\n            if (isPolygon) {\n                nextIndex = index + 1 === coords.length ? 0 : index + 1;\n            } else {\n                nextIndex = index + 1 === coords.length ? undefined : index + 1;\n            }\n\n            var B = coords[nextIndex];\n\n            if (B) {\n                // calc the distance between P and AB-segment\n                var distance = _this4._getDistanceToSegment(map, P, A, B);\n\n                // is the distance shorter than the previous one? Save it and the segment\n                if (shortestDistance === undefined || distance < shortestDistance) {\n                    shortestDistance = distance;\n                    closestSegment = [A, B];\n                }\n            }\n\n            return true;\n        });\n\n        // now, take the closest segment (closestSegment) and calc the closest point to P on it.\n        var C = this._getClosestPointOnSegment(map, latlng, closestSegment[0], closestSegment[1]);\n\n        // return the latlng of that sucker\n        return {\n            latlng: Object.assign({}, C),\n            segment: closestSegment,\n            distance: shortestDistance\n        };\n    },\n    _getClosestPointOnSegment: function _getClosestPointOnSegment(map, latlng, latlngA, latlngB) {\n        var maxzoom = map.getMaxZoom();\n        if (maxzoom === Infinity) {\n            maxzoom = map.getZoom();\n        }\n        var P = map.project(latlng, maxzoom);\n        var A = map.project(latlngA, maxzoom);\n        var B = map.project(latlngB, maxzoom);\n        var closest = L.LineUtil.closestPointOnSegment(P, A, B);\n        return map.unproject(closest, maxzoom);\n    },\n    _getDistanceToSegment: function _getDistanceToSegment(map, latlng, latlngA, latlngB) {\n        var P = map.latLngToLayerPoint(latlng);\n        var A = map.latLngToLayerPoint(latlngA);\n        var B = map.latLngToLayerPoint(latlngB);\n        return L.LineUtil.pointToSegmentDistance(P, A, B);\n    },\n    _getDistance: function _getDistance(map, latlngA, latlngB) {\n        return map.latLngToLayerPoint(latlngA).distanceTo(map.latLngToLayerPoint(latlngB));\n    }\n};\n\nexports.default = SnapMixin;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9NaXhpbnMvU25hcHBpbmcuanM/N2E5YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbnZhciBTbmFwTWl4aW4gPSB7XG4gICAgX2luaXRTbmFwcGFibGVNYXJrZXJzOiBmdW5jdGlvbiBfaW5pdFNuYXBwYWJsZU1hcmtlcnMoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5vcHRpb25zLnNuYXBEaXN0YW5jZSA9IHRoaXMub3B0aW9ucy5zbmFwRGlzdGFuY2UgfHwgMzA7XG5cbiAgICAgICAgdGhpcy5fbWFya2Vycy5mb3JFYWNoKGZ1bmN0aW9uIChtYXJrZXIpIHtcbiAgICAgICAgICAgIG1hcmtlci5vZmYoJ2RyYWcnLCBfdGhpcy5faGFuZGxlU25hcHBpbmcsIF90aGlzKTtcbiAgICAgICAgICAgIG1hcmtlci5vbignZHJhZycsIF90aGlzLl9oYW5kbGVTbmFwcGluZywgX3RoaXMpO1xuXG4gICAgICAgICAgICBtYXJrZXIub2ZmKCdkcmFnZW5kJywgX3RoaXMuX2NsZWFudXBTbmFwcGluZywgX3RoaXMpO1xuICAgICAgICAgICAgbWFya2VyLm9uKCdkcmFnZW5kJywgX3RoaXMuX2NsZWFudXBTbmFwcGluZywgX3RoaXMpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9sYXllci5vZmYoJ3BtOmRyYWdzdGFydCcsIHRoaXMuX3Vuc25hcCwgdGhpcyk7XG4gICAgICAgIHRoaXMuX2xheWVyLm9uKCdwbTpkcmFnc3RhcnQnLCB0aGlzLl91bnNuYXAsIHRoaXMpO1xuICAgIH0sXG4gICAgX3Vuc25hcDogZnVuY3Rpb24gX3Vuc25hcCgpIHtcbiAgICAgICAgLy8gZGVsZXRlIHRoZSBsYXN0IHNuYXBcbiAgICAgICAgZGVsZXRlIHRoaXMuX3NuYXBMYXRMbmc7XG4gICAgfSxcbiAgICBfY2xlYW51cFNuYXBwaW5nOiBmdW5jdGlvbiBfY2xlYW51cFNuYXBwaW5nKCkge1xuICAgICAgICAvLyBkZWxldGUgaXQsIHdlIG5lZWQgdG8gcmVmcmVzaCB0aGlzIHdpdGggZWFjaCBzdGFydCBvZiBhIGRyYWcgYmVjYXVzZVxuICAgICAgICAvLyBtZWFud2hpbGUsIG5ldyBsYXllcnMgY291bGQndmUgYmVlbiBhZGRlZCB0byB0aGUgbWFwXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zbmFwTGlzdDtcblxuICAgICAgICBpZiAodGhpcy5kZWJ1Z0luZGljYXRvckxpbmVzKSB7XG4gICAgICAgICAgICB0aGlzLmRlYnVnSW5kaWNhdG9yTGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xuICAgICAgICAgICAgICAgIGxpbmUucmVtb3ZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX2hhbmRsZVNuYXBwaW5nOiBmdW5jdGlvbiBfaGFuZGxlU25hcHBpbmcoZSkge1xuICAgICAgICAvLyBpZiBzbmFwcGluZyBpcyBkaXNhYmxlZCB2aWEgaG9sZGluZyBBTFQgZHVyaW5nIGRyYWcsIHN0b3AgcmlnaHQgaGVyZVxuICAgICAgICBpZiAoZS5vcmlnaW5hbEV2ZW50LmFsdEtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY3JlYXRlIGEgbGlzdCBvZiBwb2x5Z29ucyB0aGF0IHRoZSBtYXJrZXIgY291bGQgc25hcCB0b1xuICAgICAgICAvLyB0aGlzIGlzbid0IGluc2lkZSBhIG1vdmVzdGFydC9kcmFnc3RhcnQgY2FsbGJhY2sgYmVjYXVzZSBtaWRkbGVtYXJrZXJzIGFyZSBpbml0aWFsaXplZFxuICAgICAgICAvLyBhZnRlciBkcmFnc3RhcnQvbW92ZXN0YXJ0IHNvIGl0IHdvdWxkbid0IGZpcmUgZm9yIHRoZW1cbiAgICAgICAgaWYgKHRoaXMuX3NuYXBMaXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVNuYXBMaXN0KGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIGxheWVycyB0byBzbmFwIHRvLCBzdG9wIGhlcmVcbiAgICAgICAgaWYgKHRoaXMuX3NuYXBMaXN0Lmxlbmd0aCA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbWFya2VyID0gZS50YXJnZXQ7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBjbG9zZXN0IGxheWVyLCBpdCdzIGNsb3Nlc3QgbGF0bG5nLCBzZWdtZW50IGFuZCB0aGUgZGlzdGFuY2VcbiAgICAgICAgdmFyIGNsb3Nlc3RMYXllciA9IHRoaXMuX2NhbGNDbG9zZXN0TGF5ZXIobWFya2VyLmdldExhdExuZygpLCB0aGlzLl9zbmFwTGlzdCk7XG5cbiAgICAgICAgdmFyIGlzTWFya2VyID0gY2xvc2VzdExheWVyLmxheWVyIGluc3RhbmNlb2YgTC5NYXJrZXIgfHwgY2xvc2VzdExheWVyLmxheWVyIGluc3RhbmNlb2YgTC5DaXJjbGVNYXJrZXI7XG5cbiAgICAgICAgLy8gZmluZCB0aGUgZmluYWwgbGF0bG5nIHRoYXQgd2Ugd2FudCB0byBzbmFwIHRvXG4gICAgICAgIHZhciBzbmFwTGF0TG5nID0gdm9pZCAwO1xuICAgICAgICBpZiAoIWlzTWFya2VyKSB7XG4gICAgICAgICAgICBzbmFwTGF0TG5nID0gdGhpcy5fY2hlY2tQcmlvcml0aXlTbmFwcGluZyhjbG9zZXN0TGF5ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc25hcExhdExuZyA9IGNsb3Nlc3RMYXllci5sYXRsbmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtaW5pbWFsIGRpc3RhbmNlIGJlZm9yZSBtYXJrZXIgc25hcHMgKGluIHBpeGVscylcbiAgICAgICAgdmFyIG1pbkRpc3RhbmNlID0gdGhpcy5vcHRpb25zLnNuYXBEaXN0YW5jZTtcblxuICAgICAgICAvLyBldmVudCBpbmZvIGZvciBwbTpzbmFwIGFuZCBwbTp1bnNuYXBcbiAgICAgICAgdmFyIGV2ZW50SW5mbyA9IHtcbiAgICAgICAgICAgIG1hcmtlcjogbWFya2VyLFxuICAgICAgICAgICAgc25hcExhdExuZzogc25hcExhdExuZyxcbiAgICAgICAgICAgIHNlZ21lbnQ6IGNsb3Nlc3RMYXllci5zZWdtZW50LFxuICAgICAgICAgICAgbGF5ZXI6IHRoaXMuX2xheWVyLFxuICAgICAgICAgICAgbGF5ZXJJbnRlcmFjdGVkV2l0aDogY2xvc2VzdExheWVyLmxheWVyIH07XG5cbiAgICAgICAgaWYgKGNsb3Nlc3RMYXllci5kaXN0YW5jZSA8IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgICAvLyBzbmFwIHRoZSBtYXJrZXJcbiAgICAgICAgICAgIG1hcmtlci5zZXRMYXRMbmcoc25hcExhdExuZyk7XG5cbiAgICAgICAgICAgIG1hcmtlci5fc25hcHBlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHRoZSBzbmFwcGluZyBwb3NpdGlvbiBkaWZmZXJzIGZyb20gdGhlIGxhc3Qgc25hcFxuICAgICAgICAgICAgaWYgKHRoaXMuX3NuYXBMYXRMbmcgIT09IHNuYXBMYXRMbmcpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB5ZXMsIHNhdmUgaXQgYW5kIGZpcmUgdGhlIHBtOnNuYXAgZXZlbnRcbiAgICAgICAgICAgICAgICB0aGlzLl9zbmFwTGF0TG5nID0gc25hcExhdExuZztcbiAgICAgICAgICAgICAgICBtYXJrZXIuZmlyZSgncG06c25hcCcsIGV2ZW50SW5mbyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXIuZmlyZSgncG06c25hcCcsIGV2ZW50SW5mbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fc25hcExhdExuZykge1xuICAgICAgICAgICAgLy8gbm8gbW9yZSBzbmFwcGluZ1xuXG4gICAgICAgICAgICAvLyBpZiBpdCB3YXMgcHJldmlvdXNseSBzbmFwcGVkLi4uXG4gICAgICAgICAgICAvLyAuLi51bnNuYXBcbiAgICAgICAgICAgIHRoaXMuX3Vuc25hcChldmVudEluZm8pO1xuXG4gICAgICAgICAgICBtYXJrZXIuX3NuYXBwZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgLy8gYW5kIGZpcmUgdW5zbmFwIGV2ZW50XG4gICAgICAgICAgICBldmVudEluZm8ubWFya2VyLmZpcmUoJ3BtOnVuc25hcCcsIGV2ZW50SW5mbyk7XG4gICAgICAgICAgICB0aGlzLl9sYXllci5maXJlKCdwbTp1bnNuYXAnLCBldmVudEluZm8pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuXG4gICAgLy8gd2UgZ290IHRoZSBwb2ludCB3ZSB3YW50IHRvIHNuYXAgdG8gKEMpLCBidXQgd2UgbmVlZCB0byBjaGVjayBpZiBhIGNvb3JkIG9mIHRoZSBwb2x5Z29uXG4gICAgLy8gcmVjZWl2ZXMgcHJpb3JpdHkgb3ZlciBDIGFzIHRoZSBzbmFwcGluZyBwb2ludC4gTGV0J3MgY2hlY2sgdGhpcyBoZXJlXG4gICAgX2NoZWNrUHJpb3JpdGl5U25hcHBpbmc6IGZ1bmN0aW9uIF9jaGVja1ByaW9yaXRpeVNuYXBwaW5nKGNsb3Nlc3RMYXllcikge1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG4gICAgICAgIC8vIEEgYW5kIEIgYXJlIHRoZSBwb2ludHMgb2YgdGhlIGNsb3Nlc3Qgc2VnbWVudCB0byBQICh0aGUgbWFya2VyIHBvc2l0aW9uIHdlIHdhbnQgdG8gc25hcClcbiAgICAgICAgdmFyIEEgPSBjbG9zZXN0TGF5ZXIuc2VnbWVudFswXTtcbiAgICAgICAgdmFyIEIgPSBjbG9zZXN0TGF5ZXIuc2VnbWVudFsxXTtcblxuICAgICAgICAvLyBDIGlzIHRoZSBwb2ludCB3ZSB3b3VsZCBzbmFwIHRvIG9uIHRoZSBzZWdtZW50LlxuICAgICAgICAvLyBUaGUgY2xvc2VzdCBwb2ludCBvbiB0aGUgY2xvc2VzdCBzZWdtZW50IG9mIHRoZSBjbG9zZXN0IHBvbHlnb24gdG8gUC4gVGhhdCdzIHJpZ2h0LlxuICAgICAgICB2YXIgQyA9IGNsb3Nlc3RMYXllci5sYXRsbmc7XG5cbiAgICAgICAgLy8gZGlzdGFuY2VzIGZyb20gQSB0byBDIGFuZCBCIHRvIEMgdG8gY2hlY2sgd2hpY2ggb25lIGlzIGNsb3NlciB0byBDXG4gICAgICAgIHZhciBkaXN0YW5jZUFDID0gdGhpcy5fZ2V0RGlzdGFuY2UobWFwLCBBLCBDKTtcbiAgICAgICAgdmFyIGRpc3RhbmNlQkMgPSB0aGlzLl9nZXREaXN0YW5jZShtYXAsIEIsIEMpO1xuXG4gICAgICAgIC8vIGNsb3Nlc3QgbGF0bG5nIG9mIEEgYW5kIEIgdG8gQ1xuICAgICAgICB2YXIgY2xvc2VzdFZlcnRleExhdExuZyA9IGRpc3RhbmNlQUMgPCBkaXN0YW5jZUJDID8gQSA6IEI7XG5cbiAgICAgICAgLy8gZGlzdGFuY2UgYmV0d2VlbiBjbG9zZXN0VmVydGV4TGF0TG5nIGFuZCBDXG4gICAgICAgIHZhciBzaG9ydGVzdERpc3RhbmNlID0gZGlzdGFuY2VBQyA8IGRpc3RhbmNlQkMgPyBkaXN0YW5jZUFDIDogZGlzdGFuY2VCQztcblxuICAgICAgICAvLyB0aGUgZGlzdGFuY2UgdGhhdCBuZWVkcyB0byBiZSB1bmRlcmN1dCB0byB0cmlnZ2VyIHByaW9yaXR5XG4gICAgICAgIHZhciBwcmlvcml0eURpc3RhbmNlID0gdGhpcy5vcHRpb25zLnNuYXBEaXN0YW5jZTtcblxuICAgICAgICAvLyB0aGUgbGF0bG5nIHdlIHVsdGVtYXRlbHkgd2FudCB0byBzbmFwIHRvXG4gICAgICAgIHZhciBzbmFwTGF0bG5nID0gdm9pZCAwO1xuXG4gICAgICAgIC8vIGlmIEMgaXMgY2xvc2VyIHRvIHRoZSBjbG9zZXN0VmVydGV4TGF0TG5nIChBIG9yIEIpIHRoYW4gdGhlIHNuYXBEaXN0YW5jZSxcbiAgICAgICAgLy8gdGhlIGNsb3Nlc3RWZXJ0ZXhMYXRMbmcgaGFzIHByaW9yaXR5IG92ZXIgQyBhcyB0aGUgc25hcHBpbmcgcG9pbnQuXG4gICAgICAgIGlmIChzaG9ydGVzdERpc3RhbmNlIDwgcHJpb3JpdHlEaXN0YW5jZSkge1xuICAgICAgICAgICAgc25hcExhdGxuZyA9IGNsb3Nlc3RWZXJ0ZXhMYXRMbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzbmFwTGF0bG5nID0gQztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJldHVybiB0aGUgY29weSBvZiBzbmFwcGluZyBwb2ludFxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgc25hcExhdGxuZyk7XG4gICAgfSxcbiAgICBfY3JlYXRlU25hcExpc3Q6IGZ1bmN0aW9uIF9jcmVhdGVTbmFwTGlzdCgpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGxheWVycyA9IFtdO1xuICAgICAgICB2YXIgZGVidWdJbmRpY2F0b3JMaW5lcyA9IFtdO1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG4gICAgICAgIC8vIGZpbmQgYWxsIGxheWVycyB0aGF0IGFyZSBvciBpbmhlcml0IGZyb20gUG9seWxpbmVzLi4uIGFuZCBtYXJrZXJzIHRoYXQgYXJlIG5vdFxuICAgICAgICAvLyB0ZW1wb3JhcnkgbWFya2VycyBvZiBwb2x5Z29uLWVkaXRzXG4gICAgICAgIG1hcC5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICBpZiAobGF5ZXIgaW5zdGFuY2VvZiBMLlBvbHlsaW5lIHx8IGxheWVyIGluc3RhbmNlb2YgTC5NYXJrZXIgfHwgbGF5ZXIgaW5zdGFuY2VvZiBMLkNpcmNsZU1hcmtlcikge1xuICAgICAgICAgICAgICAgIGxheWVycy5wdXNoKGxheWVyKTtcblxuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgZm9yIGRlYnVnZ2luZ1xuICAgICAgICAgICAgICAgIHZhciBkZWJ1Z0xpbmUgPSBMLnBvbHlsaW5lKFtdLCB7IGNvbG9yOiAncmVkJyB9KTtcbiAgICAgICAgICAgICAgICBkZWJ1Z0luZGljYXRvckxpbmVzLnB1c2goZGVidWdMaW5lKTtcblxuICAgICAgICAgICAgICAgIC8vIHVuY29tbWVudCDwn5GHIHRoaXMgbGluZSB0byBzaG93IGhlbHBlciBsaW5lcyBmb3IgZGVidWdnaW5nXG4gICAgICAgICAgICAgICAgLy8gZGVidWdMaW5lLmFkZFRvKG1hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIC4uLmV4Y2VwdCBteXNlbGZcbiAgICAgICAgbGF5ZXJzID0gbGF5ZXJzLmZpbHRlcihmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczIuX2xheWVyICE9PSBsYXllcjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gYWxzbyByZW1vdmUgZXZlcnl0aGluZyB0aGF0IGhhcyBubyBjb29yZGluYXRlcyB5ZXRcbiAgICAgICAgbGF5ZXJzID0gbGF5ZXJzLmZpbHRlcihmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXllci5fbGF0bG5nIHx8IGxheWVyLl9sYXRsbmdzLmxlbmd0aCA+IDA7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGZpbmFsbHkgcmVtb3ZlIGV2ZXJ5dGhpbmcgdGhhdCdzIGxlYWZsZXQucG0gc3BlY2lmaWMgdGVtcG9yYXJ5IHN0dWZmXG4gICAgICAgIGxheWVycyA9IGxheWVycy5maWx0ZXIoZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gIWxheWVyLl9wbVRlbXBMYXllcjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gc2F2ZSBzbmFwbGlzdCBmcm9tIGxheWVycyBhbmQgdGhlIG90aGVyIHNuYXAgbGF5ZXJzIGFkZGVkIGZyb20gb3RoZXIgY2xhc3Nlcy9zY3JpcHRzXG4gICAgICAgIGlmICh0aGlzLl9vdGhlclNuYXBMYXllcnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3NuYXBMaXN0ID0gbGF5ZXJzLmNvbmNhdCh0aGlzLl9vdGhlclNuYXBMYXllcnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc25hcExpc3QgPSBsYXllcnM7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRlYnVnSW5kaWNhdG9yTGluZXMgPSBkZWJ1Z0luZGljYXRvckxpbmVzO1xuICAgIH0sXG4gICAgX2NhbGNDbG9zZXN0TGF5ZXI6IGZ1bmN0aW9uIF9jYWxjQ2xvc2VzdExheWVyKGxhdGxuZywgbGF5ZXJzKSB7XG4gICAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICAgIC8vIHRoZSBjbG9zZXN0IHBvbHlnb24gdG8gb3VyIGRyYWdnZWQgbWFya2VyIGxhdGxuZ1xuICAgICAgICB2YXIgY2xvc2VzdExheWVyID0ge307XG5cbiAgICAgICAgLy8gbG9vcCB0aHJvdWdoIHRoZSBsYXllcnNcbiAgICAgICAgbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKGxheWVyLCBpbmRleCkge1xuICAgICAgICAgICAgLy8gZmluZCB0aGUgY2xvc2VzdCBsYXRsbmcsIHNlZ21lbnQgYW5kIHRoZSBkaXN0YW5jZSBvZiB0aGlzIGxheWVyIHRvIHRoZSBkcmFnZ2VkIG1hcmtlciBsYXRsbmdcbiAgICAgICAgICAgIHZhciByZXN1bHRzID0gX3RoaXMzLl9jYWxjTGF5ZXJEaXN0YW5jZXMobGF0bG5nLCBsYXllcik7XG5cbiAgICAgICAgICAgIC8vIHNob3cgaW5kaWNhdG9yIGxpbmVzLCBpdCdzIGZvciBkZWJ1Z2dpbmdcbiAgICAgICAgICAgIF90aGlzMy5kZWJ1Z0luZGljYXRvckxpbmVzW2luZGV4XS5zZXRMYXRMbmdzKFtsYXRsbmcsIHJlc3VsdHMubGF0bG5nXSk7XG5cbiAgICAgICAgICAgIC8vIHNhdmUgdGhlIGluZm8gaWYgaXQgZG9lc24ndCBleGlzdCBvciBpZiB0aGUgZGlzdGFuY2UgaXMgc21hbGxlciB0aGFuIHRoZSBwcmV2aW91cyBvbmVcbiAgICAgICAgICAgIGlmIChjbG9zZXN0TGF5ZXIuZGlzdGFuY2UgPT09IHVuZGVmaW5lZCB8fCByZXN1bHRzLmRpc3RhbmNlIDwgY2xvc2VzdExheWVyLmRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgY2xvc2VzdExheWVyID0gcmVzdWx0cztcbiAgICAgICAgICAgICAgICBjbG9zZXN0TGF5ZXIubGF5ZXIgPSBsYXllcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gcmV0dXJuIHRoZSBjbG9zZXN0IGxheWVyIGFuZCBpdCdzIGRhdGFcbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gY2xvc2VzdCBsYXllciwgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICByZXR1cm4gY2xvc2VzdExheWVyO1xuICAgIH0sXG4gICAgX2NhbGNMYXllckRpc3RhbmNlczogZnVuY3Rpb24gX2NhbGNMYXllckRpc3RhbmNlcyhsYXRsbmcsIGxheWVyKSB7XG4gICAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgICAgICAgLy8gaXMgdGhpcyBhIHBvbHlsaW5lLCBtYXJrZXIgb3IgcG9seWdvbj9cbiAgICAgICAgdmFyIGlzUG9seWdvbiA9IGxheWVyIGluc3RhbmNlb2YgTC5Qb2x5Z29uO1xuICAgICAgICB2YXIgaXNQb2x5bGluZSA9ICEobGF5ZXIgaW5zdGFuY2VvZiBMLlBvbHlnb24pICYmIGxheWVyIGluc3RhbmNlb2YgTC5Qb2x5bGluZTtcbiAgICAgICAgdmFyIGlzTWFya2VyID0gbGF5ZXIgaW5zdGFuY2VvZiBMLk1hcmtlciB8fCBsYXllciBpbnN0YW5jZW9mIEwuQ2lyY2xlTWFya2VyO1xuXG4gICAgICAgIC8vIHRoZSBwb2ludCBQIHdoaWNoIHdlIHdhbnQgdG8gc25hcCAocHJvYnBhYmx5IHRoZSBtYXJrZXIgdGhhdCBpcyBkcmFnZ2VkKVxuICAgICAgICB2YXIgUCA9IGxhdGxuZztcblxuICAgICAgICB2YXIgY29vcmRzID0gdm9pZCAwO1xuXG4gICAgICAgIC8vIHRoZSBjb29yZHMgb2YgdGhlIGxheWVyXG4gICAgICAgIGlmIChpc1BvbHlnb24pIHtcbiAgICAgICAgICAgIC8vIHBvbHlnb25cbiAgICAgICAgICAgIGNvb3JkcyA9IGxheWVyLmdldExhdExuZ3MoKVswXTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1BvbHlsaW5lKSB7XG4gICAgICAgICAgICAvLyBwb2x5bGluZVxuICAgICAgICAgICAgY29vcmRzID0gbGF5ZXIuZ2V0TGF0TG5ncygpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzTWFya2VyKSB7XG4gICAgICAgICAgICAvLyBtYXJrZXJcbiAgICAgICAgICAgIGNvb3JkcyA9IGxheWVyLmdldExhdExuZygpO1xuXG4gICAgICAgICAgICAvLyByZXR1cm4gdGhlIGluZm8gZm9yIHRoZSBtYXJrZXIsIG5vIG1vcmUgY2FsY3VsYXRpb25zIG5lZWRlZFxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsYXRsbmc6IE9iamVjdC5hc3NpZ24oe30sIGNvb3JkcyksXG4gICAgICAgICAgICAgICAgZGlzdGFuY2U6IHRoaXMuX2dldERpc3RhbmNlKG1hcCwgY29vcmRzLCBQKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZSBjbG9zZXN0IHNlZ21lbnQgKGxpbmUgYmV0d2VlbiB0d28gcG9pbnRzKSBvZiB0aGUgbGF5ZXJcbiAgICAgICAgdmFyIGNsb3Nlc3RTZWdtZW50ID0gdm9pZCAwO1xuXG4gICAgICAgIC8vIHRoZSBzaG9ydGVzdCBkaXN0YW5jZSBmcm9tIFAgdG8gY2xvc2VzdFNlZ21lbnRcbiAgICAgICAgdmFyIHNob3J0ZXN0RGlzdGFuY2UgPSB2b2lkIDA7XG5cbiAgICAgICAgLy8gbG9vcCB0aHJvdWdoIHRoZSBjb29yZHMgb2YgdGhlIGxheWVyXG4gICAgICAgIGNvb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uIChjb29yZCwgaW5kZXgpIHtcbiAgICAgICAgICAgIC8vIHRha2UgdGhpcyBjb29yZCAoQSkuLi5cbiAgICAgICAgICAgIHZhciBBID0gY29vcmQ7XG4gICAgICAgICAgICB2YXIgbmV4dEluZGV4ID0gdm9pZCAwO1xuXG4gICAgICAgICAgICAvLyBhbmQgdGhlIG5leHQgY29vcmQgKEIpIGFzIHBvaW50c1xuICAgICAgICAgICAgaWYgKGlzUG9seWdvbikge1xuICAgICAgICAgICAgICAgIG5leHRJbmRleCA9IGluZGV4ICsgMSA9PT0gY29vcmRzLmxlbmd0aCA/IDAgOiBpbmRleCArIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5leHRJbmRleCA9IGluZGV4ICsgMSA9PT0gY29vcmRzLmxlbmd0aCA/IHVuZGVmaW5lZCA6IGluZGV4ICsgMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIEIgPSBjb29yZHNbbmV4dEluZGV4XTtcblxuICAgICAgICAgICAgaWYgKEIpIHtcbiAgICAgICAgICAgICAgICAvLyBjYWxjIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIFAgYW5kIEFCLXNlZ21lbnRcbiAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBfdGhpczQuX2dldERpc3RhbmNlVG9TZWdtZW50KG1hcCwgUCwgQSwgQik7XG5cbiAgICAgICAgICAgICAgICAvLyBpcyB0aGUgZGlzdGFuY2Ugc2hvcnRlciB0aGFuIHRoZSBwcmV2aW91cyBvbmU/IFNhdmUgaXQgYW5kIHRoZSBzZWdtZW50XG4gICAgICAgICAgICAgICAgaWYgKHNob3J0ZXN0RGlzdGFuY2UgPT09IHVuZGVmaW5lZCB8fCBkaXN0YW5jZSA8IHNob3J0ZXN0RGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvcnRlc3REaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgICAgICAgICBjbG9zZXN0U2VnbWVudCA9IFtBLCBCXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBub3csIHRha2UgdGhlIGNsb3Nlc3Qgc2VnbWVudCAoY2xvc2VzdFNlZ21lbnQpIGFuZCBjYWxjIHRoZSBjbG9zZXN0IHBvaW50IHRvIFAgb24gaXQuXG4gICAgICAgIHZhciBDID0gdGhpcy5fZ2V0Q2xvc2VzdFBvaW50T25TZWdtZW50KG1hcCwgbGF0bG5nLCBjbG9zZXN0U2VnbWVudFswXSwgY2xvc2VzdFNlZ21lbnRbMV0pO1xuXG4gICAgICAgIC8vIHJldHVybiB0aGUgbGF0bG5nIG9mIHRoYXQgc3Vja2VyXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsYXRsbmc6IE9iamVjdC5hc3NpZ24oe30sIEMpLFxuICAgICAgICAgICAgc2VnbWVudDogY2xvc2VzdFNlZ21lbnQsXG4gICAgICAgICAgICBkaXN0YW5jZTogc2hvcnRlc3REaXN0YW5jZVxuICAgICAgICB9O1xuICAgIH0sXG4gICAgX2dldENsb3Nlc3RQb2ludE9uU2VnbWVudDogZnVuY3Rpb24gX2dldENsb3Nlc3RQb2ludE9uU2VnbWVudChtYXAsIGxhdGxuZywgbGF0bG5nQSwgbGF0bG5nQikge1xuICAgICAgICB2YXIgbWF4em9vbSA9IG1hcC5nZXRNYXhab29tKCk7XG4gICAgICAgIGlmIChtYXh6b29tID09PSBJbmZpbml0eSkge1xuICAgICAgICAgICAgbWF4em9vbSA9IG1hcC5nZXRab29tKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIFAgPSBtYXAucHJvamVjdChsYXRsbmcsIG1heHpvb20pO1xuICAgICAgICB2YXIgQSA9IG1hcC5wcm9qZWN0KGxhdGxuZ0EsIG1heHpvb20pO1xuICAgICAgICB2YXIgQiA9IG1hcC5wcm9qZWN0KGxhdGxuZ0IsIG1heHpvb20pO1xuICAgICAgICB2YXIgY2xvc2VzdCA9IEwuTGluZVV0aWwuY2xvc2VzdFBvaW50T25TZWdtZW50KFAsIEEsIEIpO1xuICAgICAgICByZXR1cm4gbWFwLnVucHJvamVjdChjbG9zZXN0LCBtYXh6b29tKTtcbiAgICB9LFxuICAgIF9nZXREaXN0YW5jZVRvU2VnbWVudDogZnVuY3Rpb24gX2dldERpc3RhbmNlVG9TZWdtZW50KG1hcCwgbGF0bG5nLCBsYXRsbmdBLCBsYXRsbmdCKSB7XG4gICAgICAgIHZhciBQID0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmcpO1xuICAgICAgICB2YXIgQSA9IG1hcC5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nQSk7XG4gICAgICAgIHZhciBCID0gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmdCKTtcbiAgICAgICAgcmV0dXJuIEwuTGluZVV0aWwucG9pbnRUb1NlZ21lbnREaXN0YW5jZShQLCBBLCBCKTtcbiAgICB9LFxuICAgIF9nZXREaXN0YW5jZTogZnVuY3Rpb24gX2dldERpc3RhbmNlKG1hcCwgbGF0bG5nQSwgbGF0bG5nQikge1xuICAgICAgICByZXR1cm4gbWFwLmxhdExuZ1RvTGF5ZXJQb2ludChsYXRsbmdBKS5kaXN0YW5jZVRvKG1hcC5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nQikpO1xuICAgIH1cbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFNuYXBNaXhpbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9NaXhpbnMvU25hcHBpbmcuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _LPM = __webpack_require__(1);\n\nvar _LPM2 = _interopRequireDefault(_LPM);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_LPM2.default.Circle = _LPM2.default.extend({\n    initialize: function initialize(map) {\n        this._map = map;\n        this._shape = 'Circle';\n        this.toolbarButtonName = 'drawCircle';\n    },\n    enable: function enable(options) {\n        // TODO: Think about if these options could be passed globally for all\n        // instances of L.PM.Draw. So a dev could set drawing style one time as some kind of config\n        L.Util.setOptions(this, options);\n\n        this.options.radius = 0;\n\n        // enable draw mode\n        this._enabled = true;\n\n        // create a new layergroup\n        this._layerGroup = new L.LayerGroup();\n        this._layerGroup.addTo(this._map);\n\n        // this is the circle we want to draw\n        this._layer = L.circle([0, 0], this.options.templineStyle);\n        this._layer._pmTempLayer = true;\n        this._layerGroup.addLayer(this._layer);\n\n        // this is the marker in the center of the circle\n        this._centerMarker = L.marker([0, 0], {\n            icon: L.divIcon({ className: 'marker-icon' }),\n            draggable: true,\n            zIndexOffset: 100\n        });\n        this._centerMarker._pmTempLayer = true;\n        this._layerGroup.addLayer(this._centerMarker);\n\n        // this is the hintmarker on the mouse cursor\n        this._hintMarker = L.marker([0, 0], {\n            icon: L.divIcon({ className: 'marker-icon cursor-marker' })\n        });\n        this._hintMarker._pmTempLayer = true;\n        this._layerGroup.addLayer(this._hintMarker);\n\n        // show the hintmarker if the option is set\n        if (this.options.cursorMarker) {\n            L.DomUtil.addClass(this._hintMarker._icon, 'visible');\n        }\n\n        // this is the hintline from the hint marker to the center marker\n        this._hintline = L.polyline([], this.options.hintlineStyle);\n        this._hintline._pmTempLayer = true;\n        this._layerGroup.addLayer(this._hintline);\n\n        // change map cursor\n        this._map._container.style.cursor = 'crosshair';\n\n        // create a polygon-point on click\n        this._map.on('click', this._placeCenterMarker, this);\n\n        // sync hint marker with mouse cursor\n        this._map.on('mousemove', this._syncHintMarker, this);\n\n        // fire drawstart event\n        this._map.fire('pm:drawstart', { shape: this._shape });\n\n        // toggle the draw button of the Toolbar in case drawing mode got enabled without the button\n        this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, true);\n\n        // an array used in the snapping mixin.\n        // TODO: think about moving this somewhere else?\n        this._otherSnapLayers = [];\n    },\n    disable: function disable() {\n        // disable drawing mode\n\n        // cancel, if drawing mode isn't event enabled\n        if (!this._enabled) {\n            return;\n        }\n\n        this._enabled = false;\n\n        // reset cursor\n        this._map._container.style.cursor = 'default';\n\n        // unbind listeners\n        this._map.off('click', this._finishShape, this);\n        this._map.off('click', this._placeCenterMarker, this);\n        this._map.off('mousemove', this._syncHintMarker, this);\n\n        // remove helping layers\n        this._map.removeLayer(this._layerGroup);\n\n        // fire drawend event\n        this._map.fire('pm:drawend', { shape: this._shape });\n\n        // toggle the draw button of the Toolbar in case drawing mode got disabled without the button\n        this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, false);\n\n        // cleanup snapping\n        if (this.options.snappable) {\n            this._cleanupSnapping();\n        }\n    },\n    enabled: function enabled() {\n        return this._enabled;\n    },\n    toggle: function toggle(options) {\n        if (this.enabled()) {\n            this.disable();\n        } else {\n            this.enable(options);\n        }\n    },\n    _syncHintLine: function _syncHintLine() {\n        var latlng = this._centerMarker.getLatLng();\n\n        // set coords for hintline from marker to last vertex of drawin polyline\n        this._hintline.setLatLngs([latlng, this._hintMarker.getLatLng()]);\n    },\n    _syncCircleRadius: function _syncCircleRadius() {\n        var A = this._centerMarker.getLatLng();\n        var B = this._hintMarker.getLatLng();\n\n        var distance = A.distanceTo(B);\n\n        this._layer.setRadius(distance);\n    },\n    _syncHintMarker: function _syncHintMarker(e) {\n        // move the cursor marker\n        this._hintMarker.setLatLng(e.latlng);\n\n        // if snapping is enabled, do it\n        if (this.options.snappable) {\n            var fakeDragEvent = e;\n            fakeDragEvent.target = this._hintMarker;\n            this._handleSnapping(fakeDragEvent);\n        }\n    },\n    _placeCenterMarker: function _placeCenterMarker(e) {\n        // assign the coordinate of the click to the hintMarker, that's necessary for\n        // mobile where the marker can't follow a cursor\n        if (!this._hintMarker._snapped) {\n            this._hintMarker.setLatLng(e.latlng);\n        }\n\n        // get coordinate for new vertex by hintMarker (cursor marker)\n        var latlng = this._hintMarker.getLatLng();\n\n        this._centerMarker.setLatLng(latlng);\n\n        this._map.off('click', this._placeCenterMarker, this);\n        this._map.on('click', this._finishShape, this);\n\n        this._placeCircleCenter();\n    },\n    _placeCircleCenter: function _placeCircleCenter() {\n        var latlng = this._centerMarker.getLatLng();\n\n        if (latlng) {\n            this._layer.setLatLng(latlng);\n\n            // sync the hintline with hint marker\n            this._hintMarker.on('move', this._syncHintLine, this);\n            this._hintMarker.on('move', this._syncCircleRadius, this);\n        }\n    },\n    _finishShape: function _finishShape() {\n        // calc the radius\n        var center = this._centerMarker.getLatLng();\n        var cursor = this._hintMarker.getLatLng();\n        var radius = center.distanceTo(cursor);\n\n        // create the final circle layer\n        var circleLayer = L.circle(center, { radius: radius }).addTo(this._map);\n\n        // disable drawing\n        this.disable();\n\n        // fire the pm:create event and pass shape and layer\n        this._map.fire('pm:create', {\n            shape: this._shape,\n            layer: circleLayer\n        });\n    },\n    _createMarker: function _createMarker(latlng) {\n        // create the new marker\n        var marker = new L.Marker(latlng, {\n            draggable: false,\n            icon: L.divIcon({ className: 'marker-icon' })\n        });\n        marker._pmTempLayer = true;\n\n        // add it to the map\n        this._layerGroup.addLayer(marker);\n\n        return marker;\n    }\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9EcmF3L0wuUE0uRHJhdy5DaXJjbGUuanM/MTE2OCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfTFBNID0gcmVxdWlyZSgnLi9MLlBNLkRyYXcnKTtcblxudmFyIF9MUE0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTFBNKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuX0xQTTIuZGVmYXVsdC5DaXJjbGUgPSBfTFBNMi5kZWZhdWx0LmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZShtYXApIHtcbiAgICAgICAgdGhpcy5fbWFwID0gbWFwO1xuICAgICAgICB0aGlzLl9zaGFwZSA9ICdDaXJjbGUnO1xuICAgICAgICB0aGlzLnRvb2xiYXJCdXR0b25OYW1lID0gJ2RyYXdDaXJjbGUnO1xuICAgIH0sXG4gICAgZW5hYmxlOiBmdW5jdGlvbiBlbmFibGUob3B0aW9ucykge1xuICAgICAgICAvLyBUT0RPOiBUaGluayBhYm91dCBpZiB0aGVzZSBvcHRpb25zIGNvdWxkIGJlIHBhc3NlZCBnbG9iYWxseSBmb3IgYWxsXG4gICAgICAgIC8vIGluc3RhbmNlcyBvZiBMLlBNLkRyYXcuIFNvIGEgZGV2IGNvdWxkIHNldCBkcmF3aW5nIHN0eWxlIG9uZSB0aW1lIGFzIHNvbWUga2luZCBvZiBjb25maWdcbiAgICAgICAgTC5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5vcHRpb25zLnJhZGl1cyA9IDA7XG5cbiAgICAgICAgLy8gZW5hYmxlIGRyYXcgbW9kZVxuICAgICAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICAvLyBjcmVhdGUgYSBuZXcgbGF5ZXJncm91cFxuICAgICAgICB0aGlzLl9sYXllckdyb3VwID0gbmV3IEwuTGF5ZXJHcm91cCgpO1xuICAgICAgICB0aGlzLl9sYXllckdyb3VwLmFkZFRvKHRoaXMuX21hcCk7XG5cbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgY2lyY2xlIHdlIHdhbnQgdG8gZHJhd1xuICAgICAgICB0aGlzLl9sYXllciA9IEwuY2lyY2xlKFswLCAwXSwgdGhpcy5vcHRpb25zLnRlbXBsaW5lU3R5bGUpO1xuICAgICAgICB0aGlzLl9sYXllci5fcG1UZW1wTGF5ZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLl9sYXllckdyb3VwLmFkZExheWVyKHRoaXMuX2xheWVyKTtcblxuICAgICAgICAvLyB0aGlzIGlzIHRoZSBtYXJrZXIgaW4gdGhlIGNlbnRlciBvZiB0aGUgY2lyY2xlXG4gICAgICAgIHRoaXMuX2NlbnRlck1hcmtlciA9IEwubWFya2VyKFswLCAwXSwge1xuICAgICAgICAgICAgaWNvbjogTC5kaXZJY29uKHsgY2xhc3NOYW1lOiAnbWFya2VyLWljb24nIH0pLFxuICAgICAgICAgICAgZHJhZ2dhYmxlOiB0cnVlLFxuICAgICAgICAgICAgekluZGV4T2Zmc2V0OiAxMDBcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2NlbnRlck1hcmtlci5fcG1UZW1wTGF5ZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLl9sYXllckdyb3VwLmFkZExheWVyKHRoaXMuX2NlbnRlck1hcmtlcik7XG5cbiAgICAgICAgLy8gdGhpcyBpcyB0aGUgaGludG1hcmtlciBvbiB0aGUgbW91c2UgY3Vyc29yXG4gICAgICAgIHRoaXMuX2hpbnRNYXJrZXIgPSBMLm1hcmtlcihbMCwgMF0sIHtcbiAgICAgICAgICAgIGljb246IEwuZGl2SWNvbih7IGNsYXNzTmFtZTogJ21hcmtlci1pY29uIGN1cnNvci1tYXJrZXInIH0pXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9oaW50TWFya2VyLl9wbVRlbXBMYXllciA9IHRydWU7XG4gICAgICAgIHRoaXMuX2xheWVyR3JvdXAuYWRkTGF5ZXIodGhpcy5faGludE1hcmtlcik7XG5cbiAgICAgICAgLy8gc2hvdyB0aGUgaGludG1hcmtlciBpZiB0aGUgb3B0aW9uIGlzIHNldFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmN1cnNvck1hcmtlcikge1xuICAgICAgICAgICAgTC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2hpbnRNYXJrZXIuX2ljb24sICd2aXNpYmxlJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGlzIGlzIHRoZSBoaW50bGluZSBmcm9tIHRoZSBoaW50IG1hcmtlciB0byB0aGUgY2VudGVyIG1hcmtlclxuICAgICAgICB0aGlzLl9oaW50bGluZSA9IEwucG9seWxpbmUoW10sIHRoaXMub3B0aW9ucy5oaW50bGluZVN0eWxlKTtcbiAgICAgICAgdGhpcy5faGludGxpbmUuX3BtVGVtcExheWVyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fbGF5ZXJHcm91cC5hZGRMYXllcih0aGlzLl9oaW50bGluZSk7XG5cbiAgICAgICAgLy8gY2hhbmdlIG1hcCBjdXJzb3JcbiAgICAgICAgdGhpcy5fbWFwLl9jb250YWluZXIuc3R5bGUuY3Vyc29yID0gJ2Nyb3NzaGFpcic7XG5cbiAgICAgICAgLy8gY3JlYXRlIGEgcG9seWdvbi1wb2ludCBvbiBjbGlja1xuICAgICAgICB0aGlzLl9tYXAub24oJ2NsaWNrJywgdGhpcy5fcGxhY2VDZW50ZXJNYXJrZXIsIHRoaXMpO1xuXG4gICAgICAgIC8vIHN5bmMgaGludCBtYXJrZXIgd2l0aCBtb3VzZSBjdXJzb3JcbiAgICAgICAgdGhpcy5fbWFwLm9uKCdtb3VzZW1vdmUnLCB0aGlzLl9zeW5jSGludE1hcmtlciwgdGhpcyk7XG5cbiAgICAgICAgLy8gZmlyZSBkcmF3c3RhcnQgZXZlbnRcbiAgICAgICAgdGhpcy5fbWFwLmZpcmUoJ3BtOmRyYXdzdGFydCcsIHsgc2hhcGU6IHRoaXMuX3NoYXBlIH0pO1xuXG4gICAgICAgIC8vIHRvZ2dsZSB0aGUgZHJhdyBidXR0b24gb2YgdGhlIFRvb2xiYXIgaW4gY2FzZSBkcmF3aW5nIG1vZGUgZ290IGVuYWJsZWQgd2l0aG91dCB0aGUgYnV0dG9uXG4gICAgICAgIHRoaXMuX21hcC5wbS5Ub29sYmFyLnRvZ2dsZUJ1dHRvbih0aGlzLnRvb2xiYXJCdXR0b25OYW1lLCB0cnVlKTtcblxuICAgICAgICAvLyBhbiBhcnJheSB1c2VkIGluIHRoZSBzbmFwcGluZyBtaXhpbi5cbiAgICAgICAgLy8gVE9ETzogdGhpbmsgYWJvdXQgbW92aW5nIHRoaXMgc29tZXdoZXJlIGVsc2U/XG4gICAgICAgIHRoaXMuX290aGVyU25hcExheWVycyA9IFtdO1xuICAgIH0sXG4gICAgZGlzYWJsZTogZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICAgICAgLy8gZGlzYWJsZSBkcmF3aW5nIG1vZGVcblxuICAgICAgICAvLyBjYW5jZWwsIGlmIGRyYXdpbmcgbW9kZSBpc24ndCBldmVudCBlbmFibGVkXG4gICAgICAgIGlmICghdGhpcy5fZW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIHJlc2V0IGN1cnNvclxuICAgICAgICB0aGlzLl9tYXAuX2NvbnRhaW5lci5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG5cbiAgICAgICAgLy8gdW5iaW5kIGxpc3RlbmVyc1xuICAgICAgICB0aGlzLl9tYXAub2ZmKCdjbGljaycsIHRoaXMuX2ZpbmlzaFNoYXBlLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fbWFwLm9mZignY2xpY2snLCB0aGlzLl9wbGFjZUNlbnRlck1hcmtlciwgdGhpcyk7XG4gICAgICAgIHRoaXMuX21hcC5vZmYoJ21vdXNlbW92ZScsIHRoaXMuX3N5bmNIaW50TWFya2VyLCB0aGlzKTtcblxuICAgICAgICAvLyByZW1vdmUgaGVscGluZyBsYXllcnNcbiAgICAgICAgdGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2xheWVyR3JvdXApO1xuXG4gICAgICAgIC8vIGZpcmUgZHJhd2VuZCBldmVudFxuICAgICAgICB0aGlzLl9tYXAuZmlyZSgncG06ZHJhd2VuZCcsIHsgc2hhcGU6IHRoaXMuX3NoYXBlIH0pO1xuXG4gICAgICAgIC8vIHRvZ2dsZSB0aGUgZHJhdyBidXR0b24gb2YgdGhlIFRvb2xiYXIgaW4gY2FzZSBkcmF3aW5nIG1vZGUgZ290IGRpc2FibGVkIHdpdGhvdXQgdGhlIGJ1dHRvblxuICAgICAgICB0aGlzLl9tYXAucG0uVG9vbGJhci50b2dnbGVCdXR0b24odGhpcy50b29sYmFyQnV0dG9uTmFtZSwgZmFsc2UpO1xuXG4gICAgICAgIC8vIGNsZWFudXAgc25hcHBpbmdcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zbmFwcGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFudXBTbmFwcGluZygpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBlbmFibGVkOiBmdW5jdGlvbiBlbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5hYmxlZDtcbiAgICB9LFxuICAgIHRvZ2dsZTogZnVuY3Rpb24gdG9nZ2xlKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBfc3luY0hpbnRMaW5lOiBmdW5jdGlvbiBfc3luY0hpbnRMaW5lKCkge1xuICAgICAgICB2YXIgbGF0bG5nID0gdGhpcy5fY2VudGVyTWFya2VyLmdldExhdExuZygpO1xuXG4gICAgICAgIC8vIHNldCBjb29yZHMgZm9yIGhpbnRsaW5lIGZyb20gbWFya2VyIHRvIGxhc3QgdmVydGV4IG9mIGRyYXdpbiBwb2x5bGluZVxuICAgICAgICB0aGlzLl9oaW50bGluZS5zZXRMYXRMbmdzKFtsYXRsbmcsIHRoaXMuX2hpbnRNYXJrZXIuZ2V0TGF0TG5nKCldKTtcbiAgICB9LFxuICAgIF9zeW5jQ2lyY2xlUmFkaXVzOiBmdW5jdGlvbiBfc3luY0NpcmNsZVJhZGl1cygpIHtcbiAgICAgICAgdmFyIEEgPSB0aGlzLl9jZW50ZXJNYXJrZXIuZ2V0TGF0TG5nKCk7XG4gICAgICAgIHZhciBCID0gdGhpcy5faGludE1hcmtlci5nZXRMYXRMbmcoKTtcblxuICAgICAgICB2YXIgZGlzdGFuY2UgPSBBLmRpc3RhbmNlVG8oQik7XG5cbiAgICAgICAgdGhpcy5fbGF5ZXIuc2V0UmFkaXVzKGRpc3RhbmNlKTtcbiAgICB9LFxuICAgIF9zeW5jSGludE1hcmtlcjogZnVuY3Rpb24gX3N5bmNIaW50TWFya2VyKGUpIHtcbiAgICAgICAgLy8gbW92ZSB0aGUgY3Vyc29yIG1hcmtlclxuICAgICAgICB0aGlzLl9oaW50TWFya2VyLnNldExhdExuZyhlLmxhdGxuZyk7XG5cbiAgICAgICAgLy8gaWYgc25hcHBpbmcgaXMgZW5hYmxlZCwgZG8gaXRcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zbmFwcGFibGUpIHtcbiAgICAgICAgICAgIHZhciBmYWtlRHJhZ0V2ZW50ID0gZTtcbiAgICAgICAgICAgIGZha2VEcmFnRXZlbnQudGFyZ2V0ID0gdGhpcy5faGludE1hcmtlcjtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZVNuYXBwaW5nKGZha2VEcmFnRXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBfcGxhY2VDZW50ZXJNYXJrZXI6IGZ1bmN0aW9uIF9wbGFjZUNlbnRlck1hcmtlcihlKSB7XG4gICAgICAgIC8vIGFzc2lnbiB0aGUgY29vcmRpbmF0ZSBvZiB0aGUgY2xpY2sgdG8gdGhlIGhpbnRNYXJrZXIsIHRoYXQncyBuZWNlc3NhcnkgZm9yXG4gICAgICAgIC8vIG1vYmlsZSB3aGVyZSB0aGUgbWFya2VyIGNhbid0IGZvbGxvdyBhIGN1cnNvclxuICAgICAgICBpZiAoIXRoaXMuX2hpbnRNYXJrZXIuX3NuYXBwZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2hpbnRNYXJrZXIuc2V0TGF0TG5nKGUubGF0bG5nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGdldCBjb29yZGluYXRlIGZvciBuZXcgdmVydGV4IGJ5IGhpbnRNYXJrZXIgKGN1cnNvciBtYXJrZXIpXG4gICAgICAgIHZhciBsYXRsbmcgPSB0aGlzLl9oaW50TWFya2VyLmdldExhdExuZygpO1xuXG4gICAgICAgIHRoaXMuX2NlbnRlck1hcmtlci5zZXRMYXRMbmcobGF0bG5nKTtcblxuICAgICAgICB0aGlzLl9tYXAub2ZmKCdjbGljaycsIHRoaXMuX3BsYWNlQ2VudGVyTWFya2VyLCB0aGlzKTtcbiAgICAgICAgdGhpcy5fbWFwLm9uKCdjbGljaycsIHRoaXMuX2ZpbmlzaFNoYXBlLCB0aGlzKTtcblxuICAgICAgICB0aGlzLl9wbGFjZUNpcmNsZUNlbnRlcigpO1xuICAgIH0sXG4gICAgX3BsYWNlQ2lyY2xlQ2VudGVyOiBmdW5jdGlvbiBfcGxhY2VDaXJjbGVDZW50ZXIoKSB7XG4gICAgICAgIHZhciBsYXRsbmcgPSB0aGlzLl9jZW50ZXJNYXJrZXIuZ2V0TGF0TG5nKCk7XG5cbiAgICAgICAgaWYgKGxhdGxuZykge1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXIuc2V0TGF0TG5nKGxhdGxuZyk7XG5cbiAgICAgICAgICAgIC8vIHN5bmMgdGhlIGhpbnRsaW5lIHdpdGggaGludCBtYXJrZXJcbiAgICAgICAgICAgIHRoaXMuX2hpbnRNYXJrZXIub24oJ21vdmUnLCB0aGlzLl9zeW5jSGludExpbmUsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5faGludE1hcmtlci5vbignbW92ZScsIHRoaXMuX3N5bmNDaXJjbGVSYWRpdXMsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBfZmluaXNoU2hhcGU6IGZ1bmN0aW9uIF9maW5pc2hTaGFwZSgpIHtcbiAgICAgICAgLy8gY2FsYyB0aGUgcmFkaXVzXG4gICAgICAgIHZhciBjZW50ZXIgPSB0aGlzLl9jZW50ZXJNYXJrZXIuZ2V0TGF0TG5nKCk7XG4gICAgICAgIHZhciBjdXJzb3IgPSB0aGlzLl9oaW50TWFya2VyLmdldExhdExuZygpO1xuICAgICAgICB2YXIgcmFkaXVzID0gY2VudGVyLmRpc3RhbmNlVG8oY3Vyc29yKTtcblxuICAgICAgICAvLyBjcmVhdGUgdGhlIGZpbmFsIGNpcmNsZSBsYXllclxuICAgICAgICB2YXIgY2lyY2xlTGF5ZXIgPSBMLmNpcmNsZShjZW50ZXIsIHsgcmFkaXVzOiByYWRpdXMgfSkuYWRkVG8odGhpcy5fbWFwKTtcblxuICAgICAgICAvLyBkaXNhYmxlIGRyYXdpbmdcbiAgICAgICAgdGhpcy5kaXNhYmxlKCk7XG5cbiAgICAgICAgLy8gZmlyZSB0aGUgcG06Y3JlYXRlIGV2ZW50IGFuZCBwYXNzIHNoYXBlIGFuZCBsYXllclxuICAgICAgICB0aGlzLl9tYXAuZmlyZSgncG06Y3JlYXRlJywge1xuICAgICAgICAgICAgc2hhcGU6IHRoaXMuX3NoYXBlLFxuICAgICAgICAgICAgbGF5ZXI6IGNpcmNsZUxheWVyXG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgX2NyZWF0ZU1hcmtlcjogZnVuY3Rpb24gX2NyZWF0ZU1hcmtlcihsYXRsbmcpIHtcbiAgICAgICAgLy8gY3JlYXRlIHRoZSBuZXcgbWFya2VyXG4gICAgICAgIHZhciBtYXJrZXIgPSBuZXcgTC5NYXJrZXIobGF0bG5nLCB7XG4gICAgICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxuICAgICAgICAgICAgaWNvbjogTC5kaXZJY29uKHsgY2xhc3NOYW1lOiAnbWFya2VyLWljb24nIH0pXG4gICAgICAgIH0pO1xuICAgICAgICBtYXJrZXIuX3BtVGVtcExheWVyID0gdHJ1ZTtcblxuICAgICAgICAvLyBhZGQgaXQgdG8gdGhlIG1hcFxuICAgICAgICB0aGlzLl9sYXllckdyb3VwLmFkZExheWVyKG1hcmtlcik7XG5cbiAgICAgICAgcmV0dXJuIG1hcmtlcjtcbiAgICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9EcmF3L0wuUE0uRHJhdy5DaXJjbGUuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _LPM = __webpack_require__(1);\n\nvar _LPM2 = _interopRequireDefault(_LPM);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_LPM2.default.Line = _LPM2.default.extend({\n    initialize: function initialize(map) {\n        this._map = map;\n        this._shape = 'Line';\n        this.toolbarButtonName = 'drawPolyline';\n    },\n    enable: function enable(options) {\n        // TODO: Think about if these options could be passed globally for all\n        // instances of L.PM.Draw. So a dev could set drawing style one time as some kind of config\n        L.Util.setOptions(this, options);\n\n        // enable draw mode\n        this._enabled = true;\n\n        // create a new layergroup\n        this._layerGroup = new L.LayerGroup();\n        this._layerGroup.addTo(this._map);\n\n        // this is the polyLine that'll make up the polygon\n        this._layer = L.polyline([], this.options.templineStyle);\n        this._layer._pmTempLayer = true;\n        this._layerGroup.addLayer(this._layer);\n\n        // this is the hintline from the mouse cursor to the last marker\n        this._hintline = L.polyline([], this.options.hintlineStyle);\n        this._hintline._pmTempLayer = true;\n        this._layerGroup.addLayer(this._hintline);\n\n        // this is the hintmarker on the mouse cursor\n        this._hintMarker = L.marker([0, 0], {\n            icon: L.divIcon({ className: 'marker-icon cursor-marker' })\n        });\n        this._hintMarker._pmTempLayer = true;\n        this._layerGroup.addLayer(this._hintMarker);\n\n        // show the hintmarker if the option is set\n        if (this.options.cursorMarker) {\n            L.DomUtil.addClass(this._hintMarker._icon, 'visible');\n        }\n\n        // change map cursor\n        this._map._container.style.cursor = 'crosshair';\n\n        // create a polygon-point on click\n        this._map.on('click', this._createVertex, this);\n\n        // finish on double click\n        if (this.options.finishOnDoubleClick) {\n            this._map.on('dblclick', this._finishShape, this);\n        }\n\n        // sync hint marker with mouse cursor\n        this._map.on('mousemove', this._syncHintMarker, this);\n\n        // sync the hintline with hint marker\n        this._hintMarker.on('move', this._syncHintLine, this);\n\n        // fire drawstart event\n        this._map.fire('pm:drawstart', { shape: this._shape });\n\n        // toggle the draw button of the Toolbar in case drawing mode got enabled without the button\n        this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, true);\n\n        // an array used in the snapping mixin.\n        // TODO: think about moving this somewhere else?\n        this._otherSnapLayers = [];\n    },\n    disable: function disable() {\n        // disable draw mode\n\n        // cancel, if drawing mode isn't even enabled\n        if (!this._enabled) {\n            return;\n        }\n\n        this._enabled = false;\n\n        // reset cursor\n        this._map._container.style.cursor = 'default';\n\n        // unbind listeners\n        this._map.off('click', this._createVertex, this);\n        this._map.off('mousemove', this._syncHintMarker, this);\n        this._map.off('dblclick', this._finishShape, this);\n\n        // remove layer\n        this._map.removeLayer(this._layerGroup);\n\n        // fire drawend event\n        this._map.fire('pm:drawend', { shape: this._shape });\n\n        // toggle the draw button of the Toolbar in case drawing mode got disabled without the button\n        this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, false);\n\n        // cleanup snapping\n        if (this.options.snappable) {\n            this._cleanupSnapping();\n        }\n    },\n    enabled: function enabled() {\n        return this._enabled;\n    },\n    toggle: function toggle(options) {\n        if (this.enabled()) {\n            this.disable();\n        } else {\n            this.enable(options);\n        }\n    },\n    _syncHintLine: function _syncHintLine() {\n        var polyPoints = this._layer.getLatLngs();\n\n        if (polyPoints.length > 0) {\n            var lastPolygonPoint = polyPoints[polyPoints.length - 1];\n\n            // set coords for hintline from marker to last vertex of drawin polyline\n            this._hintline.setLatLngs([lastPolygonPoint, this._hintMarker.getLatLng()]);\n        }\n    },\n    _syncHintMarker: function _syncHintMarker(e) {\n        // move the cursor marker\n        this._hintMarker.setLatLng(e.latlng);\n\n        // if snapping is enabled, do it\n        if (this.options.snappable) {\n            var fakeDragEvent = e;\n            fakeDragEvent.target = this._hintMarker;\n            this._handleSnapping(fakeDragEvent);\n        }\n    },\n    _createVertex: function _createVertex(e) {\n        // assign the coordinate of the click to the hintMarker, that's necessary for\n        // mobile where the marker can't follow a cursor\n        if (!this._hintMarker._snapped) {\n            this._hintMarker.setLatLng(e.latlng);\n        }\n\n        // get coordinate for new vertex by hintMarker (cursor marker)\n        var latlng = this._hintMarker.getLatLng();\n\n        // check if the first and this vertex have the same latlng\n        if (latlng.equals(this._layer.getLatLngs()[0])) {\n            // yes? finish the polygon\n            this._finishShape();\n\n            // \"why?\", you ask? Because this happens when we snap the last vertex to the first one\n            // and then click without hitting the last marker. Click happens on the map\n            // in 99% of cases it's because the user wants to finish the polygon. So...\n            return;\n        }\n\n        // is this the first point?\n        var first = this._layer.getLatLngs().length === 0;\n\n        this._layer.addLatLng(latlng);\n        this._createMarker(latlng, first);\n\n        this._hintline.setLatLngs([latlng, latlng]);\n    },\n    _finishShape: function _finishShape() {\n        // get coordinates, create the leaflet shape and add it to the map\n        var coords = this._layer.getLatLngs();\n        var polylineLayer = L.polyline(coords, this.options.pathOptions).addTo(this._map);\n\n        // disable drawing\n        this.disable();\n\n        // fire the pm:create event and pass shape and layer\n        this._map.fire('pm:create', {\n            shape: this._shape,\n            layer: polylineLayer\n        });\n\n        if (this.options.snappable) {\n            this._cleanupSnapping();\n        }\n    },\n    _createMarker: function _createMarker(latlng) {\n        // create the new marker\n        var marker = new L.Marker(latlng, {\n            draggable: false,\n            icon: L.divIcon({ className: 'marker-icon' })\n        });\n        marker._pmTempLayer = true;\n\n        // add it to the map\n        this._layerGroup.addLayer(marker);\n\n        // a click on any marker finishes this shape\n        marker.on('click', this._finishShape, this);\n\n        return marker;\n    }\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9EcmF3L0wuUE0uRHJhdy5MaW5lLmpzP2ZkNDUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX0xQTSA9IHJlcXVpcmUoJy4vTC5QTS5EcmF3Jyk7XG5cbnZhciBfTFBNMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xQTSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbl9MUE0yLmRlZmF1bHQuTGluZSA9IF9MUE0yLmRlZmF1bHQuZXh0ZW5kKHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBpbml0aWFsaXplKG1hcCkge1xuICAgICAgICB0aGlzLl9tYXAgPSBtYXA7XG4gICAgICAgIHRoaXMuX3NoYXBlID0gJ0xpbmUnO1xuICAgICAgICB0aGlzLnRvb2xiYXJCdXR0b25OYW1lID0gJ2RyYXdQb2x5bGluZSc7XG4gICAgfSxcbiAgICBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZShvcHRpb25zKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaW5rIGFib3V0IGlmIHRoZXNlIG9wdGlvbnMgY291bGQgYmUgcGFzc2VkIGdsb2JhbGx5IGZvciBhbGxcbiAgICAgICAgLy8gaW5zdGFuY2VzIG9mIEwuUE0uRHJhdy4gU28gYSBkZXYgY291bGQgc2V0IGRyYXdpbmcgc3R5bGUgb25lIHRpbWUgYXMgc29tZSBraW5kIG9mIGNvbmZpZ1xuICAgICAgICBMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBlbmFibGUgZHJhdyBtb2RlXG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSB0cnVlO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBsYXllcmdyb3VwXG4gICAgICAgIHRoaXMuX2xheWVyR3JvdXAgPSBuZXcgTC5MYXllckdyb3VwKCk7XG4gICAgICAgIHRoaXMuX2xheWVyR3JvdXAuYWRkVG8odGhpcy5fbWFwKTtcblxuICAgICAgICAvLyB0aGlzIGlzIHRoZSBwb2x5TGluZSB0aGF0J2xsIG1ha2UgdXAgdGhlIHBvbHlnb25cbiAgICAgICAgdGhpcy5fbGF5ZXIgPSBMLnBvbHlsaW5lKFtdLCB0aGlzLm9wdGlvbnMudGVtcGxpbmVTdHlsZSk7XG4gICAgICAgIHRoaXMuX2xheWVyLl9wbVRlbXBMYXllciA9IHRydWU7XG4gICAgICAgIHRoaXMuX2xheWVyR3JvdXAuYWRkTGF5ZXIodGhpcy5fbGF5ZXIpO1xuXG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIGhpbnRsaW5lIGZyb20gdGhlIG1vdXNlIGN1cnNvciB0byB0aGUgbGFzdCBtYXJrZXJcbiAgICAgICAgdGhpcy5faGludGxpbmUgPSBMLnBvbHlsaW5lKFtdLCB0aGlzLm9wdGlvbnMuaGludGxpbmVTdHlsZSk7XG4gICAgICAgIHRoaXMuX2hpbnRsaW5lLl9wbVRlbXBMYXllciA9IHRydWU7XG4gICAgICAgIHRoaXMuX2xheWVyR3JvdXAuYWRkTGF5ZXIodGhpcy5faGludGxpbmUpO1xuXG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIGhpbnRtYXJrZXIgb24gdGhlIG1vdXNlIGN1cnNvclxuICAgICAgICB0aGlzLl9oaW50TWFya2VyID0gTC5tYXJrZXIoWzAsIDBdLCB7XG4gICAgICAgICAgICBpY29uOiBMLmRpdkljb24oeyBjbGFzc05hbWU6ICdtYXJrZXItaWNvbiBjdXJzb3ItbWFya2VyJyB9KVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5faGludE1hcmtlci5fcG1UZW1wTGF5ZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLl9sYXllckdyb3VwLmFkZExheWVyKHRoaXMuX2hpbnRNYXJrZXIpO1xuXG4gICAgICAgIC8vIHNob3cgdGhlIGhpbnRtYXJrZXIgaWYgdGhlIG9wdGlvbiBpcyBzZXRcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jdXJzb3JNYXJrZXIpIHtcbiAgICAgICAgICAgIEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9oaW50TWFya2VyLl9pY29uLCAndmlzaWJsZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hhbmdlIG1hcCBjdXJzb3JcbiAgICAgICAgdGhpcy5fbWFwLl9jb250YWluZXIuc3R5bGUuY3Vyc29yID0gJ2Nyb3NzaGFpcic7XG5cbiAgICAgICAgLy8gY3JlYXRlIGEgcG9seWdvbi1wb2ludCBvbiBjbGlja1xuICAgICAgICB0aGlzLl9tYXAub24oJ2NsaWNrJywgdGhpcy5fY3JlYXRlVmVydGV4LCB0aGlzKTtcblxuICAgICAgICAvLyBmaW5pc2ggb24gZG91YmxlIGNsaWNrXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZmluaXNoT25Eb3VibGVDbGljaykge1xuICAgICAgICAgICAgdGhpcy5fbWFwLm9uKCdkYmxjbGljaycsIHRoaXMuX2ZpbmlzaFNoYXBlLCB0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN5bmMgaGludCBtYXJrZXIgd2l0aCBtb3VzZSBjdXJzb3JcbiAgICAgICAgdGhpcy5fbWFwLm9uKCdtb3VzZW1vdmUnLCB0aGlzLl9zeW5jSGludE1hcmtlciwgdGhpcyk7XG5cbiAgICAgICAgLy8gc3luYyB0aGUgaGludGxpbmUgd2l0aCBoaW50IG1hcmtlclxuICAgICAgICB0aGlzLl9oaW50TWFya2VyLm9uKCdtb3ZlJywgdGhpcy5fc3luY0hpbnRMaW5lLCB0aGlzKTtcblxuICAgICAgICAvLyBmaXJlIGRyYXdzdGFydCBldmVudFxuICAgICAgICB0aGlzLl9tYXAuZmlyZSgncG06ZHJhd3N0YXJ0JywgeyBzaGFwZTogdGhpcy5fc2hhcGUgfSk7XG5cbiAgICAgICAgLy8gdG9nZ2xlIHRoZSBkcmF3IGJ1dHRvbiBvZiB0aGUgVG9vbGJhciBpbiBjYXNlIGRyYXdpbmcgbW9kZSBnb3QgZW5hYmxlZCB3aXRob3V0IHRoZSBidXR0b25cbiAgICAgICAgdGhpcy5fbWFwLnBtLlRvb2xiYXIudG9nZ2xlQnV0dG9uKHRoaXMudG9vbGJhckJ1dHRvbk5hbWUsIHRydWUpO1xuXG4gICAgICAgIC8vIGFuIGFycmF5IHVzZWQgaW4gdGhlIHNuYXBwaW5nIG1peGluLlxuICAgICAgICAvLyBUT0RPOiB0aGluayBhYm91dCBtb3ZpbmcgdGhpcyBzb21ld2hlcmUgZWxzZT9cbiAgICAgICAgdGhpcy5fb3RoZXJTbmFwTGF5ZXJzID0gW107XG4gICAgfSxcbiAgICBkaXNhYmxlOiBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgICAgICAvLyBkaXNhYmxlIGRyYXcgbW9kZVxuXG4gICAgICAgIC8vIGNhbmNlbCwgaWYgZHJhd2luZyBtb2RlIGlzbid0IGV2ZW4gZW5hYmxlZFxuICAgICAgICBpZiAoIXRoaXMuX2VuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcblxuICAgICAgICAvLyByZXNldCBjdXJzb3JcbiAgICAgICAgdGhpcy5fbWFwLl9jb250YWluZXIuc3R5bGUuY3Vyc29yID0gJ2RlZmF1bHQnO1xuXG4gICAgICAgIC8vIHVuYmluZCBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5fbWFwLm9mZignY2xpY2snLCB0aGlzLl9jcmVhdGVWZXJ0ZXgsIHRoaXMpO1xuICAgICAgICB0aGlzLl9tYXAub2ZmKCdtb3VzZW1vdmUnLCB0aGlzLl9zeW5jSGludE1hcmtlciwgdGhpcyk7XG4gICAgICAgIHRoaXMuX21hcC5vZmYoJ2RibGNsaWNrJywgdGhpcy5fZmluaXNoU2hhcGUsIHRoaXMpO1xuXG4gICAgICAgIC8vIHJlbW92ZSBsYXllclxuICAgICAgICB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbGF5ZXJHcm91cCk7XG5cbiAgICAgICAgLy8gZmlyZSBkcmF3ZW5kIGV2ZW50XG4gICAgICAgIHRoaXMuX21hcC5maXJlKCdwbTpkcmF3ZW5kJywgeyBzaGFwZTogdGhpcy5fc2hhcGUgfSk7XG5cbiAgICAgICAgLy8gdG9nZ2xlIHRoZSBkcmF3IGJ1dHRvbiBvZiB0aGUgVG9vbGJhciBpbiBjYXNlIGRyYXdpbmcgbW9kZSBnb3QgZGlzYWJsZWQgd2l0aG91dCB0aGUgYnV0dG9uXG4gICAgICAgIHRoaXMuX21hcC5wbS5Ub29sYmFyLnRvZ2dsZUJ1dHRvbih0aGlzLnRvb2xiYXJCdXR0b25OYW1lLCBmYWxzZSk7XG5cbiAgICAgICAgLy8gY2xlYW51cCBzbmFwcGluZ1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNuYXBwYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5fY2xlYW51cFNuYXBwaW5nKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGVuYWJsZWQ6IGZ1bmN0aW9uIGVuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xuICAgIH0sXG4gICAgdG9nZ2xlOiBmdW5jdGlvbiB0b2dnbGUob3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5lbmFibGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbmFibGUob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIF9zeW5jSGludExpbmU6IGZ1bmN0aW9uIF9zeW5jSGludExpbmUoKSB7XG4gICAgICAgIHZhciBwb2x5UG9pbnRzID0gdGhpcy5fbGF5ZXIuZ2V0TGF0TG5ncygpO1xuXG4gICAgICAgIGlmIChwb2x5UG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHZhciBsYXN0UG9seWdvblBvaW50ID0gcG9seVBvaW50c1twb2x5UG9pbnRzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICAvLyBzZXQgY29vcmRzIGZvciBoaW50bGluZSBmcm9tIG1hcmtlciB0byBsYXN0IHZlcnRleCBvZiBkcmF3aW4gcG9seWxpbmVcbiAgICAgICAgICAgIHRoaXMuX2hpbnRsaW5lLnNldExhdExuZ3MoW2xhc3RQb2x5Z29uUG9pbnQsIHRoaXMuX2hpbnRNYXJrZXIuZ2V0TGF0TG5nKCldKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX3N5bmNIaW50TWFya2VyOiBmdW5jdGlvbiBfc3luY0hpbnRNYXJrZXIoZSkge1xuICAgICAgICAvLyBtb3ZlIHRoZSBjdXJzb3IgbWFya2VyXG4gICAgICAgIHRoaXMuX2hpbnRNYXJrZXIuc2V0TGF0TG5nKGUubGF0bG5nKTtcblxuICAgICAgICAvLyBpZiBzbmFwcGluZyBpcyBlbmFibGVkLCBkbyBpdFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNuYXBwYWJsZSkge1xuICAgICAgICAgICAgdmFyIGZha2VEcmFnRXZlbnQgPSBlO1xuICAgICAgICAgICAgZmFrZURyYWdFdmVudC50YXJnZXQgPSB0aGlzLl9oaW50TWFya2VyO1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlU25hcHBpbmcoZmFrZURyYWdFdmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIF9jcmVhdGVWZXJ0ZXg6IGZ1bmN0aW9uIF9jcmVhdGVWZXJ0ZXgoZSkge1xuICAgICAgICAvLyBhc3NpZ24gdGhlIGNvb3JkaW5hdGUgb2YgdGhlIGNsaWNrIHRvIHRoZSBoaW50TWFya2VyLCB0aGF0J3MgbmVjZXNzYXJ5IGZvclxuICAgICAgICAvLyBtb2JpbGUgd2hlcmUgdGhlIG1hcmtlciBjYW4ndCBmb2xsb3cgYSBjdXJzb3JcbiAgICAgICAgaWYgKCF0aGlzLl9oaW50TWFya2VyLl9zbmFwcGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9oaW50TWFya2VyLnNldExhdExuZyhlLmxhdGxuZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgY29vcmRpbmF0ZSBmb3IgbmV3IHZlcnRleCBieSBoaW50TWFya2VyIChjdXJzb3IgbWFya2VyKVxuICAgICAgICB2YXIgbGF0bG5nID0gdGhpcy5faGludE1hcmtlci5nZXRMYXRMbmcoKTtcblxuICAgICAgICAvLyBjaGVjayBpZiB0aGUgZmlyc3QgYW5kIHRoaXMgdmVydGV4IGhhdmUgdGhlIHNhbWUgbGF0bG5nXG4gICAgICAgIGlmIChsYXRsbmcuZXF1YWxzKHRoaXMuX2xheWVyLmdldExhdExuZ3MoKVswXSkpIHtcbiAgICAgICAgICAgIC8vIHllcz8gZmluaXNoIHRoZSBwb2x5Z29uXG4gICAgICAgICAgICB0aGlzLl9maW5pc2hTaGFwZSgpO1xuXG4gICAgICAgICAgICAvLyBcIndoeT9cIiwgeW91IGFzaz8gQmVjYXVzZSB0aGlzIGhhcHBlbnMgd2hlbiB3ZSBzbmFwIHRoZSBsYXN0IHZlcnRleCB0byB0aGUgZmlyc3Qgb25lXG4gICAgICAgICAgICAvLyBhbmQgdGhlbiBjbGljayB3aXRob3V0IGhpdHRpbmcgdGhlIGxhc3QgbWFya2VyLiBDbGljayBoYXBwZW5zIG9uIHRoZSBtYXBcbiAgICAgICAgICAgIC8vIGluIDk5JSBvZiBjYXNlcyBpdCdzIGJlY2F1c2UgdGhlIHVzZXIgd2FudHMgdG8gZmluaXNoIHRoZSBwb2x5Z29uLiBTby4uLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaXMgdGhpcyB0aGUgZmlyc3QgcG9pbnQ/XG4gICAgICAgIHZhciBmaXJzdCA9IHRoaXMuX2xheWVyLmdldExhdExuZ3MoKS5sZW5ndGggPT09IDA7XG5cbiAgICAgICAgdGhpcy5fbGF5ZXIuYWRkTGF0TG5nKGxhdGxuZyk7XG4gICAgICAgIHRoaXMuX2NyZWF0ZU1hcmtlcihsYXRsbmcsIGZpcnN0KTtcblxuICAgICAgICB0aGlzLl9oaW50bGluZS5zZXRMYXRMbmdzKFtsYXRsbmcsIGxhdGxuZ10pO1xuICAgIH0sXG4gICAgX2ZpbmlzaFNoYXBlOiBmdW5jdGlvbiBfZmluaXNoU2hhcGUoKSB7XG4gICAgICAgIC8vIGdldCBjb29yZGluYXRlcywgY3JlYXRlIHRoZSBsZWFmbGV0IHNoYXBlIGFuZCBhZGQgaXQgdG8gdGhlIG1hcFxuICAgICAgICB2YXIgY29vcmRzID0gdGhpcy5fbGF5ZXIuZ2V0TGF0TG5ncygpO1xuICAgICAgICB2YXIgcG9seWxpbmVMYXllciA9IEwucG9seWxpbmUoY29vcmRzLCB0aGlzLm9wdGlvbnMucGF0aE9wdGlvbnMpLmFkZFRvKHRoaXMuX21hcCk7XG5cbiAgICAgICAgLy8gZGlzYWJsZSBkcmF3aW5nXG4gICAgICAgIHRoaXMuZGlzYWJsZSgpO1xuXG4gICAgICAgIC8vIGZpcmUgdGhlIHBtOmNyZWF0ZSBldmVudCBhbmQgcGFzcyBzaGFwZSBhbmQgbGF5ZXJcbiAgICAgICAgdGhpcy5fbWFwLmZpcmUoJ3BtOmNyZWF0ZScsIHtcbiAgICAgICAgICAgIHNoYXBlOiB0aGlzLl9zaGFwZSxcbiAgICAgICAgICAgIGxheWVyOiBwb2x5bGluZUxheWVyXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc25hcHBhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9jbGVhbnVwU25hcHBpbmcoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX2NyZWF0ZU1hcmtlcjogZnVuY3Rpb24gX2NyZWF0ZU1hcmtlcihsYXRsbmcpIHtcbiAgICAgICAgLy8gY3JlYXRlIHRoZSBuZXcgbWFya2VyXG4gICAgICAgIHZhciBtYXJrZXIgPSBuZXcgTC5NYXJrZXIobGF0bG5nLCB7XG4gICAgICAgICAgICBkcmFnZ2FibGU6IGZhbHNlLFxuICAgICAgICAgICAgaWNvbjogTC5kaXZJY29uKHsgY2xhc3NOYW1lOiAnbWFya2VyLWljb24nIH0pXG4gICAgICAgIH0pO1xuICAgICAgICBtYXJrZXIuX3BtVGVtcExheWVyID0gdHJ1ZTtcblxuICAgICAgICAvLyBhZGQgaXQgdG8gdGhlIG1hcFxuICAgICAgICB0aGlzLl9sYXllckdyb3VwLmFkZExheWVyKG1hcmtlcik7XG5cbiAgICAgICAgLy8gYSBjbGljayBvbiBhbnkgbWFya2VyIGZpbmlzaGVzIHRoaXMgc2hhcGVcbiAgICAgICAgbWFya2VyLm9uKCdjbGljaycsIHRoaXMuX2ZpbmlzaFNoYXBlLCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gbWFya2VyO1xuICAgIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL0RyYXcvTC5QTS5EcmF3LkxpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _LPM = __webpack_require__(1);\n\nvar _LPM2 = _interopRequireDefault(_LPM);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_LPM2.default.Marker = _LPM2.default.extend({\n    initialize: function initialize(map) {\n        this._map = map;\n        this._shape = 'Marker';\n        this.toolbarButtonName = 'drawMarker';\n    },\n    enable: function enable(options) {\n        // TODO: Think about if these options could be passed globally for all\n        // instances of L.PM.Draw. So a dev could set drawing style one time as some kind of config\n        L.Util.setOptions(this, options);\n\n        // change enabled state\n        this._enabled = true;\n\n        // create a marker on click on the map\n        this._map.on('click', this._createMarker, this);\n\n        // toggle the draw button of the Toolbar in case drawing mode got enabled without the button\n        this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, true);\n\n        // this is the hintmarker on the mouse cursor\n        this._hintMarker = L.marker([0, 0], this.options.markerStyle);\n        this._hintMarker._pmTempLayer = true;\n        this._hintMarker.addTo(this._map);\n\n        // this is just to keep the snappable mixin happy\n        this._layer = this._hintMarker;\n\n        // sync hint marker with mouse cursor\n        this._map.on('mousemove', this._syncHintMarker, this);\n\n        // enable edit mode for existing markers\n        this._map.eachLayer(function (layer) {\n            if (layer instanceof L.Marker) {\n                layer.pm.enable();\n            }\n        });\n    },\n    disable: function disable() {\n        // cancel, if drawing mode isn't even enabled\n        if (!this._enabled) {\n            return;\n        }\n\n        // undbind click event, don't create a marker on click anymore\n        this._map.off('click', this._createMarker, this);\n\n        // remove hint marker\n        this._hintMarker.remove();\n\n        // remove event listener to sync hint marker\n        this._map.off('mousemove', this._syncHintMarker, this);\n\n        // disable dragging and removing for all markers\n        this._map.eachLayer(function (layer) {\n            if (layer instanceof L.Marker && !layer._pmTempLayer) {\n                layer.pm.disable();\n            }\n        });\n\n        // toggle the draw button of the Toolbar in case drawing mode got disabled without the button\n        this._map.pm.Toolbar.toggleButton(this.toolbarButtonName, false);\n\n        // change enabled state\n        this._enabled = false;\n    },\n    enabled: function enabled() {\n        return this._enabled;\n    },\n    toggle: function toggle(options) {\n        if (this.enabled()) {\n            this.disable();\n        } else {\n            this.enable(options);\n        }\n    },\n    _createMarker: function _createMarker(e) {\n        if (!e.latlng) {\n            return;\n        }\n\n        // assign the coordinate of the click to the hintMarker, that's necessary for\n        // mobile where the marker can't follow a cursor\n        if (!this._hintMarker._snapped) {\n            this._hintMarker.setLatLng(e.latlng);\n        }\n\n        // get coordinate for new vertex by hintMarker (cursor marker)\n        var latlng = this._hintMarker.getLatLng();\n\n        // create marker\n        var marker = new L.Marker(latlng, this.options.markerStyle);\n\n        // add marker to the map\n        marker.addTo(this._map);\n\n        // enable editing for the marker\n        marker.pm.enable();\n\n        // fire the pm:create event and pass shape and marker\n        this._map.fire('pm:create', {\n            shape: this._shape,\n            marker: marker, // DEPRECATED\n            layer: marker\n        });\n\n        this._cleanupSnapping();\n    },\n    _syncHintMarker: function _syncHintMarker(e) {\n        // move the cursor marker\n        this._hintMarker.setLatLng(e.latlng);\n\n        // if snapping is enabled, do it\n        if (this.options.snappable) {\n            var fakeDragEvent = e;\n            fakeDragEvent.target = this._hintMarker;\n            this._handleSnapping(fakeDragEvent);\n        }\n    }\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9EcmF3L0wuUE0uRHJhdy5NYXJrZXIuanM/YTUzMiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfTFBNID0gcmVxdWlyZSgnLi9MLlBNLkRyYXcnKTtcblxudmFyIF9MUE0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTFBNKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuX0xQTTIuZGVmYXVsdC5NYXJrZXIgPSBfTFBNMi5kZWZhdWx0LmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZShtYXApIHtcbiAgICAgICAgdGhpcy5fbWFwID0gbWFwO1xuICAgICAgICB0aGlzLl9zaGFwZSA9ICdNYXJrZXInO1xuICAgICAgICB0aGlzLnRvb2xiYXJCdXR0b25OYW1lID0gJ2RyYXdNYXJrZXInO1xuICAgIH0sXG4gICAgZW5hYmxlOiBmdW5jdGlvbiBlbmFibGUob3B0aW9ucykge1xuICAgICAgICAvLyBUT0RPOiBUaGluayBhYm91dCBpZiB0aGVzZSBvcHRpb25zIGNvdWxkIGJlIHBhc3NlZCBnbG9iYWxseSBmb3IgYWxsXG4gICAgICAgIC8vIGluc3RhbmNlcyBvZiBMLlBNLkRyYXcuIFNvIGEgZGV2IGNvdWxkIHNldCBkcmF3aW5nIHN0eWxlIG9uZSB0aW1lIGFzIHNvbWUga2luZCBvZiBjb25maWdcbiAgICAgICAgTC5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gY2hhbmdlIGVuYWJsZWQgc3RhdGVcbiAgICAgICAgdGhpcy5fZW5hYmxlZCA9IHRydWU7XG5cbiAgICAgICAgLy8gY3JlYXRlIGEgbWFya2VyIG9uIGNsaWNrIG9uIHRoZSBtYXBcbiAgICAgICAgdGhpcy5fbWFwLm9uKCdjbGljaycsIHRoaXMuX2NyZWF0ZU1hcmtlciwgdGhpcyk7XG5cbiAgICAgICAgLy8gdG9nZ2xlIHRoZSBkcmF3IGJ1dHRvbiBvZiB0aGUgVG9vbGJhciBpbiBjYXNlIGRyYXdpbmcgbW9kZSBnb3QgZW5hYmxlZCB3aXRob3V0IHRoZSBidXR0b25cbiAgICAgICAgdGhpcy5fbWFwLnBtLlRvb2xiYXIudG9nZ2xlQnV0dG9uKHRoaXMudG9vbGJhckJ1dHRvbk5hbWUsIHRydWUpO1xuXG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIGhpbnRtYXJrZXIgb24gdGhlIG1vdXNlIGN1cnNvclxuICAgICAgICB0aGlzLl9oaW50TWFya2VyID0gTC5tYXJrZXIoWzAsIDBdLCB0aGlzLm9wdGlvbnMubWFya2VyU3R5bGUpO1xuICAgICAgICB0aGlzLl9oaW50TWFya2VyLl9wbVRlbXBMYXllciA9IHRydWU7XG4gICAgICAgIHRoaXMuX2hpbnRNYXJrZXIuYWRkVG8odGhpcy5fbWFwKTtcblxuICAgICAgICAvLyB0aGlzIGlzIGp1c3QgdG8ga2VlcCB0aGUgc25hcHBhYmxlIG1peGluIGhhcHB5XG4gICAgICAgIHRoaXMuX2xheWVyID0gdGhpcy5faGludE1hcmtlcjtcblxuICAgICAgICAvLyBzeW5jIGhpbnQgbWFya2VyIHdpdGggbW91c2UgY3Vyc29yXG4gICAgICAgIHRoaXMuX21hcC5vbignbW91c2Vtb3ZlJywgdGhpcy5fc3luY0hpbnRNYXJrZXIsIHRoaXMpO1xuXG4gICAgICAgIC8vIGVuYWJsZSBlZGl0IG1vZGUgZm9yIGV4aXN0aW5nIG1hcmtlcnNcbiAgICAgICAgdGhpcy5fbWFwLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgIGlmIChsYXllciBpbnN0YW5jZW9mIEwuTWFya2VyKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXIucG0uZW5hYmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgZGlzYWJsZTogZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICAgICAgLy8gY2FuY2VsLCBpZiBkcmF3aW5nIG1vZGUgaXNuJ3QgZXZlbiBlbmFibGVkXG4gICAgICAgIGlmICghdGhpcy5fZW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdW5kYmluZCBjbGljayBldmVudCwgZG9uJ3QgY3JlYXRlIGEgbWFya2VyIG9uIGNsaWNrIGFueW1vcmVcbiAgICAgICAgdGhpcy5fbWFwLm9mZignY2xpY2snLCB0aGlzLl9jcmVhdGVNYXJrZXIsIHRoaXMpO1xuXG4gICAgICAgIC8vIHJlbW92ZSBoaW50IG1hcmtlclxuICAgICAgICB0aGlzLl9oaW50TWFya2VyLnJlbW92ZSgpO1xuXG4gICAgICAgIC8vIHJlbW92ZSBldmVudCBsaXN0ZW5lciB0byBzeW5jIGhpbnQgbWFya2VyXG4gICAgICAgIHRoaXMuX21hcC5vZmYoJ21vdXNlbW92ZScsIHRoaXMuX3N5bmNIaW50TWFya2VyLCB0aGlzKTtcblxuICAgICAgICAvLyBkaXNhYmxlIGRyYWdnaW5nIGFuZCByZW1vdmluZyBmb3IgYWxsIG1hcmtlcnNcbiAgICAgICAgdGhpcy5fbWFwLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgIGlmIChsYXllciBpbnN0YW5jZW9mIEwuTWFya2VyICYmICFsYXllci5fcG1UZW1wTGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBsYXllci5wbS5kaXNhYmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIHRvZ2dsZSB0aGUgZHJhdyBidXR0b24gb2YgdGhlIFRvb2xiYXIgaW4gY2FzZSBkcmF3aW5nIG1vZGUgZ290IGRpc2FibGVkIHdpdGhvdXQgdGhlIGJ1dHRvblxuICAgICAgICB0aGlzLl9tYXAucG0uVG9vbGJhci50b2dnbGVCdXR0b24odGhpcy50b29sYmFyQnV0dG9uTmFtZSwgZmFsc2UpO1xuXG4gICAgICAgIC8vIGNoYW5nZSBlbmFibGVkIHN0YXRlXG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcbiAgICB9LFxuICAgIGVuYWJsZWQ6IGZ1bmN0aW9uIGVuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xuICAgIH0sXG4gICAgdG9nZ2xlOiBmdW5jdGlvbiB0b2dnbGUob3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5lbmFibGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbmFibGUob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIF9jcmVhdGVNYXJrZXI6IGZ1bmN0aW9uIF9jcmVhdGVNYXJrZXIoZSkge1xuICAgICAgICBpZiAoIWUubGF0bG5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhc3NpZ24gdGhlIGNvb3JkaW5hdGUgb2YgdGhlIGNsaWNrIHRvIHRoZSBoaW50TWFya2VyLCB0aGF0J3MgbmVjZXNzYXJ5IGZvclxuICAgICAgICAvLyBtb2JpbGUgd2hlcmUgdGhlIG1hcmtlciBjYW4ndCBmb2xsb3cgYSBjdXJzb3JcbiAgICAgICAgaWYgKCF0aGlzLl9oaW50TWFya2VyLl9zbmFwcGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9oaW50TWFya2VyLnNldExhdExuZyhlLmxhdGxuZyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBnZXQgY29vcmRpbmF0ZSBmb3IgbmV3IHZlcnRleCBieSBoaW50TWFya2VyIChjdXJzb3IgbWFya2VyKVxuICAgICAgICB2YXIgbGF0bG5nID0gdGhpcy5faGludE1hcmtlci5nZXRMYXRMbmcoKTtcblxuICAgICAgICAvLyBjcmVhdGUgbWFya2VyXG4gICAgICAgIHZhciBtYXJrZXIgPSBuZXcgTC5NYXJrZXIobGF0bG5nLCB0aGlzLm9wdGlvbnMubWFya2VyU3R5bGUpO1xuXG4gICAgICAgIC8vIGFkZCBtYXJrZXIgdG8gdGhlIG1hcFxuICAgICAgICBtYXJrZXIuYWRkVG8odGhpcy5fbWFwKTtcblxuICAgICAgICAvLyBlbmFibGUgZWRpdGluZyBmb3IgdGhlIG1hcmtlclxuICAgICAgICBtYXJrZXIucG0uZW5hYmxlKCk7XG5cbiAgICAgICAgLy8gZmlyZSB0aGUgcG06Y3JlYXRlIGV2ZW50IGFuZCBwYXNzIHNoYXBlIGFuZCBtYXJrZXJcbiAgICAgICAgdGhpcy5fbWFwLmZpcmUoJ3BtOmNyZWF0ZScsIHtcbiAgICAgICAgICAgIHNoYXBlOiB0aGlzLl9zaGFwZSxcbiAgICAgICAgICAgIG1hcmtlcjogbWFya2VyLCAvLyBERVBSRUNBVEVEXG4gICAgICAgICAgICBsYXllcjogbWFya2VyXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2NsZWFudXBTbmFwcGluZygpO1xuICAgIH0sXG4gICAgX3N5bmNIaW50TWFya2VyOiBmdW5jdGlvbiBfc3luY0hpbnRNYXJrZXIoZSkge1xuICAgICAgICAvLyBtb3ZlIHRoZSBjdXJzb3IgbWFya2VyXG4gICAgICAgIHRoaXMuX2hpbnRNYXJrZXIuc2V0TGF0TG5nKGUubGF0bG5nKTtcblxuICAgICAgICAvLyBpZiBzbmFwcGluZyBpcyBlbmFibGVkLCBkbyBpdFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNuYXBwYWJsZSkge1xuICAgICAgICAgICAgdmFyIGZha2VEcmFnRXZlbnQgPSBlO1xuICAgICAgICAgICAgZmFrZURyYWdFdmVudC50YXJnZXQgPSB0aGlzLl9oaW50TWFya2VyO1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlU25hcHBpbmcoZmFrZURyYWdFdmVudCk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9EcmF3L0wuUE0uRHJhdy5NYXJrZXIuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _LPM = __webpack_require__(1);\n\nvar _LPM2 = _interopRequireDefault(_LPM);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_LPM2.default.Poly = _LPM2.default.Line.extend({\n    initialize: function initialize(map) {\n        this._map = map;\n        this._shape = 'Poly';\n        this.toolbarButtonName = 'drawPolygon';\n    },\n    _finishShape: function _finishShape() {\n        // get coordinates, create the leaflet shape and add it to the map\n        var coords = this._layer.getLatLngs();\n        var polygonLayer = L.polygon(coords, this.options.pathOptions).addTo(this._map);\n\n        // disable drawing\n        this.disable();\n\n        // fire the pm:create event and pass shape and layer\n        this._map.fire('pm:create', {\n            shape: this._shape,\n            layer: polygonLayer\n        });\n\n        // clean up snapping states\n        this._cleanupSnapping();\n\n        // remove the first vertex from \"other snapping layers\"\n        this._otherSnapLayers.splice(this._tempSnapLayerIndex, 1);\n        delete this._tempSnapLayerIndex;\n    },\n    _createMarker: function _createMarker(latlng, first) {\n        // create the new marker\n        var marker = new L.Marker(latlng, {\n            draggable: false,\n            icon: L.divIcon({ className: 'marker-icon' })\n        });\n\n        // mark this marker as temporary\n        marker._pmTempLayer = true;\n\n        // add it to the map\n        this._layerGroup.addLayer(marker);\n\n        // if the first marker gets clicked again, finish this shape\n        if (first) {\n            marker.on('click', this._finishShape, this);\n\n            // add the first vertex to \"other snapping layers\" so the polygon is easier to finish\n            this._tempSnapLayerIndex = this._otherSnapLayers.push(marker) - 1;\n\n            if (this.options.snappable) {\n                this._cleanupSnapping();\n            }\n        }\n    }\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNi5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9EcmF3L0wuUE0uRHJhdy5Qb2x5LmpzPzBkYWMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX0xQTSA9IHJlcXVpcmUoJy4vTC5QTS5EcmF3Jyk7XG5cbnZhciBfTFBNMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xQTSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbl9MUE0yLmRlZmF1bHQuUG9seSA9IF9MUE0yLmRlZmF1bHQuTGluZS5leHRlbmQoe1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIGluaXRpYWxpemUobWFwKSB7XG4gICAgICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICAgICAgdGhpcy5fc2hhcGUgPSAnUG9seSc7XG4gICAgICAgIHRoaXMudG9vbGJhckJ1dHRvbk5hbWUgPSAnZHJhd1BvbHlnb24nO1xuICAgIH0sXG4gICAgX2ZpbmlzaFNoYXBlOiBmdW5jdGlvbiBfZmluaXNoU2hhcGUoKSB7XG4gICAgICAgIC8vIGdldCBjb29yZGluYXRlcywgY3JlYXRlIHRoZSBsZWFmbGV0IHNoYXBlIGFuZCBhZGQgaXQgdG8gdGhlIG1hcFxuICAgICAgICB2YXIgY29vcmRzID0gdGhpcy5fbGF5ZXIuZ2V0TGF0TG5ncygpO1xuICAgICAgICB2YXIgcG9seWdvbkxheWVyID0gTC5wb2x5Z29uKGNvb3JkcywgdGhpcy5vcHRpb25zLnBhdGhPcHRpb25zKS5hZGRUbyh0aGlzLl9tYXApO1xuXG4gICAgICAgIC8vIGRpc2FibGUgZHJhd2luZ1xuICAgICAgICB0aGlzLmRpc2FibGUoKTtcblxuICAgICAgICAvLyBmaXJlIHRoZSBwbTpjcmVhdGUgZXZlbnQgYW5kIHBhc3Mgc2hhcGUgYW5kIGxheWVyXG4gICAgICAgIHRoaXMuX21hcC5maXJlKCdwbTpjcmVhdGUnLCB7XG4gICAgICAgICAgICBzaGFwZTogdGhpcy5fc2hhcGUsXG4gICAgICAgICAgICBsYXllcjogcG9seWdvbkxheWVyXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNsZWFuIHVwIHNuYXBwaW5nIHN0YXRlc1xuICAgICAgICB0aGlzLl9jbGVhbnVwU25hcHBpbmcoKTtcblxuICAgICAgICAvLyByZW1vdmUgdGhlIGZpcnN0IHZlcnRleCBmcm9tIFwib3RoZXIgc25hcHBpbmcgbGF5ZXJzXCJcbiAgICAgICAgdGhpcy5fb3RoZXJTbmFwTGF5ZXJzLnNwbGljZSh0aGlzLl90ZW1wU25hcExheWVySW5kZXgsIDEpO1xuICAgICAgICBkZWxldGUgdGhpcy5fdGVtcFNuYXBMYXllckluZGV4O1xuICAgIH0sXG4gICAgX2NyZWF0ZU1hcmtlcjogZnVuY3Rpb24gX2NyZWF0ZU1hcmtlcihsYXRsbmcsIGZpcnN0KSB7XG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgbmV3IG1hcmtlclxuICAgICAgICB2YXIgbWFya2VyID0gbmV3IEwuTWFya2VyKGxhdGxuZywge1xuICAgICAgICAgICAgZHJhZ2dhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGljb246IEwuZGl2SWNvbih7IGNsYXNzTmFtZTogJ21hcmtlci1pY29uJyB9KVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBtYXJrIHRoaXMgbWFya2VyIGFzIHRlbXBvcmFyeVxuICAgICAgICBtYXJrZXIuX3BtVGVtcExheWVyID0gdHJ1ZTtcblxuICAgICAgICAvLyBhZGQgaXQgdG8gdGhlIG1hcFxuICAgICAgICB0aGlzLl9sYXllckdyb3VwLmFkZExheWVyKG1hcmtlcik7XG5cbiAgICAgICAgLy8gaWYgdGhlIGZpcnN0IG1hcmtlciBnZXRzIGNsaWNrZWQgYWdhaW4sIGZpbmlzaCB0aGlzIHNoYXBlXG4gICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgbWFya2VyLm9uKCdjbGljaycsIHRoaXMuX2ZpbmlzaFNoYXBlLCB0aGlzKTtcblxuICAgICAgICAgICAgLy8gYWRkIHRoZSBmaXJzdCB2ZXJ0ZXggdG8gXCJvdGhlciBzbmFwcGluZyBsYXllcnNcIiBzbyB0aGUgcG9seWdvbiBpcyBlYXNpZXIgdG8gZmluaXNoXG4gICAgICAgICAgICB0aGlzLl90ZW1wU25hcExheWVySW5kZXggPSB0aGlzLl9vdGhlclNuYXBMYXllcnMucHVzaChtYXJrZXIpIC0gMTtcblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zbmFwcGFibGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGVhbnVwU25hcHBpbmcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL0RyYXcvTC5QTS5EcmF3LlBvbHkuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _LPM = __webpack_require__(0);\n\nvar _LPM2 = _interopRequireDefault(_LPM);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_LPM2.default.Circle = _LPM2.default.extend({\n    initialize: function initialize(layer) {\n        this._layer = layer;\n        this._enabled = false;\n    },\n    toggleEdit: function toggleEdit(options) {\n        if (!this.enabled()) {\n            this.enable(options);\n        } else {\n            this.disable();\n        }\n    },\n    enabled: function enabled() {\n        return this._enabled;\n    },\n    enable: function enable() {\n        var _this = this;\n\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        this.options = options;\n\n        this._map = this._layer._map;\n\n        if (!this.enabled()) {\n            // if it was already enabled, disable first\n            // we don't block enabling again because new options might be passed\n            this.disable();\n        }\n\n        // change state\n        this._enabled = true;\n\n        // // init markers\n        this._initMarkers();\n\n        // if polygon gets removed from map, disable edit mode\n        this._layer.on('remove', function (e) {\n            _this.disable(e.target);\n        });\n    },\n    disable: function disable() {\n        var layer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._layer;\n\n        // if it's not enabled, it doesn't need to be disabled\n        if (!this.enabled()) {\n            return false;\n        }\n\n        // prevent disabling if layer is being dragged\n        if (layer.pm._dragging) {\n            return false;\n        }\n        layer.pm._enabled = false;\n        layer.pm._layerGroup.clearLayers();\n\n        // clean up draggable\n        layer.off('mousedown');\n        layer.off('mouseup');\n\n        // remove draggable class\n        var el = layer._path;\n        L.DomUtil.removeClass(el, 'leaflet-pm-draggable');\n\n        return true;\n    },\n    _initMarkers: function _initMarkers() {\n        var map = this._map;\n\n        // cleanup old ones first\n        if (this._layerGroup) {\n            this._layerGroup.clearLayers();\n        }\n\n        // add markerGroup to map, markerGroup includes regular and middle markers\n        this._layerGroup = new L.LayerGroup();\n        map.addLayer(this._layerGroup);\n\n        // create marker for each coordinate\n        var center = this._layer.getLatLng();\n        var radius = this._layer._radius;\n\n        var outer = this._getLatLngOnCircle(center, radius);\n\n        this._centerMarker = this._createCenterMarker(center);\n        this._outerMarker = this._createOuterMarker(outer);\n        this._markers = [this._centerMarker, this._outerMarker];\n        this._createHintLine(this._centerMarker, this._outerMarker);\n\n        if (this.options.snappable) {\n            this._initSnappableMarkers();\n        }\n    },\n    _getLatLngOnCircle: function _getLatLngOnCircle(center, radius) {\n        var pointA = this._map.project(center);\n        var pointB = L.point(pointA.x + radius, pointA.y);\n\n        return this._map.unproject(pointB);\n    },\n    _resizeCircle: function _resizeCircle() {\n        this._syncHintLine();\n        this._syncCircleRadius();\n    },\n    _moveCircle: function _moveCircle(e) {\n        var center = e.latlng;\n        this._layer.setLatLng(center);\n\n        var radius = this._layer._radius;\n\n        var outer = this._getLatLngOnCircle(center, radius);\n        this._outerMarker.setLatLng(outer);\n        this._syncHintLine();\n    },\n    _syncCircleRadius: function _syncCircleRadius() {\n        var A = this._centerMarker.getLatLng();\n        var B = this._outerMarker.getLatLng();\n\n        var distance = A.distanceTo(B);\n\n        this._layer.setRadius(distance);\n    },\n    _syncHintLine: function _syncHintLine() {\n        var A = this._centerMarker.getLatLng();\n        var B = this._outerMarker.getLatLng();\n\n        // set coords for hintline from marker to last vertex of drawin polyline\n        this._hintline.setLatLngs([A, B]);\n    },\n    _createHintLine: function _createHintLine(markerA, markerB) {\n        var A = markerA.getLatLng();\n        var B = markerB.getLatLng();\n        this._hintline = L.polyline([A, B], this.options.hintlineStyle);\n        this._hintline._pmTempLayer = true;\n        this._layerGroup.addLayer(this._hintline);\n    },\n    _createCenterMarker: function _createCenterMarker(latlng) {\n        var marker = this._createMarker(latlng);\n\n        // marker.on('dragstart', this._onMarkerDragStart, this);\n        marker.on('move', this._moveCircle, this);\n        // marker.on('dragend', this._onMarkerDragEnd, this);\n        // marker.on('contextmenu', this._removeMarker, this);\n\n        return marker;\n    },\n    _createOuterMarker: function _createOuterMarker(latlng) {\n        var marker = this._createMarker(latlng);\n\n        // marker.on('dragstart', this._onMarkerDragStart, this);\n        marker.on('move', this._resizeCircle, this);\n        // marker.on('dragend', this._onMarkerDragEnd, this);\n        // marker.on('contextmenu', this._removeMarker, this);\n\n        return marker;\n    },\n    _createMarker: function _createMarker(latlng) {\n        var marker = new L.Marker(latlng, {\n            draggable: true,\n            icon: L.divIcon({ className: 'marker-icon' })\n        });\n\n        marker._origLatLng = latlng;\n        marker._pmTempLayer = true;\n\n        this._layerGroup.addLayer(marker);\n\n        return marker;\n    }\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9FZGl0L0wuUE0uRWRpdC5DaXJjbGUuanM/NTA0NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBfTFBNID0gcmVxdWlyZSgnLi9MLlBNLkVkaXQnKTtcblxudmFyIF9MUE0yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTFBNKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuX0xQTTIuZGVmYXVsdC5DaXJjbGUgPSBfTFBNMi5kZWZhdWx0LmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZShsYXllcikge1xuICAgICAgICB0aGlzLl9sYXllciA9IGxheWVyO1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XG4gICAgfSxcbiAgICB0b2dnbGVFZGl0OiBmdW5jdGlvbiB0b2dnbGVFZGl0KG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGUob3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZW5hYmxlZDogZnVuY3Rpb24gZW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuYWJsZWQ7XG4gICAgfSxcbiAgICBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgICAgICB0aGlzLl9tYXAgPSB0aGlzLl9sYXllci5fbWFwO1xuXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKCkpIHtcbiAgICAgICAgICAgIC8vIGlmIGl0IHdhcyBhbHJlYWR5IGVuYWJsZWQsIGRpc2FibGUgZmlyc3RcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IGJsb2NrIGVuYWJsaW5nIGFnYWluIGJlY2F1c2UgbmV3IG9wdGlvbnMgbWlnaHQgYmUgcGFzc2VkXG4gICAgICAgICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoYW5nZSBzdGF0ZVxuICAgICAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICAvLyAvLyBpbml0IG1hcmtlcnNcbiAgICAgICAgdGhpcy5faW5pdE1hcmtlcnMoKTtcblxuICAgICAgICAvLyBpZiBwb2x5Z29uIGdldHMgcmVtb3ZlZCBmcm9tIG1hcCwgZGlzYWJsZSBlZGl0IG1vZGVcbiAgICAgICAgdGhpcy5fbGF5ZXIub24oJ3JlbW92ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBfdGhpcy5kaXNhYmxlKGUudGFyZ2V0KTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBkaXNhYmxlOiBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgICAgICB2YXIgbGF5ZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMuX2xheWVyO1xuXG4gICAgICAgIC8vIGlmIGl0J3Mgbm90IGVuYWJsZWQsIGl0IGRvZXNuJ3QgbmVlZCB0byBiZSBkaXNhYmxlZFxuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBwcmV2ZW50IGRpc2FibGluZyBpZiBsYXllciBpcyBiZWluZyBkcmFnZ2VkXG4gICAgICAgIGlmIChsYXllci5wbS5fZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBsYXllci5wbS5fZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICBsYXllci5wbS5fbGF5ZXJHcm91cC5jbGVhckxheWVycygpO1xuXG4gICAgICAgIC8vIGNsZWFuIHVwIGRyYWdnYWJsZVxuICAgICAgICBsYXllci5vZmYoJ21vdXNlZG93bicpO1xuICAgICAgICBsYXllci5vZmYoJ21vdXNldXAnKTtcblxuICAgICAgICAvLyByZW1vdmUgZHJhZ2dhYmxlIGNsYXNzXG4gICAgICAgIHZhciBlbCA9IGxheWVyLl9wYXRoO1xuICAgICAgICBMLkRvbVV0aWwucmVtb3ZlQ2xhc3MoZWwsICdsZWFmbGV0LXBtLWRyYWdnYWJsZScpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgX2luaXRNYXJrZXJzOiBmdW5jdGlvbiBfaW5pdE1hcmtlcnMoKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cbiAgICAgICAgLy8gY2xlYW51cCBvbGQgb25lcyBmaXJzdFxuICAgICAgICBpZiAodGhpcy5fbGF5ZXJHcm91cCkge1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXJHcm91cC5jbGVhckxheWVycygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIG1hcmtlckdyb3VwIHRvIG1hcCwgbWFya2VyR3JvdXAgaW5jbHVkZXMgcmVndWxhciBhbmQgbWlkZGxlIG1hcmtlcnNcbiAgICAgICAgdGhpcy5fbGF5ZXJHcm91cCA9IG5ldyBMLkxheWVyR3JvdXAoKTtcbiAgICAgICAgbWFwLmFkZExheWVyKHRoaXMuX2xheWVyR3JvdXApO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBtYXJrZXIgZm9yIGVhY2ggY29vcmRpbmF0ZVxuICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5fbGF5ZXIuZ2V0TGF0TG5nKCk7XG4gICAgICAgIHZhciByYWRpdXMgPSB0aGlzLl9sYXllci5fcmFkaXVzO1xuXG4gICAgICAgIHZhciBvdXRlciA9IHRoaXMuX2dldExhdExuZ09uQ2lyY2xlKGNlbnRlciwgcmFkaXVzKTtcblxuICAgICAgICB0aGlzLl9jZW50ZXJNYXJrZXIgPSB0aGlzLl9jcmVhdGVDZW50ZXJNYXJrZXIoY2VudGVyKTtcbiAgICAgICAgdGhpcy5fb3V0ZXJNYXJrZXIgPSB0aGlzLl9jcmVhdGVPdXRlck1hcmtlcihvdXRlcik7XG4gICAgICAgIHRoaXMuX21hcmtlcnMgPSBbdGhpcy5fY2VudGVyTWFya2VyLCB0aGlzLl9vdXRlck1hcmtlcl07XG4gICAgICAgIHRoaXMuX2NyZWF0ZUhpbnRMaW5lKHRoaXMuX2NlbnRlck1hcmtlciwgdGhpcy5fb3V0ZXJNYXJrZXIpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc25hcHBhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9pbml0U25hcHBhYmxlTWFya2VycygpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBfZ2V0TGF0TG5nT25DaXJjbGU6IGZ1bmN0aW9uIF9nZXRMYXRMbmdPbkNpcmNsZShjZW50ZXIsIHJhZGl1cykge1xuICAgICAgICB2YXIgcG9pbnRBID0gdGhpcy5fbWFwLnByb2plY3QoY2VudGVyKTtcbiAgICAgICAgdmFyIHBvaW50QiA9IEwucG9pbnQocG9pbnRBLnggKyByYWRpdXMsIHBvaW50QS55KTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLnVucHJvamVjdChwb2ludEIpO1xuICAgIH0sXG4gICAgX3Jlc2l6ZUNpcmNsZTogZnVuY3Rpb24gX3Jlc2l6ZUNpcmNsZSgpIHtcbiAgICAgICAgdGhpcy5fc3luY0hpbnRMaW5lKCk7XG4gICAgICAgIHRoaXMuX3N5bmNDaXJjbGVSYWRpdXMoKTtcbiAgICB9LFxuICAgIF9tb3ZlQ2lyY2xlOiBmdW5jdGlvbiBfbW92ZUNpcmNsZShlKSB7XG4gICAgICAgIHZhciBjZW50ZXIgPSBlLmxhdGxuZztcbiAgICAgICAgdGhpcy5fbGF5ZXIuc2V0TGF0TG5nKGNlbnRlcik7XG5cbiAgICAgICAgdmFyIHJhZGl1cyA9IHRoaXMuX2xheWVyLl9yYWRpdXM7XG5cbiAgICAgICAgdmFyIG91dGVyID0gdGhpcy5fZ2V0TGF0TG5nT25DaXJjbGUoY2VudGVyLCByYWRpdXMpO1xuICAgICAgICB0aGlzLl9vdXRlck1hcmtlci5zZXRMYXRMbmcob3V0ZXIpO1xuICAgICAgICB0aGlzLl9zeW5jSGludExpbmUoKTtcbiAgICB9LFxuICAgIF9zeW5jQ2lyY2xlUmFkaXVzOiBmdW5jdGlvbiBfc3luY0NpcmNsZVJhZGl1cygpIHtcbiAgICAgICAgdmFyIEEgPSB0aGlzLl9jZW50ZXJNYXJrZXIuZ2V0TGF0TG5nKCk7XG4gICAgICAgIHZhciBCID0gdGhpcy5fb3V0ZXJNYXJrZXIuZ2V0TGF0TG5nKCk7XG5cbiAgICAgICAgdmFyIGRpc3RhbmNlID0gQS5kaXN0YW5jZVRvKEIpO1xuXG4gICAgICAgIHRoaXMuX2xheWVyLnNldFJhZGl1cyhkaXN0YW5jZSk7XG4gICAgfSxcbiAgICBfc3luY0hpbnRMaW5lOiBmdW5jdGlvbiBfc3luY0hpbnRMaW5lKCkge1xuICAgICAgICB2YXIgQSA9IHRoaXMuX2NlbnRlck1hcmtlci5nZXRMYXRMbmcoKTtcbiAgICAgICAgdmFyIEIgPSB0aGlzLl9vdXRlck1hcmtlci5nZXRMYXRMbmcoKTtcblxuICAgICAgICAvLyBzZXQgY29vcmRzIGZvciBoaW50bGluZSBmcm9tIG1hcmtlciB0byBsYXN0IHZlcnRleCBvZiBkcmF3aW4gcG9seWxpbmVcbiAgICAgICAgdGhpcy5faGludGxpbmUuc2V0TGF0TG5ncyhbQSwgQl0pO1xuICAgIH0sXG4gICAgX2NyZWF0ZUhpbnRMaW5lOiBmdW5jdGlvbiBfY3JlYXRlSGludExpbmUobWFya2VyQSwgbWFya2VyQikge1xuICAgICAgICB2YXIgQSA9IG1hcmtlckEuZ2V0TGF0TG5nKCk7XG4gICAgICAgIHZhciBCID0gbWFya2VyQi5nZXRMYXRMbmcoKTtcbiAgICAgICAgdGhpcy5faGludGxpbmUgPSBMLnBvbHlsaW5lKFtBLCBCXSwgdGhpcy5vcHRpb25zLmhpbnRsaW5lU3R5bGUpO1xuICAgICAgICB0aGlzLl9oaW50bGluZS5fcG1UZW1wTGF5ZXIgPSB0cnVlO1xuICAgICAgICB0aGlzLl9sYXllckdyb3VwLmFkZExheWVyKHRoaXMuX2hpbnRsaW5lKTtcbiAgICB9LFxuICAgIF9jcmVhdGVDZW50ZXJNYXJrZXI6IGZ1bmN0aW9uIF9jcmVhdGVDZW50ZXJNYXJrZXIobGF0bG5nKSB7XG4gICAgICAgIHZhciBtYXJrZXIgPSB0aGlzLl9jcmVhdGVNYXJrZXIobGF0bG5nKTtcblxuICAgICAgICAvLyBtYXJrZXIub24oJ2RyYWdzdGFydCcsIHRoaXMuX29uTWFya2VyRHJhZ1N0YXJ0LCB0aGlzKTtcbiAgICAgICAgbWFya2VyLm9uKCdtb3ZlJywgdGhpcy5fbW92ZUNpcmNsZSwgdGhpcyk7XG4gICAgICAgIC8vIG1hcmtlci5vbignZHJhZ2VuZCcsIHRoaXMuX29uTWFya2VyRHJhZ0VuZCwgdGhpcyk7XG4gICAgICAgIC8vIG1hcmtlci5vbignY29udGV4dG1lbnUnLCB0aGlzLl9yZW1vdmVNYXJrZXIsIHRoaXMpO1xuXG4gICAgICAgIHJldHVybiBtYXJrZXI7XG4gICAgfSxcbiAgICBfY3JlYXRlT3V0ZXJNYXJrZXI6IGZ1bmN0aW9uIF9jcmVhdGVPdXRlck1hcmtlcihsYXRsbmcpIHtcbiAgICAgICAgdmFyIG1hcmtlciA9IHRoaXMuX2NyZWF0ZU1hcmtlcihsYXRsbmcpO1xuXG4gICAgICAgIC8vIG1hcmtlci5vbignZHJhZ3N0YXJ0JywgdGhpcy5fb25NYXJrZXJEcmFnU3RhcnQsIHRoaXMpO1xuICAgICAgICBtYXJrZXIub24oJ21vdmUnLCB0aGlzLl9yZXNpemVDaXJjbGUsIHRoaXMpO1xuICAgICAgICAvLyBtYXJrZXIub24oJ2RyYWdlbmQnLCB0aGlzLl9vbk1hcmtlckRyYWdFbmQsIHRoaXMpO1xuICAgICAgICAvLyBtYXJrZXIub24oJ2NvbnRleHRtZW51JywgdGhpcy5fcmVtb3ZlTWFya2VyLCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gbWFya2VyO1xuICAgIH0sXG4gICAgX2NyZWF0ZU1hcmtlcjogZnVuY3Rpb24gX2NyZWF0ZU1hcmtlcihsYXRsbmcpIHtcbiAgICAgICAgdmFyIG1hcmtlciA9IG5ldyBMLk1hcmtlcihsYXRsbmcsIHtcbiAgICAgICAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGljb246IEwuZGl2SWNvbih7IGNsYXNzTmFtZTogJ21hcmtlci1pY29uJyB9KVxuICAgICAgICB9KTtcblxuICAgICAgICBtYXJrZXIuX29yaWdMYXRMbmcgPSBsYXRsbmc7XG4gICAgICAgIG1hcmtlci5fcG1UZW1wTGF5ZXIgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX2xheWVyR3JvdXAuYWRkTGF5ZXIobWFya2VyKTtcblxuICAgICAgICByZXR1cm4gbWFya2VyO1xuICAgIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL0VkaXQvTC5QTS5FZGl0LkNpcmNsZS5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _LPM = __webpack_require__(0);\n\nvar _LPM2 = _interopRequireDefault(_LPM);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// LayerGroup doesn't inherit from L.PM.Edit because it's just calling L.PM.Edit.Poly\n// (which inherits from L.PM.Edit) for each layer,\n// so it's not really a parent class\n_LPM2.default.LayerGroup = L.Class.extend({\n    initialize: function initialize(layerGroup) {\n        var _this = this;\n\n        this._layerGroup = layerGroup;\n        this._layers = this.findLayers();\n\n        // init all layers of the group\n        this._layers.forEach(function (layer) {\n            return _this._initLayer(layer);\n        });\n\n        // if a new layer is added to the group, reinitialize\n        // This only works for FeatureGroups, not LayerGroups\n        // https://github.com/Leaflet/Leaflet/issues/4861\n        this._layerGroup.on('layeradd', function (e) {\n            _this._layers = _this.findLayers();\n\n            // init the newly added layer\n            if (e.layer.pm) {\n                _this._initLayer(e.layer);\n            }\n\n            // if editing was already enabled for this group, enable it again\n            // so the new layers are enabled\n            if (e.target.pm.enabled()) {\n                _this.enable(_this.getOptions());\n            }\n        });\n    },\n    findLayers: function findLayers() {\n        // get all layers of the layer group\n        var layers = this._layerGroup.getLayers();\n\n        // filter out layers that don't have leaflet.pm\n        layers = layers.filter(function (layer) {\n            return !!layer.pm;\n        });\n\n        // return them\n        return layers;\n    },\n    _initLayer: function _initLayer(layer) {\n        var _this2 = this;\n\n        // available events\n        var availableEvents = ['pm:edit', 'pm:remove', 'pm:dragstart', 'pm:drag', 'pm:dragend', 'pm:snap', 'pm:unsnap', 'pm:raiseMarkers', 'pm:markerdragend', 'pm:markerdragstart'];\n\n        // listen to the events of the layers in this group\n        availableEvents.forEach(function (event) {\n            layer.on(event, _this2._fireEvent, _this2);\n        });\n\n        // add reference for the group to each layer inside said group\n        layer.pm._layerGroup = this._layerGroup;\n    },\n    _fireEvent: function _fireEvent(e) {\n        this._layerGroup.fireEvent(e.type, e);\n    },\n    toggleEdit: function toggleEdit(options) {\n        this._options = options;\n        this._layers.forEach(function (layer) {\n            layer.pm.toggleEdit(options);\n        });\n    },\n    enable: function enable(options) {\n        this._options = options;\n        this._layers.forEach(function (layer) {\n            layer.pm.enable(options);\n        });\n    },\n    disable: function disable() {\n        this._layers.forEach(function (layer) {\n            layer.pm.disable();\n        });\n    },\n    enabled: function enabled() {\n        var enabled = this._layers.find(function (layer) {\n            return layer.pm.enabled();\n        });\n        return !!enabled;\n    },\n    dragging: function dragging() {\n        var dragging = this._layers.find(function (layer) {\n            return layer.pm.dragging();\n        });\n        return !!dragging;\n    },\n    getOptions: function getOptions() {\n        return this._options;\n    }\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9FZGl0L0wuUE0uRWRpdC5MYXllckdyb3VwLmpzPzJjZDAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX0xQTSA9IHJlcXVpcmUoJy4vTC5QTS5FZGl0Jyk7XG5cbnZhciBfTFBNMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xQTSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8vIExheWVyR3JvdXAgZG9lc24ndCBpbmhlcml0IGZyb20gTC5QTS5FZGl0IGJlY2F1c2UgaXQncyBqdXN0IGNhbGxpbmcgTC5QTS5FZGl0LlBvbHlcbi8vICh3aGljaCBpbmhlcml0cyBmcm9tIEwuUE0uRWRpdCkgZm9yIGVhY2ggbGF5ZXIsXG4vLyBzbyBpdCdzIG5vdCByZWFsbHkgYSBwYXJlbnQgY2xhc3Ncbl9MUE0yLmRlZmF1bHQuTGF5ZXJHcm91cCA9IEwuQ2xhc3MuZXh0ZW5kKHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBpbml0aWFsaXplKGxheWVyR3JvdXApIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB0aGlzLl9sYXllckdyb3VwID0gbGF5ZXJHcm91cDtcbiAgICAgICAgdGhpcy5fbGF5ZXJzID0gdGhpcy5maW5kTGF5ZXJzKCk7XG5cbiAgICAgICAgLy8gaW5pdCBhbGwgbGF5ZXJzIG9mIHRoZSBncm91cFxuICAgICAgICB0aGlzLl9sYXllcnMuZm9yRWFjaChmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5faW5pdExheWVyKGxheWVyKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaWYgYSBuZXcgbGF5ZXIgaXMgYWRkZWQgdG8gdGhlIGdyb3VwLCByZWluaXRpYWxpemVcbiAgICAgICAgLy8gVGhpcyBvbmx5IHdvcmtzIGZvciBGZWF0dXJlR3JvdXBzLCBub3QgTGF5ZXJHcm91cHNcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvNDg2MVxuICAgICAgICB0aGlzLl9sYXllckdyb3VwLm9uKCdsYXllcmFkZCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBfdGhpcy5fbGF5ZXJzID0gX3RoaXMuZmluZExheWVycygpO1xuXG4gICAgICAgICAgICAvLyBpbml0IHRoZSBuZXdseSBhZGRlZCBsYXllclxuICAgICAgICAgICAgaWYgKGUubGF5ZXIucG0pIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5faW5pdExheWVyKGUubGF5ZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiBlZGl0aW5nIHdhcyBhbHJlYWR5IGVuYWJsZWQgZm9yIHRoaXMgZ3JvdXAsIGVuYWJsZSBpdCBhZ2FpblxuICAgICAgICAgICAgLy8gc28gdGhlIG5ldyBsYXllcnMgYXJlIGVuYWJsZWRcbiAgICAgICAgICAgIGlmIChlLnRhcmdldC5wbS5lbmFibGVkKCkpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbmFibGUoX3RoaXMuZ2V0T3B0aW9ucygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBmaW5kTGF5ZXJzOiBmdW5jdGlvbiBmaW5kTGF5ZXJzKCkge1xuICAgICAgICAvLyBnZXQgYWxsIGxheWVycyBvZiB0aGUgbGF5ZXIgZ3JvdXBcbiAgICAgICAgdmFyIGxheWVycyA9IHRoaXMuX2xheWVyR3JvdXAuZ2V0TGF5ZXJzKCk7XG5cbiAgICAgICAgLy8gZmlsdGVyIG91dCBsYXllcnMgdGhhdCBkb24ndCBoYXZlIGxlYWZsZXQucG1cbiAgICAgICAgbGF5ZXJzID0gbGF5ZXJzLmZpbHRlcihmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAhIWxheWVyLnBtO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyByZXR1cm4gdGhlbVxuICAgICAgICByZXR1cm4gbGF5ZXJzO1xuICAgIH0sXG4gICAgX2luaXRMYXllcjogZnVuY3Rpb24gX2luaXRMYXllcihsYXllcikge1xuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgICAvLyBhdmFpbGFibGUgZXZlbnRzXG4gICAgICAgIHZhciBhdmFpbGFibGVFdmVudHMgPSBbJ3BtOmVkaXQnLCAncG06cmVtb3ZlJywgJ3BtOmRyYWdzdGFydCcsICdwbTpkcmFnJywgJ3BtOmRyYWdlbmQnLCAncG06c25hcCcsICdwbTp1bnNuYXAnLCAncG06cmFpc2VNYXJrZXJzJywgJ3BtOm1hcmtlcmRyYWdlbmQnLCAncG06bWFya2VyZHJhZ3N0YXJ0J107XG5cbiAgICAgICAgLy8gbGlzdGVuIHRvIHRoZSBldmVudHMgb2YgdGhlIGxheWVycyBpbiB0aGlzIGdyb3VwXG4gICAgICAgIGF2YWlsYWJsZUV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgbGF5ZXIub24oZXZlbnQsIF90aGlzMi5fZmlyZUV2ZW50LCBfdGhpczIpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBhZGQgcmVmZXJlbmNlIGZvciB0aGUgZ3JvdXAgdG8gZWFjaCBsYXllciBpbnNpZGUgc2FpZCBncm91cFxuICAgICAgICBsYXllci5wbS5fbGF5ZXJHcm91cCA9IHRoaXMuX2xheWVyR3JvdXA7XG4gICAgfSxcbiAgICBfZmlyZUV2ZW50OiBmdW5jdGlvbiBfZmlyZUV2ZW50KGUpIHtcbiAgICAgICAgdGhpcy5fbGF5ZXJHcm91cC5maXJlRXZlbnQoZS50eXBlLCBlKTtcbiAgICB9LFxuICAgIHRvZ2dsZUVkaXQ6IGZ1bmN0aW9uIHRvZ2dsZUVkaXQob3B0aW9ucykge1xuICAgICAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5fbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICBsYXllci5wbS50b2dnbGVFZGl0KG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGVuYWJsZTogZnVuY3Rpb24gZW5hYmxlKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuX2xheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICAgICAgbGF5ZXIucG0uZW5hYmxlKG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGRpc2FibGU6IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgICAgIHRoaXMuX2xheWVycy5mb3JFYWNoKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICAgICAgbGF5ZXIucG0uZGlzYWJsZSgpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGVuYWJsZWQ6IGZ1bmN0aW9uIGVuYWJsZWQoKSB7XG4gICAgICAgIHZhciBlbmFibGVkID0gdGhpcy5fbGF5ZXJzLmZpbmQoZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbGF5ZXIucG0uZW5hYmxlZCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICEhZW5hYmxlZDtcbiAgICB9LFxuICAgIGRyYWdnaW5nOiBmdW5jdGlvbiBkcmFnZ2luZygpIHtcbiAgICAgICAgdmFyIGRyYWdnaW5nID0gdGhpcy5fbGF5ZXJzLmZpbmQoZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbGF5ZXIucG0uZHJhZ2dpbmcoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAhIWRyYWdnaW5nO1xuICAgIH0sXG4gICAgZ2V0T3B0aW9uczogZnVuY3Rpb24gZ2V0T3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnM7XG4gICAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvRWRpdC9MLlBNLkVkaXQuTGF5ZXJHcm91cC5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _LPM = __webpack_require__(0);\n\nvar _LPM2 = _interopRequireDefault(_LPM);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_LPM2.default.Line = _LPM2.default.extend({\n    initialize: function initialize(layer) {\n        this._layer = layer;\n        this._enabled = false;\n    },\n    toggleEdit: function toggleEdit(options) {\n        if (!this.enabled()) {\n            this.enable(options);\n        } else {\n            this.disable();\n        }\n    },\n    enable: function enable() {\n        var _this = this;\n\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n        this.options = options;\n\n        this._map = this._layer._map;\n\n        // cancel when map isn't available, this happens when the polygon is removed before this fires\n        if (!this._map) {\n            return;\n        }\n\n        if (!this.enabled()) {\n            // if it was already enabled, disable first\n            // we don't block enabling again because new options might be passed\n            this.disable();\n        }\n\n        // change state\n        this._enabled = true;\n\n        // init markers\n        this._initMarkers();\n\n        // if polygon gets removed from map, disable edit mode\n        this._layer.on('remove', function (e) {\n            _this.disable(e.target);\n        });\n\n        if (this.options.draggable) {\n            this._initDraggableLayer();\n        }\n    },\n    enabled: function enabled() {\n        return this._enabled;\n    },\n    disable: function disable() {\n        var poly = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._layer;\n\n        // if it's not enabled, it doesn't need to be disabled\n        if (!this.enabled()) {\n            return false;\n        }\n\n        // prevent disabling if polygon is being dragged\n        if (poly.pm._dragging) {\n            return false;\n        }\n        poly.pm._enabled = false;\n        poly.pm._markerGroup.clearLayers();\n\n        // clean up draggable\n        poly.off('mousedown');\n        poly.off('mouseup');\n\n        // remove draggable class\n        var el = poly._path;\n        L.DomUtil.removeClass(el, 'leaflet-pm-draggable');\n\n        return true;\n    },\n    _initMarkers: function _initMarkers() {\n        var map = this._map;\n\n        // cleanup old ones first\n        if (this._markerGroup) {\n            this._markerGroup.clearLayers();\n        }\n\n        // add markerGroup to map, markerGroup includes regular and middle markers\n        this._markerGroup = new L.LayerGroup();\n        map.addLayer(this._markerGroup);\n\n        // create marker for each coordinate\n        var coords = this._layer._latlngs;\n\n        // the marker array, it includes only the markers that're associated with the coordinates\n        this._markers = coords.map(this._createMarker, this);\n\n        // create small markers in the middle of the regular markers\n        for (var k = 0; k < coords.length - 1; k += 1) {\n            var nextIndex = k + 1;\n            this._createMiddleMarker(this._markers[k], this._markers[nextIndex]);\n        }\n\n        if (this.options.snappable) {\n            this._initSnappableMarkers();\n        }\n    },\n\n\n    // creates initial markers for coordinates\n    _createMarker: function _createMarker(latlng, index) {\n        var marker = new L.Marker(latlng, {\n            draggable: true,\n            icon: L.divIcon({ className: 'marker-icon' })\n        });\n\n        marker._origLatLng = latlng;\n        marker._index = index;\n        marker._pmTempLayer = true;\n\n        marker.on('dragstart', this._onMarkerDragStart, this);\n        marker.on('move', this._onMarkerDrag, this);\n        marker.on('dragend', this._onMarkerDragEnd, this);\n        marker.on('contextmenu', this._removeMarker, this);\n\n        this._markerGroup.addLayer(marker);\n\n        return marker;\n    },\n\n\n    // creates the middle markes between coordinates\n    _createMiddleMarker: function _createMiddleMarker(leftM, rightM) {\n        var _this2 = this;\n\n        var latlng = this._calcMiddleLatLng(leftM.getLatLng(), rightM.getLatLng());\n\n        var middleMarker = this._createMarker(latlng);\n        var middleIcon = L.divIcon({ className: 'marker-icon marker-icon-middle' });\n        middleMarker.setIcon(middleIcon);\n\n        // save reference to this middle markers on the neighboor regular markers\n        leftM._middleMarkerNext = middleMarker;\n        rightM._middleMarkerPrev = middleMarker;\n\n        middleMarker.on('click', function () {\n            // TODO: move the next two lines inside _addMarker() as soon as\n            // https://github.com/Leaflet/Leaflet/issues/4484\n            // is fixed\n            var icon = L.divIcon({ className: 'marker-icon' });\n            middleMarker.setIcon(icon);\n\n            _this2._addMarker(middleMarker, leftM, rightM);\n        });\n        middleMarker.on('movestart', function () {\n            // TODO: This is a workaround. Remove the moveend listener and\n            // callback as soon as this is fixed:\n            // https://github.com/Leaflet/Leaflet/issues/4484\n            middleMarker.on('moveend', function () {\n                var icon = L.divIcon({ className: 'marker-icon' });\n                middleMarker.setIcon(icon);\n\n                middleMarker.off('moveend');\n            });\n\n            _this2._addMarker(middleMarker, leftM, rightM);\n        });\n    },\n\n\n    // adds a new marker from a middlemarker\n    _addMarker: function _addMarker(newM, leftM, rightM) {\n        // first, make this middlemarker a regular marker\n        newM.off('movestart');\n        newM.off('click');\n\n        // now, create the polygon coordinate point for that marker\n        var latlng = newM.getLatLng();\n        var coords = this._layer._latlngs;\n        var index = leftM._index + 1;\n\n        coords.splice(index, 0, latlng);\n\n        // associate polygon coordinate with marker coordinate\n        newM._origLatLng = coords[index];\n\n        // push into marker array & update the indexes for every marker\n        this._markers.splice(index, 0, newM);\n        this._markers.map(function (marker, i) {\n            marker._index = i;\n            return true;\n        });\n\n        // create the new middlemarkers\n        this._createMiddleMarker(leftM, newM);\n        this._createMiddleMarker(newM, rightM);\n\n        // fire edit event\n        this._fireEdit();\n\n        if (this.options.snappable) {\n            this._initSnappableMarkers();\n        }\n    },\n    _removeMarker: function _removeMarker(e) {\n        var marker = e.target;\n        var coords = this._layer._latlngs;\n        var index = marker._index;\n\n        // only continue if this is NOT a middle marker (those can't be deleted)\n        if (index === undefined) {\n            return;\n        }\n\n        // remove polygon coordinate from this marker\n        coords.splice(index, 1);\n\n        // if the poly has no coordinates left, remove the layer\n        // else, redraw it\n        if (coords.length < 1) {\n            this._layer.remove();\n        } else {\n            this._layer.redraw();\n        }\n\n        // remove the marker and the middlemarkers next to it from the map\n        if (marker._middleMarkerPrev) {\n            this._markerGroup.removeLayer(marker._middleMarkerPrev);\n        }\n        if (marker._middleMarkerNext) {\n            this._markerGroup.removeLayer(marker._middleMarkerNext);\n        }\n\n        this._markerGroup.removeLayer(marker);\n\n        // find neighbor marker-indexes\n        var leftMarkerIndex = index - 1 < 0 ? undefined : index - 1;\n        var rightMarkerIndex = index + 1 >= this._markers.length ? undefined : index + 1;\n\n        // don't create middlemarkers if there is only one marker left\n        // or if the middlemarker would be between the first and last coordinate of a polyline\n        if (rightMarkerIndex && leftMarkerIndex && rightMarkerIndex !== leftMarkerIndex) {\n            var leftM = this._markers[leftMarkerIndex];\n            var rightM = this._markers[rightMarkerIndex];\n            this._createMiddleMarker(leftM, rightM);\n        }\n\n        // remove the marker from the markers array & update indexes\n        this._markers.splice(index, 1);\n        this._markers.map(function (m, i) {\n            m._index = i;\n            return true;\n        });\n\n        // fire edit event\n        this._fireEdit();\n    },\n    _onMarkerDrag: function _onMarkerDrag(e) {\n        // dragged marker\n        var marker = e.target;\n\n        // only continue if this is NOT a middle marker (those can't be deleted)\n        if (marker._index === undefined) {\n            return;\n        }\n\n        // the dragged markers neighbors\n        var nextMarkerIndex = marker._index + 1 >= this._markers.length ? 0 : marker._index + 1;\n        var prevMarkerIndex = marker._index - 1 < 0 ? this._markers.length - 1 : marker._index - 1;\n\n        // update marker coordinates which will update polygon coordinates\n        L.extend(marker._origLatLng, marker._latlng);\n        this._layer.redraw();\n\n        // update middle markers on the left and right\n        // be aware that \"next\" and \"prev\" might be interchanged, depending on the geojson array\n        var markerLatLng = marker.getLatLng();\n        var prevMarkerLatLng = this._markers[prevMarkerIndex].getLatLng();\n        var nextMarkerLatLng = this._markers[nextMarkerIndex].getLatLng();\n\n        if (marker._middleMarkerNext) {\n            var middleMarkerNextLatLng = this._calcMiddleLatLng(markerLatLng, nextMarkerLatLng);\n            marker._middleMarkerNext.setLatLng(middleMarkerNextLatLng);\n        }\n\n        if (marker._middleMarkerPrev) {\n            var middleMarkerPrevLatLng = this._calcMiddleLatLng(markerLatLng, prevMarkerLatLng);\n            marker._middleMarkerPrev.setLatLng(middleMarkerPrevLatLng);\n        }\n    },\n    _onMarkerDragEnd: function _onMarkerDragEnd(e) {\n        this._layer.fire('pm:markerdragend', {\n            markerEvent: e\n        });\n\n        // fire edit event\n        this._fireEdit();\n    },\n    _onMarkerDragStart: function _onMarkerDragStart(e) {\n        this._layer.fire('pm:markerdragstart', {\n            markerEvent: e\n        });\n    },\n    _fireEdit: function _fireEdit() {\n        // fire edit event\n        this._layer.edited = true;\n        this._layer.fire('pm:edit');\n    },\n    _calcMiddleLatLng: function _calcMiddleLatLng(latlng1, latlng2) {\n        // calculate the middle coordinates between two markers\n        // TODO: put this into a utils.js or something\n\n        var map = this._map;\n        var p1 = map.project(latlng1);\n        var p2 = map.project(latlng2);\n\n        var latlng = map.unproject(p1._add(p2)._divideBy(2));\n\n        return latlng;\n    }\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiOS5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9FZGl0L0wuUE0uRWRpdC5MaW5lLmpzPzcwZjQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX0xQTSA9IHJlcXVpcmUoJy4vTC5QTS5FZGl0Jyk7XG5cbnZhciBfTFBNMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xQTSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbl9MUE0yLmRlZmF1bHQuTGluZSA9IF9MUE0yLmRlZmF1bHQuZXh0ZW5kKHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbiBpbml0aWFsaXplKGxheWVyKSB7XG4gICAgICAgIHRoaXMuX2xheWVyID0gbGF5ZXI7XG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcbiAgICB9LFxuICAgIHRvZ2dsZUVkaXQ6IGZ1bmN0aW9uIHRvZ2dsZUVkaXQob3B0aW9ucykge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZShvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGlzYWJsZSgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgICAgICB0aGlzLl9tYXAgPSB0aGlzLl9sYXllci5fbWFwO1xuXG4gICAgICAgIC8vIGNhbmNlbCB3aGVuIG1hcCBpc24ndCBhdmFpbGFibGUsIHRoaXMgaGFwcGVucyB3aGVuIHRoZSBwb2x5Z29uIGlzIHJlbW92ZWQgYmVmb3JlIHRoaXMgZmlyZXNcbiAgICAgICAgaWYgKCF0aGlzLl9tYXApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKCkpIHtcbiAgICAgICAgICAgIC8vIGlmIGl0IHdhcyBhbHJlYWR5IGVuYWJsZWQsIGRpc2FibGUgZmlyc3RcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IGJsb2NrIGVuYWJsaW5nIGFnYWluIGJlY2F1c2UgbmV3IG9wdGlvbnMgbWlnaHQgYmUgcGFzc2VkXG4gICAgICAgICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNoYW5nZSBzdGF0ZVxuICAgICAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICAvLyBpbml0IG1hcmtlcnNcbiAgICAgICAgdGhpcy5faW5pdE1hcmtlcnMoKTtcblxuICAgICAgICAvLyBpZiBwb2x5Z29uIGdldHMgcmVtb3ZlZCBmcm9tIG1hcCwgZGlzYWJsZSBlZGl0IG1vZGVcbiAgICAgICAgdGhpcy5fbGF5ZXIub24oJ3JlbW92ZScsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBfdGhpcy5kaXNhYmxlKGUudGFyZ2V0KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2luaXREcmFnZ2FibGVMYXllcigpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBlbmFibGVkOiBmdW5jdGlvbiBlbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5hYmxlZDtcbiAgICB9LFxuICAgIGRpc2FibGU6IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgICAgIHZhciBwb2x5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLl9sYXllcjtcblxuICAgICAgICAvLyBpZiBpdCdzIG5vdCBlbmFibGVkLCBpdCBkb2Vzbid0IG5lZWQgdG8gYmUgZGlzYWJsZWRcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcHJldmVudCBkaXNhYmxpbmcgaWYgcG9seWdvbiBpcyBiZWluZyBkcmFnZ2VkXG4gICAgICAgIGlmIChwb2x5LnBtLl9kcmFnZ2luZykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHBvbHkucG0uX2VuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgcG9seS5wbS5fbWFya2VyR3JvdXAuY2xlYXJMYXllcnMoKTtcblxuICAgICAgICAvLyBjbGVhbiB1cCBkcmFnZ2FibGVcbiAgICAgICAgcG9seS5vZmYoJ21vdXNlZG93bicpO1xuICAgICAgICBwb2x5Lm9mZignbW91c2V1cCcpO1xuXG4gICAgICAgIC8vIHJlbW92ZSBkcmFnZ2FibGUgY2xhc3NcbiAgICAgICAgdmFyIGVsID0gcG9seS5fcGF0aDtcbiAgICAgICAgTC5Eb21VdGlsLnJlbW92ZUNsYXNzKGVsLCAnbGVhZmxldC1wbS1kcmFnZ2FibGUnKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIF9pbml0TWFya2VyczogZnVuY3Rpb24gX2luaXRNYXJrZXJzKCkge1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG4gICAgICAgIC8vIGNsZWFudXAgb2xkIG9uZXMgZmlyc3RcbiAgICAgICAgaWYgKHRoaXMuX21hcmtlckdyb3VwKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJHcm91cC5jbGVhckxheWVycygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWRkIG1hcmtlckdyb3VwIHRvIG1hcCwgbWFya2VyR3JvdXAgaW5jbHVkZXMgcmVndWxhciBhbmQgbWlkZGxlIG1hcmtlcnNcbiAgICAgICAgdGhpcy5fbWFya2VyR3JvdXAgPSBuZXcgTC5MYXllckdyb3VwKCk7XG4gICAgICAgIG1hcC5hZGRMYXllcih0aGlzLl9tYXJrZXJHcm91cCk7XG5cbiAgICAgICAgLy8gY3JlYXRlIG1hcmtlciBmb3IgZWFjaCBjb29yZGluYXRlXG4gICAgICAgIHZhciBjb29yZHMgPSB0aGlzLl9sYXllci5fbGF0bG5ncztcblxuICAgICAgICAvLyB0aGUgbWFya2VyIGFycmF5LCBpdCBpbmNsdWRlcyBvbmx5IHRoZSBtYXJrZXJzIHRoYXQncmUgYXNzb2NpYXRlZCB3aXRoIHRoZSBjb29yZGluYXRlc1xuICAgICAgICB0aGlzLl9tYXJrZXJzID0gY29vcmRzLm1hcCh0aGlzLl9jcmVhdGVNYXJrZXIsIHRoaXMpO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBzbWFsbCBtYXJrZXJzIGluIHRoZSBtaWRkbGUgb2YgdGhlIHJlZ3VsYXIgbWFya2Vyc1xuICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IGNvb3Jkcy5sZW5ndGggLSAxOyBrICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBuZXh0SW5kZXggPSBrICsgMTtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZU1pZGRsZU1hcmtlcih0aGlzLl9tYXJrZXJzW2tdLCB0aGlzLl9tYXJrZXJzW25leHRJbmRleF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zbmFwcGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2luaXRTbmFwcGFibGVNYXJrZXJzKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG5cbiAgICAvLyBjcmVhdGVzIGluaXRpYWwgbWFya2VycyBmb3IgY29vcmRpbmF0ZXNcbiAgICBfY3JlYXRlTWFya2VyOiBmdW5jdGlvbiBfY3JlYXRlTWFya2VyKGxhdGxuZywgaW5kZXgpIHtcbiAgICAgICAgdmFyIG1hcmtlciA9IG5ldyBMLk1hcmtlcihsYXRsbmcsIHtcbiAgICAgICAgICAgIGRyYWdnYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGljb246IEwuZGl2SWNvbih7IGNsYXNzTmFtZTogJ21hcmtlci1pY29uJyB9KVxuICAgICAgICB9KTtcblxuICAgICAgICBtYXJrZXIuX29yaWdMYXRMbmcgPSBsYXRsbmc7XG4gICAgICAgIG1hcmtlci5faW5kZXggPSBpbmRleDtcbiAgICAgICAgbWFya2VyLl9wbVRlbXBMYXllciA9IHRydWU7XG5cbiAgICAgICAgbWFya2VyLm9uKCdkcmFnc3RhcnQnLCB0aGlzLl9vbk1hcmtlckRyYWdTdGFydCwgdGhpcyk7XG4gICAgICAgIG1hcmtlci5vbignbW92ZScsIHRoaXMuX29uTWFya2VyRHJhZywgdGhpcyk7XG4gICAgICAgIG1hcmtlci5vbignZHJhZ2VuZCcsIHRoaXMuX29uTWFya2VyRHJhZ0VuZCwgdGhpcyk7XG4gICAgICAgIG1hcmtlci5vbignY29udGV4dG1lbnUnLCB0aGlzLl9yZW1vdmVNYXJrZXIsIHRoaXMpO1xuXG4gICAgICAgIHRoaXMuX21hcmtlckdyb3VwLmFkZExheWVyKG1hcmtlcik7XG5cbiAgICAgICAgcmV0dXJuIG1hcmtlcjtcbiAgICB9LFxuXG5cbiAgICAvLyBjcmVhdGVzIHRoZSBtaWRkbGUgbWFya2VzIGJldHdlZW4gY29vcmRpbmF0ZXNcbiAgICBfY3JlYXRlTWlkZGxlTWFya2VyOiBmdW5jdGlvbiBfY3JlYXRlTWlkZGxlTWFya2VyKGxlZnRNLCByaWdodE0pIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgdmFyIGxhdGxuZyA9IHRoaXMuX2NhbGNNaWRkbGVMYXRMbmcobGVmdE0uZ2V0TGF0TG5nKCksIHJpZ2h0TS5nZXRMYXRMbmcoKSk7XG5cbiAgICAgICAgdmFyIG1pZGRsZU1hcmtlciA9IHRoaXMuX2NyZWF0ZU1hcmtlcihsYXRsbmcpO1xuICAgICAgICB2YXIgbWlkZGxlSWNvbiA9IEwuZGl2SWNvbih7IGNsYXNzTmFtZTogJ21hcmtlci1pY29uIG1hcmtlci1pY29uLW1pZGRsZScgfSk7XG4gICAgICAgIG1pZGRsZU1hcmtlci5zZXRJY29uKG1pZGRsZUljb24pO1xuXG4gICAgICAgIC8vIHNhdmUgcmVmZXJlbmNlIHRvIHRoaXMgbWlkZGxlIG1hcmtlcnMgb24gdGhlIG5laWdoYm9vciByZWd1bGFyIG1hcmtlcnNcbiAgICAgICAgbGVmdE0uX21pZGRsZU1hcmtlck5leHQgPSBtaWRkbGVNYXJrZXI7XG4gICAgICAgIHJpZ2h0TS5fbWlkZGxlTWFya2VyUHJldiA9IG1pZGRsZU1hcmtlcjtcblxuICAgICAgICBtaWRkbGVNYXJrZXIub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gVE9ETzogbW92ZSB0aGUgbmV4dCB0d28gbGluZXMgaW5zaWRlIF9hZGRNYXJrZXIoKSBhcyBzb29uIGFzXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy80NDg0XG4gICAgICAgICAgICAvLyBpcyBmaXhlZFxuICAgICAgICAgICAgdmFyIGljb24gPSBMLmRpdkljb24oeyBjbGFzc05hbWU6ICdtYXJrZXItaWNvbicgfSk7XG4gICAgICAgICAgICBtaWRkbGVNYXJrZXIuc2V0SWNvbihpY29uKTtcblxuICAgICAgICAgICAgX3RoaXMyLl9hZGRNYXJrZXIobWlkZGxlTWFya2VyLCBsZWZ0TSwgcmlnaHRNKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1pZGRsZU1hcmtlci5vbignbW92ZXN0YXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBpcyBhIHdvcmthcm91bmQuIFJlbW92ZSB0aGUgbW92ZWVuZCBsaXN0ZW5lciBhbmRcbiAgICAgICAgICAgIC8vIGNhbGxiYWNrIGFzIHNvb24gYXMgdGhpcyBpcyBmaXhlZDpcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzQ0ODRcbiAgICAgICAgICAgIG1pZGRsZU1hcmtlci5vbignbW92ZWVuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaWNvbiA9IEwuZGl2SWNvbih7IGNsYXNzTmFtZTogJ21hcmtlci1pY29uJyB9KTtcbiAgICAgICAgICAgICAgICBtaWRkbGVNYXJrZXIuc2V0SWNvbihpY29uKTtcblxuICAgICAgICAgICAgICAgIG1pZGRsZU1hcmtlci5vZmYoJ21vdmVlbmQnKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBfdGhpczIuX2FkZE1hcmtlcihtaWRkbGVNYXJrZXIsIGxlZnRNLCByaWdodE0pO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG5cbiAgICAvLyBhZGRzIGEgbmV3IG1hcmtlciBmcm9tIGEgbWlkZGxlbWFya2VyXG4gICAgX2FkZE1hcmtlcjogZnVuY3Rpb24gX2FkZE1hcmtlcihuZXdNLCBsZWZ0TSwgcmlnaHRNKSB7XG4gICAgICAgIC8vIGZpcnN0LCBtYWtlIHRoaXMgbWlkZGxlbWFya2VyIGEgcmVndWxhciBtYXJrZXJcbiAgICAgICAgbmV3TS5vZmYoJ21vdmVzdGFydCcpO1xuICAgICAgICBuZXdNLm9mZignY2xpY2snKTtcblxuICAgICAgICAvLyBub3csIGNyZWF0ZSB0aGUgcG9seWdvbiBjb29yZGluYXRlIHBvaW50IGZvciB0aGF0IG1hcmtlclxuICAgICAgICB2YXIgbGF0bG5nID0gbmV3TS5nZXRMYXRMbmcoKTtcbiAgICAgICAgdmFyIGNvb3JkcyA9IHRoaXMuX2xheWVyLl9sYXRsbmdzO1xuICAgICAgICB2YXIgaW5kZXggPSBsZWZ0TS5faW5kZXggKyAxO1xuXG4gICAgICAgIGNvb3Jkcy5zcGxpY2UoaW5kZXgsIDAsIGxhdGxuZyk7XG5cbiAgICAgICAgLy8gYXNzb2NpYXRlIHBvbHlnb24gY29vcmRpbmF0ZSB3aXRoIG1hcmtlciBjb29yZGluYXRlXG4gICAgICAgIG5ld00uX29yaWdMYXRMbmcgPSBjb29yZHNbaW5kZXhdO1xuXG4gICAgICAgIC8vIHB1c2ggaW50byBtYXJrZXIgYXJyYXkgJiB1cGRhdGUgdGhlIGluZGV4ZXMgZm9yIGV2ZXJ5IG1hcmtlclxuICAgICAgICB0aGlzLl9tYXJrZXJzLnNwbGljZShpbmRleCwgMCwgbmV3TSk7XG4gICAgICAgIHRoaXMuX21hcmtlcnMubWFwKGZ1bmN0aW9uIChtYXJrZXIsIGkpIHtcbiAgICAgICAgICAgIG1hcmtlci5faW5kZXggPSBpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNyZWF0ZSB0aGUgbmV3IG1pZGRsZW1hcmtlcnNcbiAgICAgICAgdGhpcy5fY3JlYXRlTWlkZGxlTWFya2VyKGxlZnRNLCBuZXdNKTtcbiAgICAgICAgdGhpcy5fY3JlYXRlTWlkZGxlTWFya2VyKG5ld00sIHJpZ2h0TSk7XG5cbiAgICAgICAgLy8gZmlyZSBlZGl0IGV2ZW50XG4gICAgICAgIHRoaXMuX2ZpcmVFZGl0KCk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zbmFwcGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2luaXRTbmFwcGFibGVNYXJrZXJzKCk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIF9yZW1vdmVNYXJrZXI6IGZ1bmN0aW9uIF9yZW1vdmVNYXJrZXIoZSkge1xuICAgICAgICB2YXIgbWFya2VyID0gZS50YXJnZXQ7XG4gICAgICAgIHZhciBjb29yZHMgPSB0aGlzLl9sYXllci5fbGF0bG5ncztcbiAgICAgICAgdmFyIGluZGV4ID0gbWFya2VyLl9pbmRleDtcblxuICAgICAgICAvLyBvbmx5IGNvbnRpbnVlIGlmIHRoaXMgaXMgTk9UIGEgbWlkZGxlIG1hcmtlciAodGhvc2UgY2FuJ3QgYmUgZGVsZXRlZClcbiAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSBwb2x5Z29uIGNvb3JkaW5hdGUgZnJvbSB0aGlzIG1hcmtlclxuICAgICAgICBjb29yZHMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgICAvLyBpZiB0aGUgcG9seSBoYXMgbm8gY29vcmRpbmF0ZXMgbGVmdCwgcmVtb3ZlIHRoZSBsYXllclxuICAgICAgICAvLyBlbHNlLCByZWRyYXcgaXRcbiAgICAgICAgaWYgKGNvb3Jkcy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICB0aGlzLl9sYXllci5yZW1vdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2xheWVyLnJlZHJhdygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVtb3ZlIHRoZSBtYXJrZXIgYW5kIHRoZSBtaWRkbGVtYXJrZXJzIG5leHQgdG8gaXQgZnJvbSB0aGUgbWFwXG4gICAgICAgIGlmIChtYXJrZXIuX21pZGRsZU1hcmtlclByZXYpIHtcbiAgICAgICAgICAgIHRoaXMuX21hcmtlckdyb3VwLnJlbW92ZUxheWVyKG1hcmtlci5fbWlkZGxlTWFya2VyUHJldik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmtlci5fbWlkZGxlTWFya2VyTmV4dCkge1xuICAgICAgICAgICAgdGhpcy5fbWFya2VyR3JvdXAucmVtb3ZlTGF5ZXIobWFya2VyLl9taWRkbGVNYXJrZXJOZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21hcmtlckdyb3VwLnJlbW92ZUxheWVyKG1hcmtlcik7XG5cbiAgICAgICAgLy8gZmluZCBuZWlnaGJvciBtYXJrZXItaW5kZXhlc1xuICAgICAgICB2YXIgbGVmdE1hcmtlckluZGV4ID0gaW5kZXggLSAxIDwgMCA/IHVuZGVmaW5lZCA6IGluZGV4IC0gMTtcbiAgICAgICAgdmFyIHJpZ2h0TWFya2VySW5kZXggPSBpbmRleCArIDEgPj0gdGhpcy5fbWFya2Vycy5sZW5ndGggPyB1bmRlZmluZWQgOiBpbmRleCArIDE7XG5cbiAgICAgICAgLy8gZG9uJ3QgY3JlYXRlIG1pZGRsZW1hcmtlcnMgaWYgdGhlcmUgaXMgb25seSBvbmUgbWFya2VyIGxlZnRcbiAgICAgICAgLy8gb3IgaWYgdGhlIG1pZGRsZW1hcmtlciB3b3VsZCBiZSBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgbGFzdCBjb29yZGluYXRlIG9mIGEgcG9seWxpbmVcbiAgICAgICAgaWYgKHJpZ2h0TWFya2VySW5kZXggJiYgbGVmdE1hcmtlckluZGV4ICYmIHJpZ2h0TWFya2VySW5kZXggIT09IGxlZnRNYXJrZXJJbmRleCkge1xuICAgICAgICAgICAgdmFyIGxlZnRNID0gdGhpcy5fbWFya2Vyc1tsZWZ0TWFya2VySW5kZXhdO1xuICAgICAgICAgICAgdmFyIHJpZ2h0TSA9IHRoaXMuX21hcmtlcnNbcmlnaHRNYXJrZXJJbmRleF07XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVNaWRkbGVNYXJrZXIobGVmdE0sIHJpZ2h0TSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgdGhlIG1hcmtlciBmcm9tIHRoZSBtYXJrZXJzIGFycmF5ICYgdXBkYXRlIGluZGV4ZXNcbiAgICAgICAgdGhpcy5fbWFya2Vycy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB0aGlzLl9tYXJrZXJzLm1hcChmdW5jdGlvbiAobSwgaSkge1xuICAgICAgICAgICAgbS5faW5kZXggPSBpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGZpcmUgZWRpdCBldmVudFxuICAgICAgICB0aGlzLl9maXJlRWRpdCgpO1xuICAgIH0sXG4gICAgX29uTWFya2VyRHJhZzogZnVuY3Rpb24gX29uTWFya2VyRHJhZyhlKSB7XG4gICAgICAgIC8vIGRyYWdnZWQgbWFya2VyXG4gICAgICAgIHZhciBtYXJrZXIgPSBlLnRhcmdldDtcblxuICAgICAgICAvLyBvbmx5IGNvbnRpbnVlIGlmIHRoaXMgaXMgTk9UIGEgbWlkZGxlIG1hcmtlciAodGhvc2UgY2FuJ3QgYmUgZGVsZXRlZClcbiAgICAgICAgaWYgKG1hcmtlci5faW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlIGRyYWdnZWQgbWFya2VycyBuZWlnaGJvcnNcbiAgICAgICAgdmFyIG5leHRNYXJrZXJJbmRleCA9IG1hcmtlci5faW5kZXggKyAxID49IHRoaXMuX21hcmtlcnMubGVuZ3RoID8gMCA6IG1hcmtlci5faW5kZXggKyAxO1xuICAgICAgICB2YXIgcHJldk1hcmtlckluZGV4ID0gbWFya2VyLl9pbmRleCAtIDEgPCAwID8gdGhpcy5fbWFya2Vycy5sZW5ndGggLSAxIDogbWFya2VyLl9pbmRleCAtIDE7XG5cbiAgICAgICAgLy8gdXBkYXRlIG1hcmtlciBjb29yZGluYXRlcyB3aGljaCB3aWxsIHVwZGF0ZSBwb2x5Z29uIGNvb3JkaW5hdGVzXG4gICAgICAgIEwuZXh0ZW5kKG1hcmtlci5fb3JpZ0xhdExuZywgbWFya2VyLl9sYXRsbmcpO1xuICAgICAgICB0aGlzLl9sYXllci5yZWRyYXcoKTtcblxuICAgICAgICAvLyB1cGRhdGUgbWlkZGxlIG1hcmtlcnMgb24gdGhlIGxlZnQgYW5kIHJpZ2h0XG4gICAgICAgIC8vIGJlIGF3YXJlIHRoYXQgXCJuZXh0XCIgYW5kIFwicHJldlwiIG1pZ2h0IGJlIGludGVyY2hhbmdlZCwgZGVwZW5kaW5nIG9uIHRoZSBnZW9qc29uIGFycmF5XG4gICAgICAgIHZhciBtYXJrZXJMYXRMbmcgPSBtYXJrZXIuZ2V0TGF0TG5nKCk7XG4gICAgICAgIHZhciBwcmV2TWFya2VyTGF0TG5nID0gdGhpcy5fbWFya2Vyc1twcmV2TWFya2VySW5kZXhdLmdldExhdExuZygpO1xuICAgICAgICB2YXIgbmV4dE1hcmtlckxhdExuZyA9IHRoaXMuX21hcmtlcnNbbmV4dE1hcmtlckluZGV4XS5nZXRMYXRMbmcoKTtcblxuICAgICAgICBpZiAobWFya2VyLl9taWRkbGVNYXJrZXJOZXh0KSB7XG4gICAgICAgICAgICB2YXIgbWlkZGxlTWFya2VyTmV4dExhdExuZyA9IHRoaXMuX2NhbGNNaWRkbGVMYXRMbmcobWFya2VyTGF0TG5nLCBuZXh0TWFya2VyTGF0TG5nKTtcbiAgICAgICAgICAgIG1hcmtlci5fbWlkZGxlTWFya2VyTmV4dC5zZXRMYXRMbmcobWlkZGxlTWFya2VyTmV4dExhdExuZyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWFya2VyLl9taWRkbGVNYXJrZXJQcmV2KSB7XG4gICAgICAgICAgICB2YXIgbWlkZGxlTWFya2VyUHJldkxhdExuZyA9IHRoaXMuX2NhbGNNaWRkbGVMYXRMbmcobWFya2VyTGF0TG5nLCBwcmV2TWFya2VyTGF0TG5nKTtcbiAgICAgICAgICAgIG1hcmtlci5fbWlkZGxlTWFya2VyUHJldi5zZXRMYXRMbmcobWlkZGxlTWFya2VyUHJldkxhdExuZyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIF9vbk1hcmtlckRyYWdFbmQ6IGZ1bmN0aW9uIF9vbk1hcmtlckRyYWdFbmQoZSkge1xuICAgICAgICB0aGlzLl9sYXllci5maXJlKCdwbTptYXJrZXJkcmFnZW5kJywge1xuICAgICAgICAgICAgbWFya2VyRXZlbnQ6IGVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZmlyZSBlZGl0IGV2ZW50XG4gICAgICAgIHRoaXMuX2ZpcmVFZGl0KCk7XG4gICAgfSxcbiAgICBfb25NYXJrZXJEcmFnU3RhcnQ6IGZ1bmN0aW9uIF9vbk1hcmtlckRyYWdTdGFydChlKSB7XG4gICAgICAgIHRoaXMuX2xheWVyLmZpcmUoJ3BtOm1hcmtlcmRyYWdzdGFydCcsIHtcbiAgICAgICAgICAgIG1hcmtlckV2ZW50OiBlXG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgX2ZpcmVFZGl0OiBmdW5jdGlvbiBfZmlyZUVkaXQoKSB7XG4gICAgICAgIC8vIGZpcmUgZWRpdCBldmVudFxuICAgICAgICB0aGlzLl9sYXllci5lZGl0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9sYXllci5maXJlKCdwbTplZGl0Jyk7XG4gICAgfSxcbiAgICBfY2FsY01pZGRsZUxhdExuZzogZnVuY3Rpb24gX2NhbGNNaWRkbGVMYXRMbmcobGF0bG5nMSwgbGF0bG5nMikge1xuICAgICAgICAvLyBjYWxjdWxhdGUgdGhlIG1pZGRsZSBjb29yZGluYXRlcyBiZXR3ZWVuIHR3byBtYXJrZXJzXG4gICAgICAgIC8vIFRPRE86IHB1dCB0aGlzIGludG8gYSB1dGlscy5qcyBvciBzb21ldGhpbmdcblxuICAgICAgICB2YXIgbWFwID0gdGhpcy5fbWFwO1xuICAgICAgICB2YXIgcDEgPSBtYXAucHJvamVjdChsYXRsbmcxKTtcbiAgICAgICAgdmFyIHAyID0gbWFwLnByb2plY3QobGF0bG5nMik7XG5cbiAgICAgICAgdmFyIGxhdGxuZyA9IG1hcC51bnByb2plY3QocDEuX2FkZChwMikuX2RpdmlkZUJ5KDIpKTtcblxuICAgICAgICByZXR1cm4gbGF0bG5nO1xuICAgIH1cbn0pO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2pzL0VkaXQvTC5QTS5FZGl0LkxpbmUuanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _LPM = __webpack_require__(0);\n\nvar _LPM2 = _interopRequireDefault(_LPM);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_LPM2.default.Marker = _LPM2.default.extend({\n    initialize: function initialize(layer) {\n        // layer is a marker in this case :-)\n        this._layer = layer;\n        this._enabled = false;\n\n        // register dragend event e.g. to fire pm:edit\n        this._layer.on('dragend', this._onDragEnd, this);\n    },\n    toggleEdit: function toggleEdit(options) {\n        if (!this.enabled()) {\n            this.enable(options);\n        } else {\n            this.disable();\n        }\n    },\n    enable: function enable() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n            draggable: true,\n            snappable: true\n        };\n\n        this.options = options;\n\n        this._map = this._layer._map;\n\n        if (this.enabled()) {\n            return;\n        }\n        this._enabled = true;\n\n        // enable removal for the marker\n        this._layer.on('contextmenu', this._removeMarker, this);\n\n        // enable dragging and removal for the marker\n        if (this.options.snappable) {\n            this._layer.dragging.enable();\n        }\n\n        // enable snapping\n        if (this.options.snappable) {\n            this._initSnappableMarkers();\n        }\n    },\n    enabled: function enabled() {\n        return this._enabled;\n    },\n    disable: function disable() {\n        this._enabled = false;\n\n        // disable dragging and removal for the marker\n        this._layer.dragging.disable();\n        this._layer.off('contextmenu', this._removeMarker, this);\n    },\n    _removeMarker: function _removeMarker(e) {\n        var marker = e.target;\n        marker.remove();\n        marker.fire('pm:remove');\n    },\n    _onDragEnd: function _onDragEnd(e) {\n        var marker = e.target;\n\n        // fire the pm:edit event and pass shape and marker\n        marker.fire('pm:edit');\n    },\n\n\n    // overwrite initSnappableMarkers from Snapping.js Mixin\n    _initSnappableMarkers: function _initSnappableMarkers() {\n        var marker = this._layer;\n\n        this.options.snapDistance = this.options.snapDistance || 30;\n\n        marker.off('drag', this._handleSnapping, this);\n        marker.on('drag', this._handleSnapping, this);\n\n        marker.off('dragend', this._cleanupSnapping, this);\n        marker.on('dragend', this._cleanupSnapping, this);\n\n        marker.off('pm:dragstart', this._unsnap, this);\n        marker.on('pm:dragstart', this._unsnap, this);\n    }\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTAuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvRWRpdC9MLlBNLkVkaXQuTWFya2VyLmpzPzI2ZWEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX0xQTSA9IHJlcXVpcmUoJy4vTC5QTS5FZGl0Jyk7XG5cbnZhciBfTFBNMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xQTSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbl9MUE0yLmRlZmF1bHQuTWFya2VyID0gX0xQTTIuZGVmYXVsdC5leHRlbmQoe1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIGluaXRpYWxpemUobGF5ZXIpIHtcbiAgICAgICAgLy8gbGF5ZXIgaXMgYSBtYXJrZXIgaW4gdGhpcyBjYXNlIDotKVxuICAgICAgICB0aGlzLl9sYXllciA9IGxheWVyO1xuICAgICAgICB0aGlzLl9lbmFibGVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gcmVnaXN0ZXIgZHJhZ2VuZCBldmVudCBlLmcuIHRvIGZpcmUgcG06ZWRpdFxuICAgICAgICB0aGlzLl9sYXllci5vbignZHJhZ2VuZCcsIHRoaXMuX29uRHJhZ0VuZCwgdGhpcyk7XG4gICAgfSxcbiAgICB0b2dnbGVFZGl0OiBmdW5jdGlvbiB0b2dnbGVFZGl0KG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5lbmFibGUob3B0aW9ucyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpc2FibGUoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgZW5hYmxlOiBmdW5jdGlvbiBlbmFibGUoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7XG4gICAgICAgICAgICBkcmFnZ2FibGU6IHRydWUsXG4gICAgICAgICAgICBzbmFwcGFibGU6IHRydWVcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXG4gICAgICAgIHRoaXMuX21hcCA9IHRoaXMuX2xheWVyLl9tYXA7XG5cbiAgICAgICAgaWYgKHRoaXMuZW5hYmxlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZW5hYmxlZCA9IHRydWU7XG5cbiAgICAgICAgLy8gZW5hYmxlIHJlbW92YWwgZm9yIHRoZSBtYXJrZXJcbiAgICAgICAgdGhpcy5fbGF5ZXIub24oJ2NvbnRleHRtZW51JywgdGhpcy5fcmVtb3ZlTWFya2VyLCB0aGlzKTtcblxuICAgICAgICAvLyBlbmFibGUgZHJhZ2dpbmcgYW5kIHJlbW92YWwgZm9yIHRoZSBtYXJrZXJcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zbmFwcGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2xheWVyLmRyYWdnaW5nLmVuYWJsZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZW5hYmxlIHNuYXBwaW5nXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc25hcHBhYmxlKSB7XG4gICAgICAgICAgICB0aGlzLl9pbml0U25hcHBhYmxlTWFya2VycygpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBlbmFibGVkOiBmdW5jdGlvbiBlbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW5hYmxlZDtcbiAgICB9LFxuICAgIGRpc2FibGU6IGZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gICAgICAgIHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcblxuICAgICAgICAvLyBkaXNhYmxlIGRyYWdnaW5nIGFuZCByZW1vdmFsIGZvciB0aGUgbWFya2VyXG4gICAgICAgIHRoaXMuX2xheWVyLmRyYWdnaW5nLmRpc2FibGUoKTtcbiAgICAgICAgdGhpcy5fbGF5ZXIub2ZmKCdjb250ZXh0bWVudScsIHRoaXMuX3JlbW92ZU1hcmtlciwgdGhpcyk7XG4gICAgfSxcbiAgICBfcmVtb3ZlTWFya2VyOiBmdW5jdGlvbiBfcmVtb3ZlTWFya2VyKGUpIHtcbiAgICAgICAgdmFyIG1hcmtlciA9IGUudGFyZ2V0O1xuICAgICAgICBtYXJrZXIucmVtb3ZlKCk7XG4gICAgICAgIG1hcmtlci5maXJlKCdwbTpyZW1vdmUnKTtcbiAgICB9LFxuICAgIF9vbkRyYWdFbmQ6IGZ1bmN0aW9uIF9vbkRyYWdFbmQoZSkge1xuICAgICAgICB2YXIgbWFya2VyID0gZS50YXJnZXQ7XG5cbiAgICAgICAgLy8gZmlyZSB0aGUgcG06ZWRpdCBldmVudCBhbmQgcGFzcyBzaGFwZSBhbmQgbWFya2VyXG4gICAgICAgIG1hcmtlci5maXJlKCdwbTplZGl0Jyk7XG4gICAgfSxcblxuXG4gICAgLy8gb3ZlcndyaXRlIGluaXRTbmFwcGFibGVNYXJrZXJzIGZyb20gU25hcHBpbmcuanMgTWl4aW5cbiAgICBfaW5pdFNuYXBwYWJsZU1hcmtlcnM6IGZ1bmN0aW9uIF9pbml0U25hcHBhYmxlTWFya2VycygpIHtcbiAgICAgICAgdmFyIG1hcmtlciA9IHRoaXMuX2xheWVyO1xuXG4gICAgICAgIHRoaXMub3B0aW9ucy5zbmFwRGlzdGFuY2UgPSB0aGlzLm9wdGlvbnMuc25hcERpc3RhbmNlIHx8IDMwO1xuXG4gICAgICAgIG1hcmtlci5vZmYoJ2RyYWcnLCB0aGlzLl9oYW5kbGVTbmFwcGluZywgdGhpcyk7XG4gICAgICAgIG1hcmtlci5vbignZHJhZycsIHRoaXMuX2hhbmRsZVNuYXBwaW5nLCB0aGlzKTtcblxuICAgICAgICBtYXJrZXIub2ZmKCdkcmFnZW5kJywgdGhpcy5fY2xlYW51cFNuYXBwaW5nLCB0aGlzKTtcbiAgICAgICAgbWFya2VyLm9uKCdkcmFnZW5kJywgdGhpcy5fY2xlYW51cFNuYXBwaW5nLCB0aGlzKTtcblxuICAgICAgICBtYXJrZXIub2ZmKCdwbTpkcmFnc3RhcnQnLCB0aGlzLl91bnNuYXAsIHRoaXMpO1xuICAgICAgICBtYXJrZXIub24oJ3BtOmRyYWdzdGFydCcsIHRoaXMuX3Vuc25hcCwgdGhpcyk7XG4gICAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvRWRpdC9MLlBNLkVkaXQuTWFya2VyLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _LPM = __webpack_require__(0);\n\nvar _LPM2 = _interopRequireDefault(_LPM);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n_LPM2.default.Poly = _LPM2.default.Line.extend({\n    _initMarkers: function _initMarkers() {\n        var map = this._map;\n\n        // cleanup old ones first\n        if (this._markerGroup) {\n            this._markerGroup.clearLayers();\n        }\n\n        // add markerGroup to map, markerGroup includes regular and middle markers\n        this._markerGroup = new L.LayerGroup();\n        map.addLayer(this._markerGroup);\n\n        // create marker for each coordinate\n        var coords = this._layer._latlngs[0];\n\n        // the marker array, it includes only the markers that're associated with the coordinates\n        this._markers = coords.map(this._createMarker, this);\n\n        // create small markers in the middle of the regular markers\n        for (var k = 0; k < coords.length; k += 1) {\n            var nextIndex = k + 1 >= coords.length ? 0 : k + 1;\n            this._createMiddleMarker(this._markers[k], this._markers[nextIndex]);\n        }\n\n        if (this.options.snappable) {\n            this._initSnappableMarkers();\n        }\n    },\n\n\n    // adds a new marker from a middlemarker\n    _addMarker: function _addMarker(newM, leftM, rightM) {\n        // first, make this middlemarker a regular marker\n        newM.off('movestart');\n        newM.off('click');\n\n        // now, create the polygon coordinate point for that marker\n        var latlng = newM.getLatLng();\n        var coords = this._layer._latlngs[0];\n        var index = leftM._index + 1;\n\n        coords.splice(index, 0, latlng);\n\n        // associate polygon coordinate with marker coordinate\n        newM._origLatLng = coords[index];\n\n        // push into marker array & update the indexes for every marker\n        this._markers.splice(index, 0, newM);\n        this._markers.map(function (marker, i) {\n            marker._index = i;\n            return true;\n        });\n\n        // create the new middlemarkers\n        this._createMiddleMarker(leftM, newM);\n        this._createMiddleMarker(newM, rightM);\n\n        // fire edit event\n        this._fireEdit();\n\n        if (this.options.snappable) {\n            this._initSnappableMarkers();\n        }\n    },\n    _removeMarker: function _removeMarker(e) {\n        var marker = e.target;\n        var coords = this._layer._latlngs[0];\n        var index = marker._index;\n\n        // only continue if this is NOT a middle marker (those can't be deleted)\n        if (index === undefined) {\n            return;\n        }\n\n        // don't remove a marker if a polygon has only 3 coordinates.\n        if (coords.length <= 3) {\n            return;\n        }\n\n        // remove polygon coordinate from this marker\n        coords.splice(index, 1);\n\n        // if the poly has no coordinates left, remove the layer\n        // else, redraw it\n        if (coords.length < 1) {\n            this._layer.remove();\n        } else {\n            this._layer.redraw();\n        }\n\n        // remove the marker and the middlemarkers next to it from the map\n        this._markerGroup.removeLayer(marker._middleMarkerPrev);\n        this._markerGroup.removeLayer(marker._middleMarkerNext);\n        this._markerGroup.removeLayer(marker);\n\n        // find neighbor marker-indexes\n        var leftMarkerIndex = index - 1 < 0 ? this._markers.length - 1 : index - 1;\n        var rightMarkerIndex = index + 1 >= this._markers.length ? 0 : index + 1;\n\n        // don't create middlemarkers if there is only one marker left\n        if (rightMarkerIndex !== leftMarkerIndex) {\n            var leftM = this._markers[leftMarkerIndex];\n            var rightM = this._markers[rightMarkerIndex];\n            this._createMiddleMarker(leftM, rightM);\n        }\n\n        // remove the marker from the markers array & update indexes\n        this._markers.splice(index, 1);\n        this._markers.map(function (m, i) {\n            m._index = i;\n            return true;\n        });\n\n        // fire edit event\n        this._fireEdit();\n    }\n});//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvRWRpdC9MLlBNLkVkaXQuUG9seS5qcz8zODlhIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF9MUE0gPSByZXF1aXJlKCcuL0wuUE0uRWRpdCcpO1xuXG52YXIgX0xQTTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9MUE0pO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5fTFBNMi5kZWZhdWx0LlBvbHkgPSBfTFBNMi5kZWZhdWx0LkxpbmUuZXh0ZW5kKHtcbiAgICBfaW5pdE1hcmtlcnM6IGZ1bmN0aW9uIF9pbml0TWFya2VycygpIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcblxuICAgICAgICAvLyBjbGVhbnVwIG9sZCBvbmVzIGZpcnN0XG4gICAgICAgIGlmICh0aGlzLl9tYXJrZXJHcm91cCkge1xuICAgICAgICAgICAgdGhpcy5fbWFya2VyR3JvdXAuY2xlYXJMYXllcnMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCBtYXJrZXJHcm91cCB0byBtYXAsIG1hcmtlckdyb3VwIGluY2x1ZGVzIHJlZ3VsYXIgYW5kIG1pZGRsZSBtYXJrZXJzXG4gICAgICAgIHRoaXMuX21hcmtlckdyb3VwID0gbmV3IEwuTGF5ZXJHcm91cCgpO1xuICAgICAgICBtYXAuYWRkTGF5ZXIodGhpcy5fbWFya2VyR3JvdXApO1xuXG4gICAgICAgIC8vIGNyZWF0ZSBtYXJrZXIgZm9yIGVhY2ggY29vcmRpbmF0ZVxuICAgICAgICB2YXIgY29vcmRzID0gdGhpcy5fbGF5ZXIuX2xhdGxuZ3NbMF07XG5cbiAgICAgICAgLy8gdGhlIG1hcmtlciBhcnJheSwgaXQgaW5jbHVkZXMgb25seSB0aGUgbWFya2VycyB0aGF0J3JlIGFzc29jaWF0ZWQgd2l0aCB0aGUgY29vcmRpbmF0ZXNcbiAgICAgICAgdGhpcy5fbWFya2VycyA9IGNvb3Jkcy5tYXAodGhpcy5fY3JlYXRlTWFya2VyLCB0aGlzKTtcblxuICAgICAgICAvLyBjcmVhdGUgc21hbGwgbWFya2VycyBpbiB0aGUgbWlkZGxlIG9mIHRoZSByZWd1bGFyIG1hcmtlcnNcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBjb29yZHMubGVuZ3RoOyBrICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBuZXh0SW5kZXggPSBrICsgMSA+PSBjb29yZHMubGVuZ3RoID8gMCA6IGsgKyAxO1xuICAgICAgICAgICAgdGhpcy5fY3JlYXRlTWlkZGxlTWFya2VyKHRoaXMuX21hcmtlcnNba10sIHRoaXMuX21hcmtlcnNbbmV4dEluZGV4XSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNuYXBwYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5faW5pdFNuYXBwYWJsZU1hcmtlcnMoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cblxuICAgIC8vIGFkZHMgYSBuZXcgbWFya2VyIGZyb20gYSBtaWRkbGVtYXJrZXJcbiAgICBfYWRkTWFya2VyOiBmdW5jdGlvbiBfYWRkTWFya2VyKG5ld00sIGxlZnRNLCByaWdodE0pIHtcbiAgICAgICAgLy8gZmlyc3QsIG1ha2UgdGhpcyBtaWRkbGVtYXJrZXIgYSByZWd1bGFyIG1hcmtlclxuICAgICAgICBuZXdNLm9mZignbW92ZXN0YXJ0Jyk7XG4gICAgICAgIG5ld00ub2ZmKCdjbGljaycpO1xuXG4gICAgICAgIC8vIG5vdywgY3JlYXRlIHRoZSBwb2x5Z29uIGNvb3JkaW5hdGUgcG9pbnQgZm9yIHRoYXQgbWFya2VyXG4gICAgICAgIHZhciBsYXRsbmcgPSBuZXdNLmdldExhdExuZygpO1xuICAgICAgICB2YXIgY29vcmRzID0gdGhpcy5fbGF5ZXIuX2xhdGxuZ3NbMF07XG4gICAgICAgIHZhciBpbmRleCA9IGxlZnRNLl9pbmRleCArIDE7XG5cbiAgICAgICAgY29vcmRzLnNwbGljZShpbmRleCwgMCwgbGF0bG5nKTtcblxuICAgICAgICAvLyBhc3NvY2lhdGUgcG9seWdvbiBjb29yZGluYXRlIHdpdGggbWFya2VyIGNvb3JkaW5hdGVcbiAgICAgICAgbmV3TS5fb3JpZ0xhdExuZyA9IGNvb3Jkc1tpbmRleF07XG5cbiAgICAgICAgLy8gcHVzaCBpbnRvIG1hcmtlciBhcnJheSAmIHVwZGF0ZSB0aGUgaW5kZXhlcyBmb3IgZXZlcnkgbWFya2VyXG4gICAgICAgIHRoaXMuX21hcmtlcnMuc3BsaWNlKGluZGV4LCAwLCBuZXdNKTtcbiAgICAgICAgdGhpcy5fbWFya2Vycy5tYXAoZnVuY3Rpb24gKG1hcmtlciwgaSkge1xuICAgICAgICAgICAgbWFya2VyLl9pbmRleCA9IGk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBuZXcgbWlkZGxlbWFya2Vyc1xuICAgICAgICB0aGlzLl9jcmVhdGVNaWRkbGVNYXJrZXIobGVmdE0sIG5ld00pO1xuICAgICAgICB0aGlzLl9jcmVhdGVNaWRkbGVNYXJrZXIobmV3TSwgcmlnaHRNKTtcblxuICAgICAgICAvLyBmaXJlIGVkaXQgZXZlbnRcbiAgICAgICAgdGhpcy5fZmlyZUVkaXQoKTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNuYXBwYWJsZSkge1xuICAgICAgICAgICAgdGhpcy5faW5pdFNuYXBwYWJsZU1hcmtlcnMoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX3JlbW92ZU1hcmtlcjogZnVuY3Rpb24gX3JlbW92ZU1hcmtlcihlKSB7XG4gICAgICAgIHZhciBtYXJrZXIgPSBlLnRhcmdldDtcbiAgICAgICAgdmFyIGNvb3JkcyA9IHRoaXMuX2xheWVyLl9sYXRsbmdzWzBdO1xuICAgICAgICB2YXIgaW5kZXggPSBtYXJrZXIuX2luZGV4O1xuXG4gICAgICAgIC8vIG9ubHkgY29udGludWUgaWYgdGhpcyBpcyBOT1QgYSBtaWRkbGUgbWFya2VyICh0aG9zZSBjYW4ndCBiZSBkZWxldGVkKVxuICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZG9uJ3QgcmVtb3ZlIGEgbWFya2VyIGlmIGEgcG9seWdvbiBoYXMgb25seSAzIGNvb3JkaW5hdGVzLlxuICAgICAgICBpZiAoY29vcmRzLmxlbmd0aCA8PSAzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZW1vdmUgcG9seWdvbiBjb29yZGluYXRlIGZyb20gdGhpcyBtYXJrZXJcbiAgICAgICAgY29vcmRzLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgICAgLy8gaWYgdGhlIHBvbHkgaGFzIG5vIGNvb3JkaW5hdGVzIGxlZnQsIHJlbW92ZSB0aGUgbGF5ZXJcbiAgICAgICAgLy8gZWxzZSwgcmVkcmF3IGl0XG4gICAgICAgIGlmIChjb29yZHMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXIucmVtb3ZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9sYXllci5yZWRyYXcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgbWFya2VyIGFuZCB0aGUgbWlkZGxlbWFya2VycyBuZXh0IHRvIGl0IGZyb20gdGhlIG1hcFxuICAgICAgICB0aGlzLl9tYXJrZXJHcm91cC5yZW1vdmVMYXllcihtYXJrZXIuX21pZGRsZU1hcmtlclByZXYpO1xuICAgICAgICB0aGlzLl9tYXJrZXJHcm91cC5yZW1vdmVMYXllcihtYXJrZXIuX21pZGRsZU1hcmtlck5leHQpO1xuICAgICAgICB0aGlzLl9tYXJrZXJHcm91cC5yZW1vdmVMYXllcihtYXJrZXIpO1xuXG4gICAgICAgIC8vIGZpbmQgbmVpZ2hib3IgbWFya2VyLWluZGV4ZXNcbiAgICAgICAgdmFyIGxlZnRNYXJrZXJJbmRleCA9IGluZGV4IC0gMSA8IDAgPyB0aGlzLl9tYXJrZXJzLmxlbmd0aCAtIDEgOiBpbmRleCAtIDE7XG4gICAgICAgIHZhciByaWdodE1hcmtlckluZGV4ID0gaW5kZXggKyAxID49IHRoaXMuX21hcmtlcnMubGVuZ3RoID8gMCA6IGluZGV4ICsgMTtcblxuICAgICAgICAvLyBkb24ndCBjcmVhdGUgbWlkZGxlbWFya2VycyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBtYXJrZXIgbGVmdFxuICAgICAgICBpZiAocmlnaHRNYXJrZXJJbmRleCAhPT0gbGVmdE1hcmtlckluZGV4KSB7XG4gICAgICAgICAgICB2YXIgbGVmdE0gPSB0aGlzLl9tYXJrZXJzW2xlZnRNYXJrZXJJbmRleF07XG4gICAgICAgICAgICB2YXIgcmlnaHRNID0gdGhpcy5fbWFya2Vyc1tyaWdodE1hcmtlckluZGV4XTtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZU1pZGRsZU1hcmtlcihsZWZ0TSwgcmlnaHRNKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgbWFya2VyIGZyb20gdGhlIG1hcmtlcnMgYXJyYXkgJiB1cGRhdGUgaW5kZXhlc1xuICAgICAgICB0aGlzLl9tYXJrZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIHRoaXMuX21hcmtlcnMubWFwKGZ1bmN0aW9uIChtLCBpKSB7XG4gICAgICAgICAgICBtLl9pbmRleCA9IGk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZmlyZSBlZGl0IGV2ZW50XG4gICAgICAgIHRoaXMuX2ZpcmVFZGl0KCk7XG4gICAgfVxufSk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvRWRpdC9MLlBNLkVkaXQuUG9seS5qc1xuLy8gbW9kdWxlIGlkID0gMTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar Map = L.Class.extend({\n    initialize: function initialize(map) {\n        this.map = map;\n        this.Draw = new L.PM.Draw(map);\n        this.Toolbar = new L.PM.Toolbar(map);\n    },\n    addControls: function addControls(options) {\n        this.Toolbar.addControls(options);\n    },\n    removeControls: function removeControls() {\n        this.Toolbar.removeControls();\n    },\n    toggleControls: function toggleControls() {\n        this.Toolbar.toggleControls();\n    },\n    controlsVisible: function controlsVisible() {\n        return this.Toolbar.isVisible;\n    },\n    enableDraw: function enableDraw() {\n        var shape = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Poly';\n        var options = arguments[1];\n\n        this.Draw.enable(shape, options);\n    },\n    disableDraw: function disableDraw() {\n        var shape = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'Poly';\n\n        this.Draw.disable(shape);\n    },\n    setPathOptions: function setPathOptions(options) {\n        this.Draw.setPathOptions(options);\n    },\n    removeLayer: function removeLayer(e) {\n        var layer = e.target;\n        if (!layer._layers && !layer.pm.dragging()) {\n            e.target.remove();\n        }\n    },\n    toggleGlobalRemovalMode: function toggleGlobalRemovalMode() {\n        var _this = this;\n\n        // toggle global edit mode\n        if (this.globalRemovalEnabled()) {\n            this._globalRemovalMode = false;\n            this.map.eachLayer(function (layer) {\n                layer.off('click', _this.removeLayer);\n            });\n        } else {\n            this._globalRemovalMode = true;\n            this.map.eachLayer(function (layer) {\n                layer.on('click', _this.removeLayer);\n            });\n        }\n\n        // toogle the button in the toolbar\n        this.Toolbar.toggleButton('deleteLayer', this._globalRemovalMode);\n    },\n    globalRemovalEnabled: function globalRemovalEnabled() {\n        return this._globalRemovalMode;\n    },\n    globalEditEnabled: function globalEditEnabled() {\n        return this._globalEditMode;\n    },\n    toggleGlobalEditMode: function toggleGlobalEditMode() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { snappable: true, draggable: true };\n\n        // find all layers that are or inherit from Polylines...\n        var layers = [];\n        this.map.eachLayer(function (layer) {\n            if (layer instanceof L.Polyline || layer instanceof L.Marker || layer instanceof L.Circle) {\n                layers.push(layer);\n            }\n        });\n\n        // filter out layers that don't have the leaflet.pm instance\n        layers = layers.filter(function (layer) {\n            return !!layer.pm;\n        });\n\n        // filter out everything that's leaflet.pm specific temporary stuff\n        layers = layers.filter(function (layer) {\n            return !layer._pmTempLayer;\n        });\n\n        if (this.globalEditEnabled()) {\n            // disable\n\n            this._globalEditMode = false;\n\n            layers.forEach(function (layer) {\n                layer.pm.disable();\n            });\n        } else {\n            // enable\n\n            this._globalEditMode = true;\n\n            layers.forEach(function (layer) {\n                layer.pm.enable(options);\n            });\n        }\n\n        // toggle the button in the toolbar\n        this.Toolbar.toggleButton('editPolygon', this._globalEditMode);\n    }\n});\n\nexports.default = Map;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvTC5QTS5NYXAuanM/Mzk5NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbnZhciBNYXAgPSBMLkNsYXNzLmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZShtYXApIHtcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgICAgIHRoaXMuRHJhdyA9IG5ldyBMLlBNLkRyYXcobWFwKTtcbiAgICAgICAgdGhpcy5Ub29sYmFyID0gbmV3IEwuUE0uVG9vbGJhcihtYXApO1xuICAgIH0sXG4gICAgYWRkQ29udHJvbHM6IGZ1bmN0aW9uIGFkZENvbnRyb2xzKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5Ub29sYmFyLmFkZENvbnRyb2xzKG9wdGlvbnMpO1xuICAgIH0sXG4gICAgcmVtb3ZlQ29udHJvbHM6IGZ1bmN0aW9uIHJlbW92ZUNvbnRyb2xzKCkge1xuICAgICAgICB0aGlzLlRvb2xiYXIucmVtb3ZlQ29udHJvbHMoKTtcbiAgICB9LFxuICAgIHRvZ2dsZUNvbnRyb2xzOiBmdW5jdGlvbiB0b2dnbGVDb250cm9scygpIHtcbiAgICAgICAgdGhpcy5Ub29sYmFyLnRvZ2dsZUNvbnRyb2xzKCk7XG4gICAgfSxcbiAgICBjb250cm9sc1Zpc2libGU6IGZ1bmN0aW9uIGNvbnRyb2xzVmlzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuVG9vbGJhci5pc1Zpc2libGU7XG4gICAgfSxcbiAgICBlbmFibGVEcmF3OiBmdW5jdGlvbiBlbmFibGVEcmF3KCkge1xuICAgICAgICB2YXIgc2hhcGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICdQb2x5JztcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHNbMV07XG5cbiAgICAgICAgdGhpcy5EcmF3LmVuYWJsZShzaGFwZSwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBkaXNhYmxlRHJhdzogZnVuY3Rpb24gZGlzYWJsZURyYXcoKSB7XG4gICAgICAgIHZhciBzaGFwZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ1BvbHknO1xuXG4gICAgICAgIHRoaXMuRHJhdy5kaXNhYmxlKHNoYXBlKTtcbiAgICB9LFxuICAgIHNldFBhdGhPcHRpb25zOiBmdW5jdGlvbiBzZXRQYXRoT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuRHJhdy5zZXRQYXRoT3B0aW9ucyhvcHRpb25zKTtcbiAgICB9LFxuICAgIHJlbW92ZUxheWVyOiBmdW5jdGlvbiByZW1vdmVMYXllcihlKSB7XG4gICAgICAgIHZhciBsYXllciA9IGUudGFyZ2V0O1xuICAgICAgICBpZiAoIWxheWVyLl9sYXllcnMgJiYgIWxheWVyLnBtLmRyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgIGUudGFyZ2V0LnJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICB0b2dnbGVHbG9iYWxSZW1vdmFsTW9kZTogZnVuY3Rpb24gdG9nZ2xlR2xvYmFsUmVtb3ZhbE1vZGUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgLy8gdG9nZ2xlIGdsb2JhbCBlZGl0IG1vZGVcbiAgICAgICAgaWYgKHRoaXMuZ2xvYmFsUmVtb3ZhbEVuYWJsZWQoKSkge1xuICAgICAgICAgICAgdGhpcy5fZ2xvYmFsUmVtb3ZhbE1vZGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMubWFwLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBsYXllci5vZmYoJ2NsaWNrJywgX3RoaXMucmVtb3ZlTGF5ZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9nbG9iYWxSZW1vdmFsTW9kZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLm1hcC5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXIub24oJ2NsaWNrJywgX3RoaXMucmVtb3ZlTGF5ZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0b29nbGUgdGhlIGJ1dHRvbiBpbiB0aGUgdG9vbGJhclxuICAgICAgICB0aGlzLlRvb2xiYXIudG9nZ2xlQnV0dG9uKCdkZWxldGVMYXllcicsIHRoaXMuX2dsb2JhbFJlbW92YWxNb2RlKTtcbiAgICB9LFxuICAgIGdsb2JhbFJlbW92YWxFbmFibGVkOiBmdW5jdGlvbiBnbG9iYWxSZW1vdmFsRW5hYmxlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dsb2JhbFJlbW92YWxNb2RlO1xuICAgIH0sXG4gICAgZ2xvYmFsRWRpdEVuYWJsZWQ6IGZ1bmN0aW9uIGdsb2JhbEVkaXRFbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2xvYmFsRWRpdE1vZGU7XG4gICAgfSxcbiAgICB0b2dnbGVHbG9iYWxFZGl0TW9kZTogZnVuY3Rpb24gdG9nZ2xlR2xvYmFsRWRpdE1vZGUoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7IHNuYXBwYWJsZTogdHJ1ZSwgZHJhZ2dhYmxlOiB0cnVlIH07XG5cbiAgICAgICAgLy8gZmluZCBhbGwgbGF5ZXJzIHRoYXQgYXJlIG9yIGluaGVyaXQgZnJvbSBQb2x5bGluZXMuLi5cbiAgICAgICAgdmFyIGxheWVycyA9IFtdO1xuICAgICAgICB0aGlzLm1hcC5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICBpZiAobGF5ZXIgaW5zdGFuY2VvZiBMLlBvbHlsaW5lIHx8IGxheWVyIGluc3RhbmNlb2YgTC5NYXJrZXIgfHwgbGF5ZXIgaW5zdGFuY2VvZiBMLkNpcmNsZSkge1xuICAgICAgICAgICAgICAgIGxheWVycy5wdXNoKGxheWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZmlsdGVyIG91dCBsYXllcnMgdGhhdCBkb24ndCBoYXZlIHRoZSBsZWFmbGV0LnBtIGluc3RhbmNlXG4gICAgICAgIGxheWVycyA9IGxheWVycy5maWx0ZXIoZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICByZXR1cm4gISFsYXllci5wbTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gZmlsdGVyIG91dCBldmVyeXRoaW5nIHRoYXQncyBsZWFmbGV0LnBtIHNwZWNpZmljIHRlbXBvcmFyeSBzdHVmZlxuICAgICAgICBsYXllcnMgPSBsYXllcnMuZmlsdGVyKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICAgICAgcmV0dXJuICFsYXllci5fcG1UZW1wTGF5ZXI7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0aGlzLmdsb2JhbEVkaXRFbmFibGVkKCkpIHtcbiAgICAgICAgICAgIC8vIGRpc2FibGVcblxuICAgICAgICAgICAgdGhpcy5fZ2xvYmFsRWRpdE1vZGUgPSBmYWxzZTtcblxuICAgICAgICAgICAgbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXIucG0uZGlzYWJsZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBlbmFibGVcblxuICAgICAgICAgICAgdGhpcy5fZ2xvYmFsRWRpdE1vZGUgPSB0cnVlO1xuXG4gICAgICAgICAgICBsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICBsYXllci5wbS5lbmFibGUob3B0aW9ucyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRvZ2dsZSB0aGUgYnV0dG9uIGluIHRoZSB0b29sYmFyXG4gICAgICAgIHRoaXMuVG9vbGJhci50b2dnbGVCdXR0b24oJ2VkaXRQb2x5Z29uJywgdGhpcy5fZ2xvYmFsRWRpdE1vZGUpO1xuICAgIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBNYXA7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvTC5QTS5NYXAuanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _L = __webpack_require__(19);\n\nvar _L2 = _interopRequireDefault(_L);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nL.Control.PMButton = _L2.default; /**\n                                  * The Icons used in this Toolbar are CC-BY Glyphicons - http://glyphicons.com/\n                                  */\n\nvar Toolbar = L.Class.extend({\n    options: {\n        drawMarker: true,\n        drawPolygon: true,\n        drawPolyline: true,\n        drawCircle: true,\n        editPolygon: true,\n        dragPolygon: false,\n        deleteLayer: true,\n        position: 'topleft'\n    },\n    initialize: function initialize(map) {\n        this.map = map;\n\n        this.buttons = {};\n        this.isVisible = false;\n        this.container = L.DomUtil.create('div', 'leaflet-pm-toolbar leaflet-bar leaflet-control');\n        this._defineButtons();\n    },\n    getButtons: function getButtons() {\n        return this.buttons;\n    },\n    addControls: function addControls() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options;\n\n        // adds all buttons to the map specified inside options\n\n        // first set the options\n        L.Util.setOptions(this, options);\n\n        // now show the specified buttons\n        this._showHideButtons();\n        this.isVisible = true;\n    },\n    removeControls: function removeControls() {\n        // grab all buttons to loop through\n        var buttons = this.getButtons();\n\n        // remove all buttons\n        for (var btn in buttons) {\n            buttons[btn].remove();\n        }\n\n        this.isVisible = false;\n    },\n    toggleControls: function toggleControls() {\n        if (this.isVisible) {\n            this.removeControls();\n        } else {\n            this.addControls();\n        }\n    },\n    _addButton: function _addButton(name, button) {\n        this.buttons[name] = button;\n        this.options[name] = this.options[name] || false;\n\n        return this.buttons[name];\n    },\n    triggerClickOnToggledButtons: function triggerClickOnToggledButtons(exceptThisButton) {\n        // this function is used when - e.g. drawing mode is enabled and a possible\n        // other active mode (like removal tool) is already active.\n        // we can't have two active modes because of possible event conflicts\n        // so, we trigger a click on all currently active (toggled) buttons\n\n        for (var name in this.buttons) {\n            if (this.buttons[name] !== exceptThisButton && this.buttons[name].toggled()) {\n                this.buttons[name]._triggerClick();\n            }\n        }\n    },\n    toggleButton: function toggleButton(name, status) {\n        // does not fire the events/functionality of the button\n        // this just changes the state and is used if a functionality (like Draw)\n        // is enabled manually via script\n\n        // as some mode got enabled, we still have to trigger the click on the other buttons\n        // to disable their mode\n        this.triggerClickOnToggledButtons(this.buttons[name]);\n\n        // now toggle the state of the button\n        return this.buttons[name].toggle(status);\n    },\n    _defineButtons: function _defineButtons() {\n        var _this = this;\n\n        // some buttons are still in their respective classes, like L.PM.Draw.Poly\n        var deleteButton = {\n            className: 'icon-delete',\n            onClick: function onClick() {},\n            afterClick: function afterClick() {\n                _this.map.pm.toggleGlobalRemovalMode();\n            },\n            doToggle: true,\n            toggleStatus: false,\n            disableOtherButtons: true,\n            position: this.options.position\n        };\n\n        var drawPolyButton = {\n            className: 'icon-polygon',\n            onClick: function onClick() {},\n            afterClick: function afterClick() {\n                // toggle drawing mode\n                _this.map.pm.Draw.Poly.toggle();\n            },\n            doToggle: true,\n            toggleStatus: false,\n            disableOtherButtons: true,\n            position: this.options.position\n        };\n\n        var drawMarkerButton = {\n            className: 'icon-marker',\n            onClick: function onClick() {},\n            afterClick: function afterClick() {\n                // toggle drawing mode\n                _this.map.pm.Draw.Marker.toggle();\n            },\n            doToggle: true,\n            toggleStatus: false,\n            disableOtherButtons: true,\n            position: this.options.position\n        };\n\n        var drawLineButton = {\n            className: 'icon-polyline',\n            onClick: function onClick() {},\n            afterClick: function afterClick() {\n                // toggle drawing mode\n                _this.map.pm.Draw.Line.toggle();\n            },\n            doToggle: true,\n            toggleStatus: false,\n            disableOtherButtons: true,\n            position: this.options.position\n        };\n\n        var drawCircleButton = {\n            className: 'icon-circle',\n            onClick: function onClick() {},\n            afterClick: function afterClick() {\n                // toggle drawing mode\n                _this.map.pm.Draw.Circle.toggle();\n            },\n            doToggle: true,\n            toggleStatus: false,\n            disableOtherButtons: true,\n            position: this.options.position\n        };\n\n        var editButton = {\n            className: 'icon-edit',\n            onClick: function onClick() {},\n            afterClick: function afterClick() {\n                _this.map.pm.toggleGlobalEditMode({\n                    snappable: true,\n                    draggable: true\n                });\n            },\n            doToggle: true,\n            toggleStatus: false,\n            disableOtherButtons: true,\n            position: this.options.position\n        };\n\n        var dragButton = {\n            className: 'icon-drag',\n            onClick: function onClick() {},\n            afterClick: function afterClick() {},\n            doToggle: true,\n            toggleStatus: false,\n            disableOtherButtons: true,\n            position: this.options.position\n        };\n\n        this._addButton('drawMarker', new L.Control.PMButton(drawMarkerButton));\n        this._addButton('drawPolygon', new L.Control.PMButton(drawPolyButton));\n        this._addButton('drawPolyline', new L.Control.PMButton(drawLineButton));\n        this._addButton('drawCircle', new L.Control.PMButton(drawCircleButton));\n        // TODO: rename editPolygon to editMode\n        this._addButton('editPolygon', new L.Control.PMButton(editButton));\n        this._addButton('dragPolygon', new L.Control.PMButton(dragButton));\n        // TODO: rename deleteLayer to removalMode\n        this._addButton('deleteLayer', new L.Control.PMButton(deleteButton));\n    },\n    _showHideButtons: function _showHideButtons() {\n        // remove all buttons, that's because the Toolbar can be added again with\n        // different options so it's basically a reset and add again\n        this.removeControls();\n\n        var buttons = this.getButtons();\n        for (var btn in buttons) {\n            if (this.options[btn]) {\n                // if options say the button should be visible, add it to the map\n                buttons[btn].setPosition(this.options.position);\n                buttons[btn].addTo(this.map);\n            }\n        }\n    }\n});\n\nexports.default = Toolbar;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvVG9vbGJhci9MLlBNLlRvb2xiYXIuanM/Y2RjOCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcblxudmFyIF9MID0gcmVxdWlyZSgnLi9MLkNvbnRyb2xzJyk7XG5cbnZhciBfTDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9MKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuTC5Db250cm9sLlBNQnV0dG9uID0gX0wyLmRlZmF1bHQ7IC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogVGhlIEljb25zIHVzZWQgaW4gdGhpcyBUb29sYmFyIGFyZSBDQy1CWSBHbHlwaGljb25zIC0gaHR0cDovL2dseXBoaWNvbnMuY29tL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG5cbnZhciBUb29sYmFyID0gTC5DbGFzcy5leHRlbmQoe1xuICAgIG9wdGlvbnM6IHtcbiAgICAgICAgZHJhd01hcmtlcjogdHJ1ZSxcbiAgICAgICAgZHJhd1BvbHlnb246IHRydWUsXG4gICAgICAgIGRyYXdQb2x5bGluZTogdHJ1ZSxcbiAgICAgICAgZHJhd0NpcmNsZTogdHJ1ZSxcbiAgICAgICAgZWRpdFBvbHlnb246IHRydWUsXG4gICAgICAgIGRyYWdQb2x5Z29uOiBmYWxzZSxcbiAgICAgICAgZGVsZXRlTGF5ZXI6IHRydWUsXG4gICAgICAgIHBvc2l0aW9uOiAndG9wbGVmdCdcbiAgICB9LFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uIGluaXRpYWxpemUobWFwKSB7XG4gICAgICAgIHRoaXMubWFwID0gbWFwO1xuXG4gICAgICAgIHRoaXMuYnV0dG9ucyA9IHt9O1xuICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LXBtLXRvb2xiYXIgbGVhZmxldC1iYXIgbGVhZmxldC1jb250cm9sJyk7XG4gICAgICAgIHRoaXMuX2RlZmluZUJ1dHRvbnMoKTtcbiAgICB9LFxuICAgIGdldEJ1dHRvbnM6IGZ1bmN0aW9uIGdldEJ1dHRvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1dHRvbnM7XG4gICAgfSxcbiAgICBhZGRDb250cm9sczogZnVuY3Rpb24gYWRkQ29udHJvbHMoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0aGlzLm9wdGlvbnM7XG5cbiAgICAgICAgLy8gYWRkcyBhbGwgYnV0dG9ucyB0byB0aGUgbWFwIHNwZWNpZmllZCBpbnNpZGUgb3B0aW9uc1xuXG4gICAgICAgIC8vIGZpcnN0IHNldCB0aGUgb3B0aW9uc1xuICAgICAgICBMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblxuICAgICAgICAvLyBub3cgc2hvdyB0aGUgc3BlY2lmaWVkIGJ1dHRvbnNcbiAgICAgICAgdGhpcy5fc2hvd0hpZGVCdXR0b25zKCk7XG4gICAgICAgIHRoaXMuaXNWaXNpYmxlID0gdHJ1ZTtcbiAgICB9LFxuICAgIHJlbW92ZUNvbnRyb2xzOiBmdW5jdGlvbiByZW1vdmVDb250cm9scygpIHtcbiAgICAgICAgLy8gZ3JhYiBhbGwgYnV0dG9ucyB0byBsb29wIHRocm91Z2hcbiAgICAgICAgdmFyIGJ1dHRvbnMgPSB0aGlzLmdldEJ1dHRvbnMoKTtcblxuICAgICAgICAvLyByZW1vdmUgYWxsIGJ1dHRvbnNcbiAgICAgICAgZm9yICh2YXIgYnRuIGluIGJ1dHRvbnMpIHtcbiAgICAgICAgICAgIGJ1dHRvbnNbYnRuXS5yZW1vdmUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuaXNWaXNpYmxlID0gZmFsc2U7XG4gICAgfSxcbiAgICB0b2dnbGVDb250cm9sczogZnVuY3Rpb24gdG9nZ2xlQ29udHJvbHMoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVDb250cm9scygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hZGRDb250cm9scygpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBfYWRkQnV0dG9uOiBmdW5jdGlvbiBfYWRkQnV0dG9uKG5hbWUsIGJ1dHRvbikge1xuICAgICAgICB0aGlzLmJ1dHRvbnNbbmFtZV0gPSBidXR0b247XG4gICAgICAgIHRoaXMub3B0aW9uc1tuYW1lXSA9IHRoaXMub3B0aW9uc1tuYW1lXSB8fCBmYWxzZTtcblxuICAgICAgICByZXR1cm4gdGhpcy5idXR0b25zW25hbWVdO1xuICAgIH0sXG4gICAgdHJpZ2dlckNsaWNrT25Ub2dnbGVkQnV0dG9uczogZnVuY3Rpb24gdHJpZ2dlckNsaWNrT25Ub2dnbGVkQnV0dG9ucyhleGNlcHRUaGlzQnV0dG9uKSB7XG4gICAgICAgIC8vIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCB3aGVuIC0gZS5nLiBkcmF3aW5nIG1vZGUgaXMgZW5hYmxlZCBhbmQgYSBwb3NzaWJsZVxuICAgICAgICAvLyBvdGhlciBhY3RpdmUgbW9kZSAobGlrZSByZW1vdmFsIHRvb2wpIGlzIGFscmVhZHkgYWN0aXZlLlxuICAgICAgICAvLyB3ZSBjYW4ndCBoYXZlIHR3byBhY3RpdmUgbW9kZXMgYmVjYXVzZSBvZiBwb3NzaWJsZSBldmVudCBjb25mbGljdHNcbiAgICAgICAgLy8gc28sIHdlIHRyaWdnZXIgYSBjbGljayBvbiBhbGwgY3VycmVudGx5IGFjdGl2ZSAodG9nZ2xlZCkgYnV0dG9uc1xuXG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcy5idXR0b25zKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5idXR0b25zW25hbWVdICE9PSBleGNlcHRUaGlzQnV0dG9uICYmIHRoaXMuYnV0dG9uc1tuYW1lXS50b2dnbGVkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbnNbbmFtZV0uX3RyaWdnZXJDbGljaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICB0b2dnbGVCdXR0b246IGZ1bmN0aW9uIHRvZ2dsZUJ1dHRvbihuYW1lLCBzdGF0dXMpIHtcbiAgICAgICAgLy8gZG9lcyBub3QgZmlyZSB0aGUgZXZlbnRzL2Z1bmN0aW9uYWxpdHkgb2YgdGhlIGJ1dHRvblxuICAgICAgICAvLyB0aGlzIGp1c3QgY2hhbmdlcyB0aGUgc3RhdGUgYW5kIGlzIHVzZWQgaWYgYSBmdW5jdGlvbmFsaXR5IChsaWtlIERyYXcpXG4gICAgICAgIC8vIGlzIGVuYWJsZWQgbWFudWFsbHkgdmlhIHNjcmlwdFxuXG4gICAgICAgIC8vIGFzIHNvbWUgbW9kZSBnb3QgZW5hYmxlZCwgd2Ugc3RpbGwgaGF2ZSB0byB0cmlnZ2VyIHRoZSBjbGljayBvbiB0aGUgb3RoZXIgYnV0dG9uc1xuICAgICAgICAvLyB0byBkaXNhYmxlIHRoZWlyIG1vZGVcbiAgICAgICAgdGhpcy50cmlnZ2VyQ2xpY2tPblRvZ2dsZWRCdXR0b25zKHRoaXMuYnV0dG9uc1tuYW1lXSk7XG5cbiAgICAgICAgLy8gbm93IHRvZ2dsZSB0aGUgc3RhdGUgb2YgdGhlIGJ1dHRvblxuICAgICAgICByZXR1cm4gdGhpcy5idXR0b25zW25hbWVdLnRvZ2dsZShzdGF0dXMpO1xuICAgIH0sXG4gICAgX2RlZmluZUJ1dHRvbnM6IGZ1bmN0aW9uIF9kZWZpbmVCdXR0b25zKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIC8vIHNvbWUgYnV0dG9ucyBhcmUgc3RpbGwgaW4gdGhlaXIgcmVzcGVjdGl2ZSBjbGFzc2VzLCBsaWtlIEwuUE0uRHJhdy5Qb2x5XG4gICAgICAgIHZhciBkZWxldGVCdXR0b24gPSB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICdpY29uLWRlbGV0ZScsXG4gICAgICAgICAgICBvbkNsaWNrOiBmdW5jdGlvbiBvbkNsaWNrKCkge30sXG4gICAgICAgICAgICBhZnRlckNsaWNrOiBmdW5jdGlvbiBhZnRlckNsaWNrKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLm1hcC5wbS50b2dnbGVHbG9iYWxSZW1vdmFsTW9kZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRvVG9nZ2xlOiB0cnVlLFxuICAgICAgICAgICAgdG9nZ2xlU3RhdHVzOiBmYWxzZSxcbiAgICAgICAgICAgIGRpc2FibGVPdGhlckJ1dHRvbnM6IHRydWUsXG4gICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5vcHRpb25zLnBvc2l0aW9uXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGRyYXdQb2x5QnV0dG9uID0ge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnaWNvbi1wb2x5Z29uJyxcbiAgICAgICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soKSB7fSxcbiAgICAgICAgICAgIGFmdGVyQ2xpY2s6IGZ1bmN0aW9uIGFmdGVyQ2xpY2soKSB7XG4gICAgICAgICAgICAgICAgLy8gdG9nZ2xlIGRyYXdpbmcgbW9kZVxuICAgICAgICAgICAgICAgIF90aGlzLm1hcC5wbS5EcmF3LlBvbHkudG9nZ2xlKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZG9Ub2dnbGU6IHRydWUsXG4gICAgICAgICAgICB0b2dnbGVTdGF0dXM6IGZhbHNlLFxuICAgICAgICAgICAgZGlzYWJsZU90aGVyQnV0dG9uczogdHJ1ZSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLm9wdGlvbnMucG9zaXRpb25cbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZHJhd01hcmtlckJ1dHRvbiA9IHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2ljb24tbWFya2VyJyxcbiAgICAgICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uIG9uQ2xpY2soKSB7fSxcbiAgICAgICAgICAgIGFmdGVyQ2xpY2s6IGZ1bmN0aW9uIGFmdGVyQ2xpY2soKSB7XG4gICAgICAgICAgICAgICAgLy8gdG9nZ2xlIGRyYXdpbmcgbW9kZVxuICAgICAgICAgICAgICAgIF90aGlzLm1hcC5wbS5EcmF3Lk1hcmtlci50b2dnbGUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkb1RvZ2dsZTogdHJ1ZSxcbiAgICAgICAgICAgIHRvZ2dsZVN0YXR1czogZmFsc2UsXG4gICAgICAgICAgICBkaXNhYmxlT3RoZXJCdXR0b25zOiB0cnVlLFxuICAgICAgICAgICAgcG9zaXRpb246IHRoaXMub3B0aW9ucy5wb3NpdGlvblxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBkcmF3TGluZUJ1dHRvbiA9IHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2ljb24tcG9seWxpbmUnLFxuICAgICAgICAgICAgb25DbGljazogZnVuY3Rpb24gb25DbGljaygpIHt9LFxuICAgICAgICAgICAgYWZ0ZXJDbGljazogZnVuY3Rpb24gYWZ0ZXJDbGljaygpIHtcbiAgICAgICAgICAgICAgICAvLyB0b2dnbGUgZHJhd2luZyBtb2RlXG4gICAgICAgICAgICAgICAgX3RoaXMubWFwLnBtLkRyYXcuTGluZS50b2dnbGUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkb1RvZ2dsZTogdHJ1ZSxcbiAgICAgICAgICAgIHRvZ2dsZVN0YXR1czogZmFsc2UsXG4gICAgICAgICAgICBkaXNhYmxlT3RoZXJCdXR0b25zOiB0cnVlLFxuICAgICAgICAgICAgcG9zaXRpb246IHRoaXMub3B0aW9ucy5wb3NpdGlvblxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBkcmF3Q2lyY2xlQnV0dG9uID0ge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnaWNvbi1jaXJjbGUnLFxuICAgICAgICAgICAgb25DbGljazogZnVuY3Rpb24gb25DbGljaygpIHt9LFxuICAgICAgICAgICAgYWZ0ZXJDbGljazogZnVuY3Rpb24gYWZ0ZXJDbGljaygpIHtcbiAgICAgICAgICAgICAgICAvLyB0b2dnbGUgZHJhd2luZyBtb2RlXG4gICAgICAgICAgICAgICAgX3RoaXMubWFwLnBtLkRyYXcuQ2lyY2xlLnRvZ2dsZSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRvVG9nZ2xlOiB0cnVlLFxuICAgICAgICAgICAgdG9nZ2xlU3RhdHVzOiBmYWxzZSxcbiAgICAgICAgICAgIGRpc2FibGVPdGhlckJ1dHRvbnM6IHRydWUsXG4gICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5vcHRpb25zLnBvc2l0aW9uXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGVkaXRCdXR0b24gPSB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICdpY29uLWVkaXQnLFxuICAgICAgICAgICAgb25DbGljazogZnVuY3Rpb24gb25DbGljaygpIHt9LFxuICAgICAgICAgICAgYWZ0ZXJDbGljazogZnVuY3Rpb24gYWZ0ZXJDbGljaygpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5tYXAucG0udG9nZ2xlR2xvYmFsRWRpdE1vZGUoe1xuICAgICAgICAgICAgICAgICAgICBzbmFwcGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGRyYWdnYWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRvVG9nZ2xlOiB0cnVlLFxuICAgICAgICAgICAgdG9nZ2xlU3RhdHVzOiBmYWxzZSxcbiAgICAgICAgICAgIGRpc2FibGVPdGhlckJ1dHRvbnM6IHRydWUsXG4gICAgICAgICAgICBwb3NpdGlvbjogdGhpcy5vcHRpb25zLnBvc2l0aW9uXG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGRyYWdCdXR0b24gPSB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICdpY29uLWRyYWcnLFxuICAgICAgICAgICAgb25DbGljazogZnVuY3Rpb24gb25DbGljaygpIHt9LFxuICAgICAgICAgICAgYWZ0ZXJDbGljazogZnVuY3Rpb24gYWZ0ZXJDbGljaygpIHt9LFxuICAgICAgICAgICAgZG9Ub2dnbGU6IHRydWUsXG4gICAgICAgICAgICB0b2dnbGVTdGF0dXM6IGZhbHNlLFxuICAgICAgICAgICAgZGlzYWJsZU90aGVyQnV0dG9uczogdHJ1ZSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiB0aGlzLm9wdGlvbnMucG9zaXRpb25cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLl9hZGRCdXR0b24oJ2RyYXdNYXJrZXInLCBuZXcgTC5Db250cm9sLlBNQnV0dG9uKGRyYXdNYXJrZXJCdXR0b24pKTtcbiAgICAgICAgdGhpcy5fYWRkQnV0dG9uKCdkcmF3UG9seWdvbicsIG5ldyBMLkNvbnRyb2wuUE1CdXR0b24oZHJhd1BvbHlCdXR0b24pKTtcbiAgICAgICAgdGhpcy5fYWRkQnV0dG9uKCdkcmF3UG9seWxpbmUnLCBuZXcgTC5Db250cm9sLlBNQnV0dG9uKGRyYXdMaW5lQnV0dG9uKSk7XG4gICAgICAgIHRoaXMuX2FkZEJ1dHRvbignZHJhd0NpcmNsZScsIG5ldyBMLkNvbnRyb2wuUE1CdXR0b24oZHJhd0NpcmNsZUJ1dHRvbikpO1xuICAgICAgICAvLyBUT0RPOiByZW5hbWUgZWRpdFBvbHlnb24gdG8gZWRpdE1vZGVcbiAgICAgICAgdGhpcy5fYWRkQnV0dG9uKCdlZGl0UG9seWdvbicsIG5ldyBMLkNvbnRyb2wuUE1CdXR0b24oZWRpdEJ1dHRvbikpO1xuICAgICAgICB0aGlzLl9hZGRCdXR0b24oJ2RyYWdQb2x5Z29uJywgbmV3IEwuQ29udHJvbC5QTUJ1dHRvbihkcmFnQnV0dG9uKSk7XG4gICAgICAgIC8vIFRPRE86IHJlbmFtZSBkZWxldGVMYXllciB0byByZW1vdmFsTW9kZVxuICAgICAgICB0aGlzLl9hZGRCdXR0b24oJ2RlbGV0ZUxheWVyJywgbmV3IEwuQ29udHJvbC5QTUJ1dHRvbihkZWxldGVCdXR0b24pKTtcbiAgICB9LFxuICAgIF9zaG93SGlkZUJ1dHRvbnM6IGZ1bmN0aW9uIF9zaG93SGlkZUJ1dHRvbnMoKSB7XG4gICAgICAgIC8vIHJlbW92ZSBhbGwgYnV0dG9ucywgdGhhdCdzIGJlY2F1c2UgdGhlIFRvb2xiYXIgY2FuIGJlIGFkZGVkIGFnYWluIHdpdGhcbiAgICAgICAgLy8gZGlmZmVyZW50IG9wdGlvbnMgc28gaXQncyBiYXNpY2FsbHkgYSByZXNldCBhbmQgYWRkIGFnYWluXG4gICAgICAgIHRoaXMucmVtb3ZlQ29udHJvbHMoKTtcblxuICAgICAgICB2YXIgYnV0dG9ucyA9IHRoaXMuZ2V0QnV0dG9ucygpO1xuICAgICAgICBmb3IgKHZhciBidG4gaW4gYnV0dG9ucykge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9uc1tidG5dKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgb3B0aW9ucyBzYXkgdGhlIGJ1dHRvbiBzaG91bGQgYmUgdmlzaWJsZSwgYWRkIGl0IHRvIHRoZSBtYXBcbiAgICAgICAgICAgICAgICBidXR0b25zW2J0bl0uc2V0UG9zaXRpb24odGhpcy5vcHRpb25zLnBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICBidXR0b25zW2J0bl0uYWRkVG8odGhpcy5tYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFRvb2xiYXI7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvVG9vbGJhci9MLlBNLlRvb2xiYXIuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 14 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTQuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY3NzL2NvbnRyb2xzLmNzcz8xMGE4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHJlbW92ZWQgYnkgZXh0cmFjdC10ZXh0LXdlYnBhY2stcGx1Z2luXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvY3NzL2NvbnRyb2xzLmNzc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ }),
/* 15 */
/***/ (function(module, exports) {

eval("// removed by extract-text-webpack-plugin//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTUuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvY3NzL2xheWVycy5jc3M/NTM3NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vc3JjL2Nzcy9sYXllcnMuY3NzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 16 */
/***/ (function(module, exports) {

eval("module.exports = {\n\t\"name\": \"leaflet.pm\",\n\t\"version\": \"0.16.0\",\n\t\"description\": \"A Leaflet Plugin For Editing Geometry Layers in Leaflet 1.0\",\n\t\"keywords\": [\n\t\t\"leaflet\",\n\t\t\"polygon management\",\n\t\t\"geometry editing\",\n\t\t\"map data\",\n\t\t\"map overlay\",\n\t\t\"polygon\",\n\t\t\"geojson\",\n\t\t\"leaflet-draw\",\n\t\t\"data-field-geojson\",\n\t\t\"ui-leaflet-draw\"\n\t],\n\t\"files\": [\n\t\t\"dist\"\n\t],\n\t\"main\": \"dist/leaflet.pm.min.js\",\n\t\"dependencies\": {},\n\t\"devDependencies\": {\n\t\t\"babel-core\": \"^6.24.1\",\n\t\t\"babel-loader\": \"^7.0.0\",\n\t\t\"babel-preset-env\": \"^1.4.0\",\n\t\t\"css-loader\": \"^0.28.0\",\n\t\t\"eslint\": \"^3.5.0\",\n\t\t\"eslint-config-airbnb-base\": \"^7.1.0\",\n\t\t\"eslint-plugin-import\": \"^1.15.0\",\n\t\t\"extract-text-webpack-plugin\": \"^2.1.0\",\n\t\t\"file-loader\": \"^0.11.1\",\n\t\t\"style-loader\": \"^0.16.1\",\n\t\t\"tape\": \"^4.6.2\",\n\t\t\"tape-run\": \"^2.1.4\",\n\t\t\"url-loader\": \"^0.5.8\",\n\t\t\"webpack\": \"^2.4.1\"\n\t},\n\t\"peerDependencies\": {\n\t\t\"leaflet\": \"^1.0.2\"\n\t},\n\t\"scripts\": {\n\t\t\"dev\": \"./node_modules/.bin/webpack --config=webpack.dev.js\",\n\t\t\"prepare\": \"./node_modules/.bin/webpack --config=webpack.build.js\"\n\t},\n\t\"repository\": {\n\t\t\"type\": \"git\",\n\t\t\"url\": \"git+https://github.com/codeofsumit/leaflet.pm.git\"\n\t},\n\t\"author\": {\n\t\t\"name\": \"Sumit Kumar\",\n\t\t\"email\": \"sk@outlook.com\",\n\t\t\"url\": \"http://twitter.com/TweetsOfSumit\"\n\t},\n\t\"license\": \"MIT\",\n\t\"bugs\": {\n\t\t\"url\": \"https://github.com/codeofsumit/leaflet.pm/issues\"\n\t},\n\t\"homepage\": \"https://codeofsumit.github.io/leaflet.pm/\"\n};//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTYuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9wYWNrYWdlLmpzb24/ZWQ4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHtcblx0XCJuYW1lXCI6IFwibGVhZmxldC5wbVwiLFxuXHRcInZlcnNpb25cIjogXCIwLjE2LjBcIixcblx0XCJkZXNjcmlwdGlvblwiOiBcIkEgTGVhZmxldCBQbHVnaW4gRm9yIEVkaXRpbmcgR2VvbWV0cnkgTGF5ZXJzIGluIExlYWZsZXQgMS4wXCIsXG5cdFwia2V5d29yZHNcIjogW1xuXHRcdFwibGVhZmxldFwiLFxuXHRcdFwicG9seWdvbiBtYW5hZ2VtZW50XCIsXG5cdFx0XCJnZW9tZXRyeSBlZGl0aW5nXCIsXG5cdFx0XCJtYXAgZGF0YVwiLFxuXHRcdFwibWFwIG92ZXJsYXlcIixcblx0XHRcInBvbHlnb25cIixcblx0XHRcImdlb2pzb25cIixcblx0XHRcImxlYWZsZXQtZHJhd1wiLFxuXHRcdFwiZGF0YS1maWVsZC1nZW9qc29uXCIsXG5cdFx0XCJ1aS1sZWFmbGV0LWRyYXdcIlxuXHRdLFxuXHRcImZpbGVzXCI6IFtcblx0XHRcImRpc3RcIlxuXHRdLFxuXHRcIm1haW5cIjogXCJkaXN0L2xlYWZsZXQucG0ubWluLmpzXCIsXG5cdFwiZGVwZW5kZW5jaWVzXCI6IHt9LFxuXHRcImRldkRlcGVuZGVuY2llc1wiOiB7XG5cdFx0XCJiYWJlbC1jb3JlXCI6IFwiXjYuMjQuMVwiLFxuXHRcdFwiYmFiZWwtbG9hZGVyXCI6IFwiXjcuMC4wXCIsXG5cdFx0XCJiYWJlbC1wcmVzZXQtZW52XCI6IFwiXjEuNC4wXCIsXG5cdFx0XCJjc3MtbG9hZGVyXCI6IFwiXjAuMjguMFwiLFxuXHRcdFwiZXNsaW50XCI6IFwiXjMuNS4wXCIsXG5cdFx0XCJlc2xpbnQtY29uZmlnLWFpcmJuYi1iYXNlXCI6IFwiXjcuMS4wXCIsXG5cdFx0XCJlc2xpbnQtcGx1Z2luLWltcG9ydFwiOiBcIl4xLjE1LjBcIixcblx0XHRcImV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblwiOiBcIl4yLjEuMFwiLFxuXHRcdFwiZmlsZS1sb2FkZXJcIjogXCJeMC4xMS4xXCIsXG5cdFx0XCJzdHlsZS1sb2FkZXJcIjogXCJeMC4xNi4xXCIsXG5cdFx0XCJ0YXBlXCI6IFwiXjQuNi4yXCIsXG5cdFx0XCJ0YXBlLXJ1blwiOiBcIl4yLjEuNFwiLFxuXHRcdFwidXJsLWxvYWRlclwiOiBcIl4wLjUuOFwiLFxuXHRcdFwid2VicGFja1wiOiBcIl4yLjQuMVwiXG5cdH0sXG5cdFwicGVlckRlcGVuZGVuY2llc1wiOiB7XG5cdFx0XCJsZWFmbGV0XCI6IFwiXjEuMC4yXCJcblx0fSxcblx0XCJzY3JpcHRzXCI6IHtcblx0XHRcImRldlwiOiBcIi4vbm9kZV9tb2R1bGVzLy5iaW4vd2VicGFjayAtLWNvbmZpZz13ZWJwYWNrLmRldi5qc1wiLFxuXHRcdFwicHJlcGFyZVwiOiBcIi4vbm9kZV9tb2R1bGVzLy5iaW4vd2VicGFjayAtLWNvbmZpZz13ZWJwYWNrLmJ1aWxkLmpzXCJcblx0fSxcblx0XCJyZXBvc2l0b3J5XCI6IHtcblx0XHRcInR5cGVcIjogXCJnaXRcIixcblx0XHRcInVybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vY29kZW9mc3VtaXQvbGVhZmxldC5wbS5naXRcIlxuXHR9LFxuXHRcImF1dGhvclwiOiB7XG5cdFx0XCJuYW1lXCI6IFwiU3VtaXQgS3VtYXJcIixcblx0XHRcImVtYWlsXCI6IFwic2tAb3V0bG9vay5jb21cIixcblx0XHRcInVybFwiOiBcImh0dHA6Ly90d2l0dGVyLmNvbS9Ud2VldHNPZlN1bWl0XCJcblx0fSxcblx0XCJsaWNlbnNlXCI6IFwiTUlUXCIsXG5cdFwiYnVnc1wiOiB7XG5cdFx0XCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vY29kZW9mc3VtaXQvbGVhZmxldC5wbS9pc3N1ZXNcIlxuXHR9LFxuXHRcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9jb2Rlb2ZzdW1pdC5naXRodWIuaW8vbGVhZmxldC5wbS9cIlxufTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3BhY2thZ2UuanNvblxuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9");

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _package = __webpack_require__(16);\n\nvar _LPM = __webpack_require__(12);\n\nvar _LPM2 = _interopRequireDefault(_LPM);\n\nvar _LPM3 = __webpack_require__(13);\n\nvar _LPM4 = _interopRequireDefault(_LPM3);\n\nvar _LPM5 = __webpack_require__(1);\n\nvar _LPM6 = _interopRequireDefault(_LPM5);\n\n__webpack_require__(3);\n\n__webpack_require__(4);\n\n__webpack_require__(6);\n\n__webpack_require__(5);\n\nvar _LPM7 = __webpack_require__(0);\n\nvar _LPM8 = _interopRequireDefault(_LPM7);\n\n__webpack_require__(9);\n\n__webpack_require__(11);\n\n__webpack_require__(7);\n\n__webpack_require__(10);\n\n__webpack_require__(8);\n\n__webpack_require__(15);\n\n__webpack_require__(14);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n*\n* A Leaflet Plugin For Editing Geometry Layers in Leaflet 1.0\n* by Sumit Kumar (@TweetsOfSumit)\n* Github Repo: https://github.com/codeofsumit/leaflet.pm\n*/\n\nL.PM = L.PM || {\n    Map: _LPM2.default,\n    Toolbar: _LPM4.default,\n    Draw: _LPM6.default,\n    Edit: _LPM8.default,\n    version: _package.version,\n    initialize: function initialize() {\n        this.addInitHooks();\n    },\n    addInitHooks: function addInitHooks() {\n        function initLayerGroup() {\n            this.pm = new L.PM.Edit.LayerGroup(this);\n        }\n\n        L.LayerGroup.addInitHook(initLayerGroup);\n\n        function initMarker() {\n            this.pm = new L.PM.Edit.Marker(this);\n        }\n\n        L.Marker.addInitHook(initMarker);\n\n        function initPolygon() {\n            this.pm = new L.PM.Edit.Poly(this);\n        }\n\n        L.Polygon.addInitHook(initPolygon);\n\n        function initPolyline() {\n            this.pm = new L.PM.Edit.Line(this);\n        }\n\n        L.Polyline.addInitHook(initPolyline);\n\n        function initCircle() {\n            this.pm = new L.PM.Edit.Circle(this);\n        }\n\n        L.Circle.addInitHook(initCircle);\n\n        function initMap() {\n            this.pm = new L.PM.Map(this);\n        }\n\n        L.Map.addInitHook(initMap);\n    }\n};\n\n// initialize leaflet.pm\nL.PM.initialize();//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTcuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvTC5QTS5qcz9jNDI1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF9wYWNrYWdlID0gcmVxdWlyZSgnLi4vLi4vcGFja2FnZS5qc29uJyk7XG5cbnZhciBfTFBNID0gcmVxdWlyZSgnLi9MLlBNLk1hcCcpO1xuXG52YXIgX0xQTTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9MUE0pO1xuXG52YXIgX0xQTTMgPSByZXF1aXJlKCcuL1Rvb2xiYXIvTC5QTS5Ub29sYmFyJyk7XG5cbnZhciBfTFBNNCA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xQTTMpO1xuXG52YXIgX0xQTTUgPSByZXF1aXJlKCcuL0RyYXcvTC5QTS5EcmF3Jyk7XG5cbnZhciBfTFBNNiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xQTTUpO1xuXG5yZXF1aXJlKCcuL0RyYXcvTC5QTS5EcmF3LkNpcmNsZScpO1xuXG5yZXF1aXJlKCcuL0RyYXcvTC5QTS5EcmF3LkxpbmUnKTtcblxucmVxdWlyZSgnLi9EcmF3L0wuUE0uRHJhdy5Qb2x5Jyk7XG5cbnJlcXVpcmUoJy4vRHJhdy9MLlBNLkRyYXcuTWFya2VyJyk7XG5cbnZhciBfTFBNNyA9IHJlcXVpcmUoJy4vRWRpdC9MLlBNLkVkaXQnKTtcblxudmFyIF9MUE04ID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTFBNNyk7XG5cbnJlcXVpcmUoJy4vRWRpdC9MLlBNLkVkaXQuTGluZScpO1xuXG5yZXF1aXJlKCcuL0VkaXQvTC5QTS5FZGl0LlBvbHknKTtcblxucmVxdWlyZSgnLi9FZGl0L0wuUE0uRWRpdC5DaXJjbGUnKTtcblxucmVxdWlyZSgnLi9FZGl0L0wuUE0uRWRpdC5NYXJrZXInKTtcblxucmVxdWlyZSgnLi9FZGl0L0wuUE0uRWRpdC5MYXllckdyb3VwJyk7XG5cbnJlcXVpcmUoJy4uL2Nzcy9sYXllcnMuY3NzJyk7XG5cbnJlcXVpcmUoJy4uL2Nzcy9jb250cm9scy5jc3MnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4qXG4qIEEgTGVhZmxldCBQbHVnaW4gRm9yIEVkaXRpbmcgR2VvbWV0cnkgTGF5ZXJzIGluIExlYWZsZXQgMS4wXG4qIGJ5IFN1bWl0IEt1bWFyIChAVHdlZXRzT2ZTdW1pdClcbiogR2l0aHViIFJlcG86IGh0dHBzOi8vZ2l0aHViLmNvbS9jb2Rlb2ZzdW1pdC9sZWFmbGV0LnBtXG4qL1xuXG5MLlBNID0gTC5QTSB8fCB7XG4gICAgTWFwOiBfTFBNMi5kZWZhdWx0LFxuICAgIFRvb2xiYXI6IF9MUE00LmRlZmF1bHQsXG4gICAgRHJhdzogX0xQTTYuZGVmYXVsdCxcbiAgICBFZGl0OiBfTFBNOC5kZWZhdWx0LFxuICAgIHZlcnNpb246IF9wYWNrYWdlLnZlcnNpb24sXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgdGhpcy5hZGRJbml0SG9va3MoKTtcbiAgICB9LFxuICAgIGFkZEluaXRIb29rczogZnVuY3Rpb24gYWRkSW5pdEhvb2tzKCkge1xuICAgICAgICBmdW5jdGlvbiBpbml0TGF5ZXJHcm91cCgpIHtcbiAgICAgICAgICAgIHRoaXMucG0gPSBuZXcgTC5QTS5FZGl0LkxheWVyR3JvdXAodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBMLkxheWVyR3JvdXAuYWRkSW5pdEhvb2soaW5pdExheWVyR3JvdXApO1xuXG4gICAgICAgIGZ1bmN0aW9uIGluaXRNYXJrZXIoKSB7XG4gICAgICAgICAgICB0aGlzLnBtID0gbmV3IEwuUE0uRWRpdC5NYXJrZXIodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBMLk1hcmtlci5hZGRJbml0SG9vayhpbml0TWFya2VyKTtcblxuICAgICAgICBmdW5jdGlvbiBpbml0UG9seWdvbigpIHtcbiAgICAgICAgICAgIHRoaXMucG0gPSBuZXcgTC5QTS5FZGl0LlBvbHkodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBMLlBvbHlnb24uYWRkSW5pdEhvb2soaW5pdFBvbHlnb24pO1xuXG4gICAgICAgIGZ1bmN0aW9uIGluaXRQb2x5bGluZSgpIHtcbiAgICAgICAgICAgIHRoaXMucG0gPSBuZXcgTC5QTS5FZGl0LkxpbmUodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICBMLlBvbHlsaW5lLmFkZEluaXRIb29rKGluaXRQb2x5bGluZSk7XG5cbiAgICAgICAgZnVuY3Rpb24gaW5pdENpcmNsZSgpIHtcbiAgICAgICAgICAgIHRoaXMucG0gPSBuZXcgTC5QTS5FZGl0LkNpcmNsZSh0aGlzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIEwuQ2lyY2xlLmFkZEluaXRIb29rKGluaXRDaXJjbGUpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGluaXRNYXAoKSB7XG4gICAgICAgICAgICB0aGlzLnBtID0gbmV3IEwuUE0uTWFwKHRoaXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgTC5NYXAuYWRkSW5pdEhvb2soaW5pdE1hcCk7XG4gICAgfVxufTtcblxuLy8gaW5pdGlhbGl6ZSBsZWFmbGV0LnBtXG5MLlBNLmluaXRpYWxpemUoKTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9MLlBNLmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar DragMixin = {\n    _initDraggableLayer: function _initDraggableLayer() {\n        // temporary coord variable for delta calculation\n        this._tempDragCoord = null;\n\n        // add CSS class\n        var el = this._layer._path;\n        L.DomUtil.addClass(el, 'leaflet-pm-draggable');\n\n        this._layer.on('mousedown', this._dragMixinOnMouseDown, this);\n    },\n    _dragMixinOnMouseUp: function _dragMixinOnMouseUp() {\n        var _this = this;\n\n        var el = this._layer._path;\n\n        // re-enable map drag\n        this._layer._map.dragging.enable();\n\n        // clear up mousemove event\n        this._layer._map.off('mousemove', this._dragMixinOnMouseMove, this);\n\n        // clear up mouseup event\n        this._layer.off('mouseup', this._dragMixinOnMouseUp, this);\n\n        // if no drag happened, don't do anything\n        if (!this._dragging) {\n            return false;\n        }\n\n        // show markers again\n        this._initMarkers();\n\n        // timeout to prevent click event after drag :-/\n        // TODO: do it better as soon as leaflet has a way to do it better :-)\n        window.setTimeout(function () {\n            // set state\n            _this._dragging = false;\n            L.DomUtil.removeClass(el, 'leaflet-pm-dragging');\n\n            // fire pm:dragend event\n            _this._layer.fire('pm:dragend');\n\n            // fire edit\n            _this._fireEdit();\n        }, 10);\n\n        return true;\n    },\n    _dragMixinOnMouseMove: function _dragMixinOnMouseMove(e) {\n        var el = this._layer._path;\n\n        if (!this._dragging) {\n            // set state\n            this._dragging = true;\n            L.DomUtil.addClass(el, 'leaflet-pm-dragging');\n\n            // bring it to front to prevent drag interception\n            this._layer.bringToFront();\n\n            // disbale map drag\n            this._layer._map.dragging.disable();\n\n            // hide markers\n            this._markerGroup.clearLayers();\n\n            // fire pm:dragstart event\n            this._layer.fire('pm:dragstart');\n        }\n\n        this._onLayerDrag(e);\n    },\n    _dragMixinOnMouseDown: function _dragMixinOnMouseDown(e) {\n        // save for delta calculation\n        this._tempDragCoord = e.latlng;\n\n        this._layer.on('mouseup', this._dragMixinOnMouseUp, this);\n\n        // listen to mousemove on map (instead of polygon),\n        // otherwise fast mouse movements stop the drag\n        this._layer._map.on('mousemove', this._dragMixinOnMouseMove, this);\n    },\n    dragging: function dragging() {\n        return this._dragging;\n    },\n    _onLayerDrag: function _onLayerDrag(e) {\n        // latLng of mouse event\n        var latlng = e.latlng;\n\n        // delta coords (how far was dragged)\n        var deltaLatLng = {\n            lat: latlng.lat - this._tempDragCoord.lat,\n            lng: latlng.lng - this._tempDragCoord.lng\n        };\n\n        // create the new coordinates array\n        var coords = void 0;\n\n        if (this._layer instanceof L.Polygon) {\n            coords = this._layer._latlngs[0];\n        } else {\n            coords = this._layer._latlngs;\n        }\n\n        var newLatLngs = coords.map(function (currentLatLng) {\n            var c = {\n                lat: currentLatLng.lat + deltaLatLng.lat,\n                lng: currentLatLng.lng + deltaLatLng.lng\n            };\n            return c;\n        });\n\n        // set new coordinates and redraw\n        this._layer.setLatLngs(newLatLngs).redraw();\n\n        // save current latlng for next delta calculation\n        this._tempDragCoord = latlng;\n\n        // fire pm:dragstart event\n        this._layer.fire('pm:drag');\n    }\n};\n\nexports.default = DragMixin;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTguanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvTWl4aW5zL0RyYWcuanM/OThmNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbnZhciBEcmFnTWl4aW4gPSB7XG4gICAgX2luaXREcmFnZ2FibGVMYXllcjogZnVuY3Rpb24gX2luaXREcmFnZ2FibGVMYXllcigpIHtcbiAgICAgICAgLy8gdGVtcG9yYXJ5IGNvb3JkIHZhcmlhYmxlIGZvciBkZWx0YSBjYWxjdWxhdGlvblxuICAgICAgICB0aGlzLl90ZW1wRHJhZ0Nvb3JkID0gbnVsbDtcblxuICAgICAgICAvLyBhZGQgQ1NTIGNsYXNzXG4gICAgICAgIHZhciBlbCA9IHRoaXMuX2xheWVyLl9wYXRoO1xuICAgICAgICBMLkRvbVV0aWwuYWRkQ2xhc3MoZWwsICdsZWFmbGV0LXBtLWRyYWdnYWJsZScpO1xuXG4gICAgICAgIHRoaXMuX2xheWVyLm9uKCdtb3VzZWRvd24nLCB0aGlzLl9kcmFnTWl4aW5Pbk1vdXNlRG93biwgdGhpcyk7XG4gICAgfSxcbiAgICBfZHJhZ01peGluT25Nb3VzZVVwOiBmdW5jdGlvbiBfZHJhZ01peGluT25Nb3VzZVVwKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBlbCA9IHRoaXMuX2xheWVyLl9wYXRoO1xuXG4gICAgICAgIC8vIHJlLWVuYWJsZSBtYXAgZHJhZ1xuICAgICAgICB0aGlzLl9sYXllci5fbWFwLmRyYWdnaW5nLmVuYWJsZSgpO1xuXG4gICAgICAgIC8vIGNsZWFyIHVwIG1vdXNlbW92ZSBldmVudFxuICAgICAgICB0aGlzLl9sYXllci5fbWFwLm9mZignbW91c2Vtb3ZlJywgdGhpcy5fZHJhZ01peGluT25Nb3VzZU1vdmUsIHRoaXMpO1xuXG4gICAgICAgIC8vIGNsZWFyIHVwIG1vdXNldXAgZXZlbnRcbiAgICAgICAgdGhpcy5fbGF5ZXIub2ZmKCdtb3VzZXVwJywgdGhpcy5fZHJhZ01peGluT25Nb3VzZVVwLCB0aGlzKTtcblxuICAgICAgICAvLyBpZiBubyBkcmFnIGhhcHBlbmVkLCBkb24ndCBkbyBhbnl0aGluZ1xuICAgICAgICBpZiAoIXRoaXMuX2RyYWdnaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBzaG93IG1hcmtlcnMgYWdhaW5cbiAgICAgICAgdGhpcy5faW5pdE1hcmtlcnMoKTtcblxuICAgICAgICAvLyB0aW1lb3V0IHRvIHByZXZlbnQgY2xpY2sgZXZlbnQgYWZ0ZXIgZHJhZyA6LS9cbiAgICAgICAgLy8gVE9ETzogZG8gaXQgYmV0dGVyIGFzIHNvb24gYXMgbGVhZmxldCBoYXMgYSB3YXkgdG8gZG8gaXQgYmV0dGVyIDotKVxuICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBzZXQgc3RhdGVcbiAgICAgICAgICAgIF90aGlzLl9kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgTC5Eb21VdGlsLnJlbW92ZUNsYXNzKGVsLCAnbGVhZmxldC1wbS1kcmFnZ2luZycpO1xuXG4gICAgICAgICAgICAvLyBmaXJlIHBtOmRyYWdlbmQgZXZlbnRcbiAgICAgICAgICAgIF90aGlzLl9sYXllci5maXJlKCdwbTpkcmFnZW5kJyk7XG5cbiAgICAgICAgICAgIC8vIGZpcmUgZWRpdFxuICAgICAgICAgICAgX3RoaXMuX2ZpcmVFZGl0KCk7XG4gICAgICAgIH0sIDEwKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIF9kcmFnTWl4aW5Pbk1vdXNlTW92ZTogZnVuY3Rpb24gX2RyYWdNaXhpbk9uTW91c2VNb3ZlKGUpIHtcbiAgICAgICAgdmFyIGVsID0gdGhpcy5fbGF5ZXIuX3BhdGg7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9kcmFnZ2luZykge1xuICAgICAgICAgICAgLy8gc2V0IHN0YXRlXG4gICAgICAgICAgICB0aGlzLl9kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICBMLkRvbVV0aWwuYWRkQ2xhc3MoZWwsICdsZWFmbGV0LXBtLWRyYWdnaW5nJyk7XG5cbiAgICAgICAgICAgIC8vIGJyaW5nIGl0IHRvIGZyb250IHRvIHByZXZlbnQgZHJhZyBpbnRlcmNlcHRpb25cbiAgICAgICAgICAgIHRoaXMuX2xheWVyLmJyaW5nVG9Gcm9udCgpO1xuXG4gICAgICAgICAgICAvLyBkaXNiYWxlIG1hcCBkcmFnXG4gICAgICAgICAgICB0aGlzLl9sYXllci5fbWFwLmRyYWdnaW5nLmRpc2FibGUoKTtcblxuICAgICAgICAgICAgLy8gaGlkZSBtYXJrZXJzXG4gICAgICAgICAgICB0aGlzLl9tYXJrZXJHcm91cC5jbGVhckxheWVycygpO1xuXG4gICAgICAgICAgICAvLyBmaXJlIHBtOmRyYWdzdGFydCBldmVudFxuICAgICAgICAgICAgdGhpcy5fbGF5ZXIuZmlyZSgncG06ZHJhZ3N0YXJ0Jyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9vbkxheWVyRHJhZyhlKTtcbiAgICB9LFxuICAgIF9kcmFnTWl4aW5Pbk1vdXNlRG93bjogZnVuY3Rpb24gX2RyYWdNaXhpbk9uTW91c2VEb3duKGUpIHtcbiAgICAgICAgLy8gc2F2ZSBmb3IgZGVsdGEgY2FsY3VsYXRpb25cbiAgICAgICAgdGhpcy5fdGVtcERyYWdDb29yZCA9IGUubGF0bG5nO1xuXG4gICAgICAgIHRoaXMuX2xheWVyLm9uKCdtb3VzZXVwJywgdGhpcy5fZHJhZ01peGluT25Nb3VzZVVwLCB0aGlzKTtcblxuICAgICAgICAvLyBsaXN0ZW4gdG8gbW91c2Vtb3ZlIG9uIG1hcCAoaW5zdGVhZCBvZiBwb2x5Z29uKSxcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGZhc3QgbW91c2UgbW92ZW1lbnRzIHN0b3AgdGhlIGRyYWdcbiAgICAgICAgdGhpcy5fbGF5ZXIuX21hcC5vbignbW91c2Vtb3ZlJywgdGhpcy5fZHJhZ01peGluT25Nb3VzZU1vdmUsIHRoaXMpO1xuICAgIH0sXG4gICAgZHJhZ2dpbmc6IGZ1bmN0aW9uIGRyYWdnaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZHJhZ2dpbmc7XG4gICAgfSxcbiAgICBfb25MYXllckRyYWc6IGZ1bmN0aW9uIF9vbkxheWVyRHJhZyhlKSB7XG4gICAgICAgIC8vIGxhdExuZyBvZiBtb3VzZSBldmVudFxuICAgICAgICB2YXIgbGF0bG5nID0gZS5sYXRsbmc7XG5cbiAgICAgICAgLy8gZGVsdGEgY29vcmRzIChob3cgZmFyIHdhcyBkcmFnZ2VkKVxuICAgICAgICB2YXIgZGVsdGFMYXRMbmcgPSB7XG4gICAgICAgICAgICBsYXQ6IGxhdGxuZy5sYXQgLSB0aGlzLl90ZW1wRHJhZ0Nvb3JkLmxhdCxcbiAgICAgICAgICAgIGxuZzogbGF0bG5nLmxuZyAtIHRoaXMuX3RlbXBEcmFnQ29vcmQubG5nXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gY3JlYXRlIHRoZSBuZXcgY29vcmRpbmF0ZXMgYXJyYXlcbiAgICAgICAgdmFyIGNvb3JkcyA9IHZvaWQgMDtcblxuICAgICAgICBpZiAodGhpcy5fbGF5ZXIgaW5zdGFuY2VvZiBMLlBvbHlnb24pIHtcbiAgICAgICAgICAgIGNvb3JkcyA9IHRoaXMuX2xheWVyLl9sYXRsbmdzWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29vcmRzID0gdGhpcy5fbGF5ZXIuX2xhdGxuZ3M7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV3TGF0TG5ncyA9IGNvb3Jkcy5tYXAoZnVuY3Rpb24gKGN1cnJlbnRMYXRMbmcpIHtcbiAgICAgICAgICAgIHZhciBjID0ge1xuICAgICAgICAgICAgICAgIGxhdDogY3VycmVudExhdExuZy5sYXQgKyBkZWx0YUxhdExuZy5sYXQsXG4gICAgICAgICAgICAgICAgbG5nOiBjdXJyZW50TGF0TG5nLmxuZyArIGRlbHRhTGF0TG5nLmxuZ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBzZXQgbmV3IGNvb3JkaW5hdGVzIGFuZCByZWRyYXdcbiAgICAgICAgdGhpcy5fbGF5ZXIuc2V0TGF0TG5ncyhuZXdMYXRMbmdzKS5yZWRyYXcoKTtcblxuICAgICAgICAvLyBzYXZlIGN1cnJlbnQgbGF0bG5nIGZvciBuZXh0IGRlbHRhIGNhbGN1bGF0aW9uXG4gICAgICAgIHRoaXMuX3RlbXBEcmFnQ29vcmQgPSBsYXRsbmc7XG5cbiAgICAgICAgLy8gZmlyZSBwbTpkcmFnc3RhcnQgZXZlbnRcbiAgICAgICAgdGhpcy5fbGF5ZXIuZmlyZSgncG06ZHJhZycpO1xuICAgIH1cbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IERyYWdNaXhpbjtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3NyYy9qcy9NaXhpbnMvRHJhZy5qc1xuLy8gbW9kdWxlIGlkID0gMThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=");

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nvar PMButton = L.Control.extend({\n    options: {\n        position: 'topleft'\n    },\n    // TODO: clean up variable names like _button should be _options and that domNodeVariable stuff\n    initialize: function initialize(options) {\n        this._button = L.Util.setOptions(this, options);\n    },\n    onAdd: function onAdd(map) {\n        this._map = map;\n\n        this._container = this._map.pm.Toolbar.container;\n        this.buttonsDomNode = this._makeButton(this._button);\n        this._container.appendChild(this.buttonsDomNode);\n\n        return this._container;\n    },\n    onRemove: function onRemove() {\n        this.buttonsDomNode.remove();\n\n        return this._container;\n    },\n    getText: function getText() {\n        return this._button.text;\n    },\n    getIconUrl: function getIconUrl() {\n        return this._button.iconUrl;\n    },\n    destroy: function destroy() {\n        this._button = {};\n        this._update();\n    },\n    toggle: function toggle(e) {\n        if (typeof e === 'boolean') {\n            this._button.toggleStatus = e;\n        } else {\n            this._button.toggleStatus = !this._button.toggleStatus;\n        }\n        this._applyStyleClasses();\n\n        return this._button.toggleStatus;\n    },\n    toggled: function toggled() {\n        return this._button.toggleStatus;\n    },\n    onCreate: function onCreate() {\n        this.toggle(false);\n    },\n    _triggerClick: function _triggerClick(e) {\n        this._button.onClick(e);\n        this._clicked(e);\n        this._button.afterClick(e);\n    },\n    _makeButton: function _makeButton(button) {\n        var _this = this;\n\n        var newButton = L.DomUtil.create('a', 'leaflet-buttons-control-button', this._container);\n        if (button.toggleStatus) {\n            L.DomUtil.addClass(newButton, 'active');\n        }\n\n        var image = L.DomUtil.create('div', 'control-icon', newButton);\n        if (button.iconUrl) {\n            image.setAttribute('src', button.iconUrl);\n        }\n        if (button.className) {\n            L.DomUtil.addClass(image, button.className);\n        }\n        // before the actual click, trigger a click on currently toggled buttons to\n        // untoggle them and their functionality\n        L.DomEvent.addListener(newButton, 'click', function () {\n            if (_this._button.disableOtherButtons) {\n                _this._map.pm.Toolbar.triggerClickOnToggledButtons(_this);\n            }\n        });\n        L.DomEvent.addListener(newButton, 'click', this._triggerClick, this);\n\n        L.DomEvent.disableClickPropagation(newButton);\n        return newButton;\n    },\n    _applyStyleClasses: function _applyStyleClasses() {\n        if (!this._container) {\n            return;\n        }\n\n        if (!this._button.toggleStatus) {\n            L.DomUtil.removeClass(this.buttonsDomNode, 'active');\n        } else {\n            L.DomUtil.addClass(this.buttonsDomNode, 'active');\n        }\n    },\n    _clicked: function _clicked() {\n        if (this._button.doToggle) {\n            this.toggle();\n        }\n        return;\n    }\n});\n\nexports.default = PMButton;//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTkuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvanMvVG9vbGJhci9MLkNvbnRyb2xzLmpzPzlhYTEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG52YXIgUE1CdXR0b24gPSBMLkNvbnRyb2wuZXh0ZW5kKHtcbiAgICBvcHRpb25zOiB7XG4gICAgICAgIHBvc2l0aW9uOiAndG9wbGVmdCdcbiAgICB9LFxuICAgIC8vIFRPRE86IGNsZWFuIHVwIHZhcmlhYmxlIG5hbWVzIGxpa2UgX2J1dHRvbiBzaG91bGQgYmUgX29wdGlvbnMgYW5kIHRoYXQgZG9tTm9kZVZhcmlhYmxlIHN0dWZmXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZShvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuX2J1dHRvbiA9IEwuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgb25BZGQ6IGZ1bmN0aW9uIG9uQWRkKG1hcCkge1xuICAgICAgICB0aGlzLl9tYXAgPSBtYXA7XG5cbiAgICAgICAgdGhpcy5fY29udGFpbmVyID0gdGhpcy5fbWFwLnBtLlRvb2xiYXIuY29udGFpbmVyO1xuICAgICAgICB0aGlzLmJ1dHRvbnNEb21Ob2RlID0gdGhpcy5fbWFrZUJ1dHRvbih0aGlzLl9idXR0b24pO1xuICAgICAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5idXR0b25zRG9tTm9kZSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcbiAgICB9LFxuICAgIG9uUmVtb3ZlOiBmdW5jdGlvbiBvblJlbW92ZSgpIHtcbiAgICAgICAgdGhpcy5idXR0b25zRG9tTm9kZS5yZW1vdmUoKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fY29udGFpbmVyO1xuICAgIH0sXG4gICAgZ2V0VGV4dDogZnVuY3Rpb24gZ2V0VGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1dHRvbi50ZXh0O1xuICAgIH0sXG4gICAgZ2V0SWNvblVybDogZnVuY3Rpb24gZ2V0SWNvblVybCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J1dHRvbi5pY29uVXJsO1xuICAgIH0sXG4gICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fYnV0dG9uID0ge307XG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgIH0sXG4gICAgdG9nZ2xlOiBmdW5jdGlvbiB0b2dnbGUoZSkge1xuICAgICAgICBpZiAodHlwZW9mIGUgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgdGhpcy5fYnV0dG9uLnRvZ2dsZVN0YXR1cyA9IGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9idXR0b24udG9nZ2xlU3RhdHVzID0gIXRoaXMuX2J1dHRvbi50b2dnbGVTdGF0dXM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXBwbHlTdHlsZUNsYXNzZXMoKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fYnV0dG9uLnRvZ2dsZVN0YXR1cztcbiAgICB9LFxuICAgIHRvZ2dsZWQ6IGZ1bmN0aW9uIHRvZ2dsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9idXR0b24udG9nZ2xlU3RhdHVzO1xuICAgIH0sXG4gICAgb25DcmVhdGU6IGZ1bmN0aW9uIG9uQ3JlYXRlKCkge1xuICAgICAgICB0aGlzLnRvZ2dsZShmYWxzZSk7XG4gICAgfSxcbiAgICBfdHJpZ2dlckNsaWNrOiBmdW5jdGlvbiBfdHJpZ2dlckNsaWNrKGUpIHtcbiAgICAgICAgdGhpcy5fYnV0dG9uLm9uQ2xpY2soZSk7XG4gICAgICAgIHRoaXMuX2NsaWNrZWQoZSk7XG4gICAgICAgIHRoaXMuX2J1dHRvbi5hZnRlckNsaWNrKGUpO1xuICAgIH0sXG4gICAgX21ha2VCdXR0b246IGZ1bmN0aW9uIF9tYWtlQnV0dG9uKGJ1dHRvbikge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBuZXdCdXR0b24gPSBMLkRvbVV0aWwuY3JlYXRlKCdhJywgJ2xlYWZsZXQtYnV0dG9ucy1jb250cm9sLWJ1dHRvbicsIHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgIGlmIChidXR0b24udG9nZ2xlU3RhdHVzKSB7XG4gICAgICAgICAgICBMLkRvbVV0aWwuYWRkQ2xhc3MobmV3QnV0dG9uLCAnYWN0aXZlJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW1hZ2UgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnY29udHJvbC1pY29uJywgbmV3QnV0dG9uKTtcbiAgICAgICAgaWYgKGJ1dHRvbi5pY29uVXJsKSB7XG4gICAgICAgICAgICBpbWFnZS5zZXRBdHRyaWJ1dGUoJ3NyYycsIGJ1dHRvbi5pY29uVXJsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnV0dG9uLmNsYXNzTmFtZSkge1xuICAgICAgICAgICAgTC5Eb21VdGlsLmFkZENsYXNzKGltYWdlLCBidXR0b24uY2xhc3NOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBiZWZvcmUgdGhlIGFjdHVhbCBjbGljaywgdHJpZ2dlciBhIGNsaWNrIG9uIGN1cnJlbnRseSB0b2dnbGVkIGJ1dHRvbnMgdG9cbiAgICAgICAgLy8gdW50b2dnbGUgdGhlbSBhbmQgdGhlaXIgZnVuY3Rpb25hbGl0eVxuICAgICAgICBMLkRvbUV2ZW50LmFkZExpc3RlbmVyKG5ld0J1dHRvbiwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLl9idXR0b24uZGlzYWJsZU90aGVyQnV0dG9ucykge1xuICAgICAgICAgICAgICAgIF90aGlzLl9tYXAucG0uVG9vbGJhci50cmlnZ2VyQ2xpY2tPblRvZ2dsZWRCdXR0b25zKF90aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIEwuRG9tRXZlbnQuYWRkTGlzdGVuZXIobmV3QnV0dG9uLCAnY2xpY2snLCB0aGlzLl90cmlnZ2VyQ2xpY2ssIHRoaXMpO1xuXG4gICAgICAgIEwuRG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24obmV3QnV0dG9uKTtcbiAgICAgICAgcmV0dXJuIG5ld0J1dHRvbjtcbiAgICB9LFxuICAgIF9hcHBseVN0eWxlQ2xhc3NlczogZnVuY3Rpb24gX2FwcGx5U3R5bGVDbGFzc2VzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9idXR0b24udG9nZ2xlU3RhdHVzKSB7XG4gICAgICAgICAgICBMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5idXR0b25zRG9tTm9kZSwgJ2FjdGl2ZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgTC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuYnV0dG9uc0RvbU5vZGUsICdhY3RpdmUnKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgX2NsaWNrZWQ6IGZ1bmN0aW9uIF9jbGlja2VkKCkge1xuICAgICAgICBpZiAodGhpcy5fYnV0dG9uLmRvVG9nZ2xlKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUE1CdXR0b247XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9zcmMvanMvVG9vbGJhci9MLkNvbnRyb2xzLmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==");

/***/ })
/******/ ]);